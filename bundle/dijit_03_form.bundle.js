/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "bundle/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// Example from: https://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/index.html
	var parser = __webpack_require__(84);
	
	__webpack_require__(154);
	__webpack_require__(159);
	__webpack_require__(184);
	__webpack_require__(199);
	__webpack_require__(114);
	
	var dojoRequire = __webpack_require__(6);
	dojoRequire.register("dojo/store/JsonRest", __webpack_require__(201));
	
	parser.parse();

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has, lang){
		// module:
		//		dojo/_base/declare
	
		var mix = lang.mixin, op = Object.prototype, opts = op.toString,
			xtor, counter = 0, cname = "constructor";
	
		if(!has("csp-restrictions")){
			xtor = new Function;
		}else{
			xtor = function(){};
		}
	
		function err(msg, cls){ throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg); }
	
		// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
		function c3mro(bases, className){
			var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,
				l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;
	
			// build a list of bases naming them if needed
			for(; i < l; ++i){
				base = bases[i];
				if(!base){
					err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
				}else if(opts.call(base) != "[object Function]"){
					err("mixin #" + i + " is not a callable constructor.", className);
				}
				lin = base._meta ? base._meta.bases : [base];
				top = 0;
				// add bases to the name map
				for(j = lin.length - 1; j >= 0; --j){
					proto = lin[j].prototype;
					if(!proto.hasOwnProperty("declaredClass")){
						proto.declaredClass = "uniqName_" + (counter++);
					}
					name = proto.declaredClass;
					if(!nameMap.hasOwnProperty(name)){
						nameMap[name] = {count: 0, refs: [], cls: lin[j]};
						++clsCount;
					}
					rec = nameMap[name];
					if(top && top !== rec){
						rec.refs.push(top);
						++top.count;
					}
					top = rec;
				}
				++top.count;
				roots[0].refs.push(top);
			}
	
			// remove classes without external references recursively
			while(roots.length){
				top = roots.pop();
				result.push(top.cls);
				--clsCount;
				// optimization: follow a single-linked chain
				while(refs = top.refs, refs.length == 1){
					top = refs[0];
					if(!top || --top.count){
						// branch or end of chain => do not end to roots
						top = 0;
						break;
					}
					result.push(top.cls);
					--clsCount;
				}
				if(top){
					// branch
					for(i = 0, l = refs.length; i < l; ++i){
						top = refs[i];
						if(!--top.count){
							roots.push(top);
						}
					}
				}
			}
			if(clsCount){
				err("can't build consistent linearization", className);
			}
	
			// calculate the superclass offset
			base = bases[0];
			result[0] = base ?
				base._meta && base === result[result.length - base._meta.bases.length] ?
					base._meta.bases.length : 1 : 0;
	
			return result;
		}
	
		function inherited(args, a, f){
			var name, chains, bases, caller, meta, base, proto, opf, pos,
				cache = this._inherited = this._inherited || {};
	
			// crack arguments
			if(typeof args == "string"){
				name = args;
				args = a;
				a = f;
			}
			f = 0;
	
			caller = args.callee;
			name = name || caller.nom;
			if(!name){
				err("can't deduce a name to call inherited()", this.declaredClass);
			}
	
			meta = this.constructor._meta;
			bases = meta.bases;
	
			pos = cache.p;
			if(name != cname){
				// method
				if(cache.c !== caller){
					// cache bust
					pos = 0;
					base = bases[0];
					meta = base._meta;
					if(meta.hidden[name] !== caller){
						// error detection
						chains = meta.chains;
						if(chains && typeof chains[name] == "string"){
							err("calling chained method with inherited: " + name, this.declaredClass);
						}
						// find caller
						do{
							meta = base._meta;
							proto = base.prototype;
							if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){
								break;
							}
						}while(base = bases[++pos]); // intentional assignment
						pos = base ? pos : -1;
					}
				}
				// find next
				base = bases[++pos];
				if(base){
					proto = base.prototype;
					if(base._meta && proto.hasOwnProperty(name)){
						f = proto[name];
					}else{
						opf = op[name];
						do{
							proto = base.prototype;
							f = proto[name];
							if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){
								break;
							}
						}while(base = bases[++pos]); // intentional assignment
					}
				}
				f = base && f || op[name];
			}else{
				// constructor
				if(cache.c !== caller){
					// cache bust
					pos = 0;
					meta = bases[0]._meta;
					if(meta && meta.ctor !== caller){
						// error detection
						chains = meta.chains;
						if(!chains || chains.constructor !== "manual"){
							err("calling chained constructor with inherited", this.declaredClass);
						}
						// find caller
						while(base = bases[++pos]){ // intentional assignment
							meta = base._meta;
							if(meta && meta.ctor === caller){
								break;
							}
						}
						pos = base ? pos : -1;
					}
				}
				// find next
				while(base = bases[++pos]){	// intentional assignment
					meta = base._meta;
					f = meta ? meta.ctor : base;
					if(f){
						break;
					}
				}
				f = base && f;
			}
	
			// cache the found super method
			cache.c = f;
			cache.p = pos;
	
			// now we have the result
			if(f){
				return a === true ? f : f.apply(this, a || args);
			}
			// intentionally no return if a super method was not found
		}
	
		function getInherited(name, args){
			if(typeof name == "string"){
				return this.__inherited(name, args, true);
			}
			return this.__inherited(name, true);
		}
	
		function inherited__debug(args, a1, a2){
			var f = this.getInherited(args, a1);
			if(f){ return f.apply(this, a2 || a1 || args); }
			// intentionally no return if a super method was not found
		}
	
		var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;
	
		// emulation of "instanceof"
		function isInstanceOf(cls){
			var bases = this.constructor._meta.bases;
			for(var i = 0, l = bases.length; i < l; ++i){
				if(bases[i] === cls){
					return true;
				}
			}
			return this instanceof cls;
		}
	
		function mixOwn(target, source){
			// add props adding metadata for incoming functions skipping a constructor
			for(var name in source){
				if(name != cname && source.hasOwnProperty(name)){
					target[name] = source[name];
				}
			}
			if(has("bug-for-in-skips-shadowed")){
				for(var extraNames= lang._extraNames, i= extraNames.length; i;){
					name = extraNames[--i];
					if(name != cname && source.hasOwnProperty(name)){
						  target[name] = source[name];
					}
				}
			}
		}
	
		// implementation of safe mixin function
		function safeMixin(target, source){
			// summary:
			//		Mix in properties skipping a constructor and decorating functions
			//		like it is done by declare().
			// target: Object
			//		Target object to accept new properties.
			// source: Object
			//		Source object for new properties.
			// description:
			//		This function is used to mix in properties like lang.mixin does,
			//		but it skips a constructor property and decorates functions like
			//		declare() does.
			//
			//		It is meant to be used with classes and objects produced with
			//		declare. Functions mixed in with dojo.safeMixin can use
			//		this.inherited() like normal methods.
			//
			//		This function is used to implement extend() method of a constructor
			//		produced with declare().
			//
			// example:
			//	|	var A = declare(null, {
			//	|		m1: function(){
			//	|			console.log("A.m1");
			//	|		},
			//	|		m2: function(){
			//	|			console.log("A.m2");
			//	|		}
			//	|	});
			//	|	var B = declare(A, {
			//	|		m1: function(){
			//	|			this.inherited(arguments);
			//	|			console.log("B.m1");
			//	|		}
			//	|	});
			//	|	B.extend({
			//	|		m2: function(){
			//	|			this.inherited(arguments);
			//	|			console.log("B.m2");
			//	|		}
			//	|	});
			//	|	var x = new B();
			//	|	dojo.safeMixin(x, {
			//	|		m1: function(){
			//	|			this.inherited(arguments);
			//	|			console.log("X.m1");
			//	|		},
			//	|		m2: function(){
			//	|			this.inherited(arguments);
			//	|			console.log("X.m2");
			//	|		}
			//	|	});
			//	|	x.m2();
			//	|	// prints:
			//	|	// A.m1
			//	|	// B.m1
			//	|	// X.m1
	
			var name, t;
			// add props adding metadata for incoming functions skipping a constructor
			for(name in source){
				t = source[name];
				if((t !== op[name] || !(name in op)) && name != cname){
					if(opts.call(t) == "[object Function]"){
						// non-trivial function method => attach its name
						t.nom = name;
					}
					target[name] = t;
				}
			}
			if(has("bug-for-in-skips-shadowed") && source){
				for(var extraNames= lang._extraNames, i= extraNames.length; i;){
					name = extraNames[--i];
					t = source[name];
					if((t !== op[name] || !(name in op)) && name != cname){
						if(opts.call(t) == "[object Function]"){
							// non-trivial function method => attach its name
							  t.nom = name;
						}
						target[name] = t;
					}
				}
			}
			return target;
		}
	
		function extend(source){
			declare.safeMixin(this.prototype, source);
			return this;
		}
	
	    function createSubclass(mixins, props){
	        // crack parameters
	        if(!(mixins instanceof Array || typeof mixins == 'function')){
	            props = mixins;
	            mixins = undefined;
	        }
	
	        props = props || {};
	        mixins = mixins || [];
	
	        return declare([this].concat(mixins), props);
	    }
	
		// chained constructor compatible with the legacy declare()
		function chainedConstructor(bases, ctorSpecial){
			return function(){
				var a = arguments, args = a, a0 = a[0], f, i, m,
					l = bases.length, preArgs;
	
				if(!(this instanceof a.callee)){
					// not called via new, so force it
					return applyNew(a);
				}
	
				//this._inherited = {};
				// perform the shaman's rituals of the original declare()
				// 1) call two types of the preamble
				if(ctorSpecial && (a0 && a0.preamble || this.preamble)){
					// full blown ritual
					preArgs = new Array(bases.length);
					// prepare parameters
					preArgs[0] = a;
					for(i = 0;;){
						// process the preamble of the 1st argument
						a0 = a[0];
						if(a0){
							f = a0.preamble;
							if(f){
								a = f.apply(this, a) || a;
							}
						}
						// process the preamble of this class
						f = bases[i].prototype;
						f = f.hasOwnProperty("preamble") && f.preamble;
						if(f){
							a = f.apply(this, a) || a;
						}
						// one peculiarity of the preamble:
						// it is called if it is not needed,
						// e.g., there is no constructor to call
						// let's watch for the last constructor
						// (see ticket #9795)
						if(++i == l){
							break;
						}
						preArgs[i] = a;
					}
				}
				// 2) call all non-trivial constructors using prepared arguments
				for(i = l - 1; i >= 0; --i){
					f = bases[i];
					m = f._meta;
					f = m ? m.ctor : f;
					if(f){
						f.apply(this, preArgs ? preArgs[i] : a);
					}
				}
				// 3) continue the original ritual: call the postscript
				f = this.postscript;
				if(f){
					f.apply(this, args);
				}
			};
		}
	
	
		// chained constructor compatible with the legacy declare()
		function singleConstructor(ctor, ctorSpecial){
			return function(){
				var a = arguments, t = a, a0 = a[0], f;
	
				if(!(this instanceof a.callee)){
					// not called via new, so force it
					return applyNew(a);
				}
	
				//this._inherited = {};
				// perform the shaman's rituals of the original declare()
				// 1) call two types of the preamble
				if(ctorSpecial){
					// full blown ritual
					if(a0){
						// process the preamble of the 1st argument
						f = a0.preamble;
						if(f){
							t = f.apply(this, t) || t;
						}
					}
					f = this.preamble;
					if(f){
						// process the preamble of this class
						f.apply(this, t);
						// one peculiarity of the preamble:
						// it is called even if it is not needed,
						// e.g., there is no constructor to call
						// let's watch for the last constructor
						// (see ticket #9795)
					}
				}
				// 2) call a constructor
				if(ctor){
					ctor.apply(this, a);
				}
				// 3) continue the original ritual: call the postscript
				f = this.postscript;
				if(f){
					f.apply(this, a);
				}
			};
		}
	
		// plain vanilla constructor (can use inherited() to call its base constructor)
		function simpleConstructor(bases){
			return function(){
				var a = arguments, i = 0, f, m;
	
				if(!(this instanceof a.callee)){
					// not called via new, so force it
					return applyNew(a);
				}
	
				//this._inherited = {};
				// perform the shaman's rituals of the original declare()
				// 1) do not call the preamble
				// 2) call the top constructor (it can use this.inherited())
				for(; f = bases[i]; ++i){ // intentional assignment
					m = f._meta;
					f = m ? m.ctor : f;
					if(f){
						f.apply(this, a);
						break;
					}
				}
				// 3) call the postscript
				f = this.postscript;
				if(f){
					f.apply(this, a);
				}
			};
		}
	
		function chain(name, bases, reversed){
			return function(){
				var b, m, f, i = 0, step = 1;
				if(reversed){
					i = bases.length - 1;
					step = -1;
				}
				for(; b = bases[i]; i += step){ // intentional assignment
					m = b._meta;
					f = (m ? m.hidden : b.prototype)[name];
					if(f){
						f.apply(this, arguments);
					}
				}
			};
		}
	
		// forceNew(ctor)
		// return a new object that inherits from ctor.prototype but
		// without actually running ctor on the object.
		function forceNew(ctor){
			// create object with correct prototype using a do-nothing
			// constructor
			xtor.prototype = ctor.prototype;
			var t = new xtor;
			xtor.prototype = null;	// clean up
			return t;
		}
	
		// applyNew(args)
		// just like 'new ctor()' except that the constructor and its arguments come
		// from args, which must be an array or an arguments object
		function applyNew(args){
			// create an object with ctor's prototype but without
			// calling ctor on it.
			var ctor = args.callee, t = forceNew(ctor);
			// execute the real constructor on the new object
			ctor.apply(t, args);
			return t;
		}
	
		function declare(className, superclass, props){
			// summary:
			//		Create a feature-rich constructor from compact notation.
			// className: String?
			//		The optional name of the constructor (loosely, a "class")
			//		stored in the "declaredClass" property in the created prototype.
			//		It will be used as a global name for a created constructor.
			// superclass: Function|Function[]
			//		May be null, a Function, or an Array of Functions. This argument
			//		specifies a list of bases (the left-most one is the most deepest
			//		base).
			// props: Object
			//		An object whose properties are copied to the created prototype.
			//		Add an instance-initialization function by making it a property
			//		named "constructor".
			// returns: dojo/_base/declare.__DeclareCreatedObject
			//		New constructor function.
			// description:
			//		Create a constructor using a compact notation for inheritance and
			//		prototype extension.
			//
			//		Mixin ancestors provide a type of multiple inheritance.
			//		Prototypes of mixin ancestors are copied to the new class:
			//		changes to mixin prototypes will not affect classes to which
			//		they have been mixed in.
			//
			//		Ancestors can be compound classes created by this version of
			//		declare(). In complex cases all base classes are going to be
			//		linearized according to C3 MRO algorithm
			//		(see http://www.python.org/download/releases/2.3/mro/ for more
			//		details).
			//
			//		"className" is cached in "declaredClass" property of the new class,
			//		if it was supplied. The immediate super class will be cached in
			//		"superclass" property of the new class.
			//
			//		Methods in "props" will be copied and modified: "nom" property
			//		(the declared name of the method) will be added to all copied
			//		functions to help identify them for the internal machinery. Be
			//		very careful, while reusing methods: if you use the same
			//		function under different names, it can produce errors in some
			//		cases.
			//
			//		It is possible to use constructors created "manually" (without
			//		declare()) as bases. They will be called as usual during the
			//		creation of an instance, their methods will be chained, and even
			//		called by "this.inherited()".
			//
			//		Special property "-chains-" governs how to chain methods. It is
			//		a dictionary, which uses method names as keys, and hint strings
			//		as values. If a hint string is "after", this method will be
			//		called after methods of its base classes. If a hint string is
			//		"before", this method will be called before methods of its base
			//		classes.
			//
			//		If "constructor" is not mentioned in "-chains-" property, it will
			//		be chained using the legacy mode: using "after" chaining,
			//		calling preamble() method before each constructor, if available,
			//		and calling postscript() after all constructors were executed.
			//		If the hint is "after", it is chained as a regular method, but
			//		postscript() will be called after the chain of constructors.
			//		"constructor" cannot be chained "before", but it allows
			//		a special hint string: "manual", which means that constructors
			//		are not going to be chained in any way, and programmer will call
			//		them manually using this.inherited(). In the latter case
			//		postscript() will be called after the construction.
			//
			//		All chaining hints are "inherited" from base classes and
			//		potentially can be overridden. Be very careful when overriding
			//		hints! Make sure that all chained methods can work in a proposed
			//		manner of chaining.
			//
			//		Once a method was chained, it is impossible to unchain it. The
			//		only exception is "constructor". You don't need to define a
			//		method in order to supply a chaining hint.
			//
			//		If a method is chained, it cannot use this.inherited() because
			//		all other methods in the hierarchy will be called automatically.
			//
			//		Usually constructors and initializers of any kind are chained
			//		using "after" and destructors of any kind are chained as
			//		"before". Note that chaining assumes that chained methods do not
			//		return any value: any returned value will be discarded.
			//
			// example:
			//	|	declare("my.classes.bar", my.classes.foo, {
			//	|		// properties to be added to the class prototype
			//	|		someValue: 2,
			//	|		// initialization function
			//	|		constructor: function(){
			//	|			this.myComplicatedObject = new ReallyComplicatedObject();
			//	|		},
			//	|		// other functions
			//	|		someMethod: function(){
			//	|			doStuff();
			//	|		}
			//	|	});
			//
			// example:
			//	|	var MyBase = declare(null, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var MyClass1 = declare(MyBase, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var MyClass2 = declare(MyBase, {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//	|	var MyDiamond = declare([MyClass1, MyClass2], {
			//	|		// constructor, properties, and methods go here
			//	|		// ...
			//	|	});
			//
			// example:
			//	|	var F = function(){ console.log("raw constructor"); };
			//	|	F.prototype.method = function(){
			//	|		console.log("raw method");
			//	|	};
			//	|	var A = declare(F, {
			//	|		constructor: function(){
			//	|			console.log("A.constructor");
			//	|		},
			//	|		method: function(){
			//	|			console.log("before calling F.method...");
			//	|			this.inherited(arguments);
			//	|			console.log("...back in A");
			//	|		}
			//	|	});
			//	|	new A().method();
			//	|	// will print:
			//	|	// raw constructor
			//	|	// A.constructor
			//	|	// before calling F.method...
			//	|	// raw method
			//	|	// ...back in A
			//
			// example:
			//	|	var A = declare(null, {
			//	|		"-chains-": {
			//	|			destroy: "before"
			//	|		}
			//	|	});
			//	|	var B = declare(A, {
			//	|		constructor: function(){
			//	|			console.log("B.constructor");
			//	|		},
			//	|		destroy: function(){
			//	|			console.log("B.destroy");
			//	|		}
			//	|	});
			//	|	var C = declare(B, {
			//	|		constructor: function(){
			//	|			console.log("C.constructor");
			//	|		},
			//	|		destroy: function(){
			//	|			console.log("C.destroy");
			//	|		}
			//	|	});
			//	|	new C().destroy();
			//	|	// prints:
			//	|	// B.constructor
			//	|	// C.constructor
			//	|	// C.destroy
			//	|	// B.destroy
			//
			// example:
			//	|	var A = declare(null, {
			//	|		"-chains-": {
			//	|			constructor: "manual"
			//	|		}
			//	|	});
			//	|	var B = declare(A, {
			//	|		constructor: function(){
			//	|			// ...
			//	|			// call the base constructor with new parameters
			//	|			this.inherited(arguments, [1, 2, 3]);
			//	|			// ...
			//	|		}
			//	|	});
			//
			// example:
			//	|	var A = declare(null, {
			//	|		"-chains-": {
			//	|			m1: "before"
			//	|		},
			//	|		m1: function(){
			//	|			console.log("A.m1");
			//	|		},
			//	|		m2: function(){
			//	|			console.log("A.m2");
			//	|		}
			//	|	});
			//	|	var B = declare(A, {
			//	|		"-chains-": {
			//	|			m2: "after"
			//	|		},
			//	|		m1: function(){
			//	|			console.log("B.m1");
			//	|		},
			//	|		m2: function(){
			//	|			console.log("B.m2");
			//	|		}
			//	|	});
			//	|	var x = new B();
			//	|	x.m1();
			//	|	// prints:
			//	|	// B.m1
			//	|	// A.m1
			//	|	x.m2();
			//	|	// prints:
			//	|	// A.m2
			//	|	// B.m2
	
			// crack parameters
			if(typeof className != "string"){
				props = superclass;
				superclass = className;
				className = "";
			}
			props = props || {};
	
			var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;
	
			// build a prototype
			if(opts.call(superclass) == "[object Array]"){
				// C3 MRO
				bases = c3mro(superclass, className);
				t = bases[0];
				mixins = bases.length - t;
				superclass = bases[mixins];
			}else{
				bases = [0];
				if(superclass){
					if(opts.call(superclass) == "[object Function]"){
						t = superclass._meta;
						bases = bases.concat(t ? t.bases : superclass);
					}else{
						err("base class is not a callable constructor.", className);
					}
				}else if(superclass !== null){
					err("unknown base class. Did you use dojo.require to pull it in?", className);
				}
			}
			if(superclass){
				for(i = mixins - 1;; --i){
					proto = forceNew(superclass);
					if(!i){
						// stop if nothing to add (the last base)
						break;
					}
					// mix in properties
					t = bases[i];
					(t._meta ? mixOwn : mix)(proto, t.prototype);
					// chain in new constructor
					ctor = new Function;
					ctor.superclass = superclass;
					ctor.prototype = proto;
					superclass = proto.constructor = ctor;
				}
			}else{
				proto = {};
			}
			// add all properties
			declare.safeMixin(proto, props);
			// add constructor
			t = props.constructor;
			if(t !== op.constructor){
				t.nom = cname;
				proto.constructor = t;
			}
	
			// collect chains and flags
			for(i = mixins - 1; i; --i){ // intentional assignment
				t = bases[i]._meta;
				if(t && t.chains){
					chains = mix(chains || {}, t.chains);
				}
			}
			if(proto["-chains-"]){
				chains = mix(chains || {}, proto["-chains-"]);
			}
	
			// build ctor
			t = !chains || !chains.hasOwnProperty(cname);
			bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) :
				(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));
	
			// add meta information to the constructor
			ctor._meta  = {bases: bases, hidden: props, chains: chains,
				parents: parents, ctor: props.constructor};
			ctor.superclass = superclass && superclass.prototype;
			ctor.extend = extend;
			ctor.createSubclass = createSubclass;
			ctor.prototype = proto;
			proto.constructor = ctor;
	
			// add "standard" methods to the prototype
			proto.getInherited = getInherited;
			proto.isInstanceOf = isInstanceOf;
			proto.inherited    = inheritedImpl;
			proto.__inherited  = inherited;
	
			// add name if specified
			if(className){
				proto.declaredClass = className;
				lang.setObject(className, ctor);
			}
	
			// build chains and add them to the prototype
			if(chains){
				for(name in chains){
					if(proto[name] && typeof chains[name] == "string" && name != cname){
						t = proto[name] = chain(name, bases, chains[name] === "after");
						t.nom = name;
					}
				}
			}
			// chained methods do not return values
			// no need to chain "invisible" functions
	
			return ctor;	// Function
		}
	
		/*=====
		declare.__DeclareCreatedObject = {
			// summary:
			//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
			//		methods, in addition to the methods and properties specified via the arguments passed to declare().
	
			inherited: function(name, args, newArgs){
				// summary:
				//		Calls a super method.
				// name: String?
				//		The optional method name. Should be the same as the caller's
				//		name. Usually "name" is specified in complex dynamic cases, when
				//		the calling method was dynamically added, undecorated by
				//		declare(), and it cannot be determined.
				// args: Arguments
				//		The caller supply this argument, which should be the original
				//		"arguments".
				// newArgs: Object?
				//		If "true", the found function will be returned without
				//		executing it.
				//		If Array, it will be used to call a super method. Otherwise
				//		"args" will be used.
				// returns:
				//		Whatever is returned by a super method, or a super method itself,
				//		if "true" was specified as newArgs.
				// description:
				//		This method is used inside method of classes produced with
				//		declare() to call a super method (next in the chain). It is
				//		used for manually controlled chaining. Consider using the regular
				//		chaining, because it is faster. Use "this.inherited()" only in
				//		complex cases.
				//
				//		This method cannot me called from automatically chained
				//		constructors including the case of a special (legacy)
				//		constructor chaining. It cannot be called from chained methods.
				//
				//		If "this.inherited()" cannot find the next-in-chain method, it
				//		does nothing and returns "undefined". The last method in chain
				//		can be a default method implemented in Object, which will be
				//		called last.
				//
				//		If "name" is specified, it is assumed that the method that
				//		received "args" is the parent method for this call. It is looked
				//		up in the chain list and if it is found the next-in-chain method
				//		is called. If it is not found, the first-in-chain method is
				//		called.
				//
				//		If "name" is not specified, it will be derived from the calling
				//		method (using a methoid property "nom").
				//
				// example:
				//	|	var B = declare(A, {
				//	|		method1: function(a, b, c){
				//	|			this.inherited(arguments);
				//	|		},
				//	|		method2: function(a, b){
				//	|			return this.inherited(arguments, [a + b]);
				//	|		}
				//	|	});
				//	|	// next method is not in the chain list because it is added
				//	|	// manually after the class was created.
				//	|	B.prototype.method3 = function(){
				//	|		console.log("This is a dynamically-added method.");
				//	|		this.inherited("method3", arguments);
				//	|	};
				// example:
				//	|	var B = declare(A, {
				//	|		method: function(a, b){
				//	|			var super = this.inherited(arguments, true);
				//	|			// ...
				//	|			if(!super){
				//	|				console.log("there is no super method");
				//	|				return 0;
				//	|			}
				//	|			return super.apply(this, arguments);
				//	|		}
				//	|	});
				return	{};	// Object
			},
	
			getInherited: function(name, args){
				// summary:
				//		Returns a super method.
				// name: String?
				//		The optional method name. Should be the same as the caller's
				//		name. Usually "name" is specified in complex dynamic cases, when
				//		the calling method was dynamically added, undecorated by
				//		declare(), and it cannot be determined.
				// args: Arguments
				//		The caller supply this argument, which should be the original
				//		"arguments".
				// returns:
				//		Returns a super method (Function) or "undefined".
				// description:
				//		This method is a convenience method for "this.inherited()".
				//		It uses the same algorithm but instead of executing a super
				//		method, it returns it, or "undefined" if not found.
				//
				// example:
				//	|	var B = declare(A, {
				//	|		method: function(a, b){
				//	|			var super = this.getInherited(arguments);
				//	|			// ...
				//	|			if(!super){
				//	|				console.log("there is no super method");
				//	|				return 0;
				//	|			}
				//	|			return super.apply(this, arguments);
				//	|		}
				//	|	});
				return	{};	// Object
			},
	
			isInstanceOf: function(cls){
				// summary:
				//		Checks the inheritance chain to see if it is inherited from this
				//		class.
				// cls: Function
				//		Class constructor.
				// returns:
				//		"true", if this object is inherited from this class, "false"
				//		otherwise.
				// description:
				//		This method is used with instances of classes produced with
				//		declare() to determine of they support a certain interface or
				//		not. It models "instanceof" operator.
				//
				// example:
				//	|	var A = declare(null, {
				//	|		// constructor, properties, and methods go here
				//	|		// ...
				//	|	});
				//	|	var B = declare(null, {
				//	|		// constructor, properties, and methods go here
				//	|		// ...
				//	|	});
				//	|	var C = declare([A, B], {
				//	|		// constructor, properties, and methods go here
				//	|		// ...
				//	|	});
				//	|	var D = declare(A, {
				//	|		// constructor, properties, and methods go here
				//	|		// ...
				//	|	});
				//	|
				//	|	var a = new A(), b = new B(), c = new C(), d = new D();
				//	|
				//	|	console.log(a.isInstanceOf(A)); // true
				//	|	console.log(b.isInstanceOf(A)); // false
				//	|	console.log(c.isInstanceOf(A)); // true
				//	|	console.log(d.isInstanceOf(A)); // true
				//	|
				//	|	console.log(a.isInstanceOf(B)); // false
				//	|	console.log(b.isInstanceOf(B)); // true
				//	|	console.log(c.isInstanceOf(B)); // true
				//	|	console.log(d.isInstanceOf(B)); // false
				//	|
				//	|	console.log(a.isInstanceOf(C)); // false
				//	|	console.log(b.isInstanceOf(C)); // false
				//	|	console.log(c.isInstanceOf(C)); // true
				//	|	console.log(d.isInstanceOf(C)); // false
				//	|
				//	|	console.log(a.isInstanceOf(D)); // false
				//	|	console.log(b.isInstanceOf(D)); // false
				//	|	console.log(c.isInstanceOf(D)); // false
				//	|	console.log(d.isInstanceOf(D)); // true
				return	{};	// Object
			},
	
			extend: function(source){
				// summary:
				//		Adds all properties and methods of source to constructor's
				//		prototype, making them available to all instances created with
				//		constructor. This method is specific to constructors created with
				//		declare().
				// source: Object
				//		Source object which properties are going to be copied to the
				//		constructor's prototype.
				// description:
				//		Adds source properties to the constructor's prototype. It can
				//		override existing properties.
				//
				//		This method is similar to dojo.extend function, but it is specific
				//		to constructors produced by declare(). It is implemented
				//		using dojo.safeMixin, and it skips a constructor property,
				//		and properly decorates copied functions.
				//
				// example:
				//	|	var A = declare(null, {
				//	|		m1: function(){},
				//	|		s1: "Popokatepetl"
				//	|	});
				//	|	A.extend({
				//	|		m1: function(){},
				//	|		m2: function(){},
				//	|		f1: true,
				//	|		d1: 42
				//	|	});
			},
	
			createSubclass: function(mixins, props){
				// summary:
				//		Create a subclass of the declared class from a list of base classes.
				// mixins: Function[]
				//		Specifies a list of bases (the left-most one is the most deepest
				//		base).
				// props: Object?
				//		An optional object whose properties are copied to the created prototype.
				// returns: dojo/_base/declare.__DeclareCreatedObject
				//		New constructor function.
				// description:
				//		Create a constructor using a compact notation for inheritance and
				//		prototype extension.
				//
				//		Mixin ancestors provide a type of multiple inheritance.
				//		Prototypes of mixin ancestors are copied to the new class:
				//		changes to mixin prototypes will not affect classes to which
				//		they have been mixed in.
				//
				// example:
				//	|	var A = declare(null, {
				//	|		m1: function(){},
				//	|		s1: "bar"
				//	|	});
				//	|	var B = declare(null, {
				//	|		m2: function(){},
				//	|		s2: "foo"
				//	|	});
				//	|	var C = declare(null, {
				//	|	});
				//	|	var D1 = A.createSubclass([B, C], {
				//	|		m1: function(){},
				//	|		d1: 42
				//	|	});
				//	|	var d1 = new D1();
				//	|
				//	|	// this is equivalent to:
				//	|	var D2 = declare([A, B, C], {
				//	|		m1: function(){},
				//	|		d1: 42
				//	|	});
				//	|	var d2 = new D2();
			}
		};
		=====*/
	
		// For back-compat, remove for 2.0
		dojo.safeMixin = declare.safeMixin = safeMixin;
		dojo.declare = declare;
	
		return declare;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4), __webpack_require__(7), __webpack_require__(6), module], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, config, require, module){module={id:"dojo/_base/kernel"}
		// module:
		//		dojo/_base/kernel
	
		// This module is the foundational module of the dojo boot sequence; it defines the dojo object.
	
		var
			// loop variables for this module
			i, p,
	
			// create dojo, dijit, and dojox
			// FIXME: in 2.0 remove dijit, dojox being created by dojo
			global = (function () { return this; })(),
			dijit = {},
			dojox = {},
			dojo = {
				// summary:
				//		This module is the foundational module of the dojo boot sequence; it defines the dojo object.
	
				// notice dojo takes ownership of the value of the config module
				config:config,
				global:global,
				dijit:dijit,
				dojox:dojox
			};
	
	
		// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
		// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
		// unique names in the global space.
		//
		// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
		// where global when in fact they are either global under different names or not global at all. In v1.6-, the
		// config variable "scopeMap" was used to map names as used within a module to global names. This has been
		// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
		// only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
		//
		// The following computations contort the packageMap for this dojo instance into a scopeMap.
		var scopeMap =
				// a map from a name used in a legacy module to the (global variable name, object addressed by that name)
				// always map dojo, dijit, and dojox
				{
					dojo:["dojo", dojo],
					dijit:["dijit", dijit],
					dojox:["dojox", dojox]
				},
	
			packageMap =
				// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config
				(require.map && require.map[module.id.match(/[^\/]+/)[0]]),
	
			item;
	
	
		// process all mapped top-level names for this instance of dojo
		for(p in packageMap){
			if(scopeMap[p]){
				// mapped dojo, dijit, or dojox
				scopeMap[p][0] = packageMap[p];
			}else{
				// some other top-level name
				scopeMap[p] = [packageMap[p], {}];
			}
		}
	
		// publish those names to _scopeName and, optionally, the global namespace
		for(p in scopeMap){
			item = scopeMap[p];
			item[1]._scopeName = item[0];
			if(!config.noGlobals){
				global[item[0]] = item[1];
			}
		}
		dojo.scopeMap = scopeMap;
	
		/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/
	
		// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
		dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
		dojo.isAsync = !has("dojo-loader") || require.async;
		dojo.locale = config.locale;
	
		var rev = "$Rev: 3594395 $".match(/[0-9a-f]{7,}/);
		dojo.version = {
			// summary:
			//		Version number of the Dojo Toolkit
			// description:
			//		Hash about the version, including
			//
			//		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
			//		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
			//		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
			//		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
			//		- revision: Number: The Git rev from which dojo was pulled
	
			major: 1, minor: 11, patch: 1, flag: "",
			revision: rev ? rev[0] : NaN,
			toString: function(){
				var v = dojo.version;
				return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";	// String
			}
		};
	
		// If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
		// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
		// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
		// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
		has.add("extend-dojo", 1);
	
		if(!has("csp-restrictions")){
			(Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
		}
		/*=====
		dojo.eval = function(scriptText){
			// summary:
			//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
			//		directly unless you understand its possibly-different implications on the platforms your are targeting.
			// description:
			//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
			//		that support indirect eval.
			//
			//		As usual, IE does not. On IE, the only way to implement global eval is to
			//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
			//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
			//		frame below the global scope; thereby coming close to the global scope. Note carefully that
			//
			//		dojo.eval("var pi = 3.14;");
			//
			//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
			//		to define a global variable using dojo.eval, write something like
			//
			//		dojo.eval("window.pi = 3.14;")
			// scriptText:
			//		The text to evaluation.
			// returns:
			//		The result of the evaluation. Often `undefined`
		};
		=====*/
	
	
		if(has("host-rhino")){
			dojo.exit = function(exitcode){
				quit(exitcode);
			};
		}else{
			dojo.exit = function(){
			};
		}
	
		if(!has("host-webworker")){
			// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100
			has.add("dojo-guarantee-console",
				// ensure that console.log, console.warn, etc. are defined
				1
			);
		}
	
		if(has("dojo-guarantee-console")){
			// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197
			has.add("console-as-object", Function.prototype.bind && console && typeof console.log === "object");
			typeof console != "undefined" || (console = {});  // intentional assignment
			//	Be careful to leave 'log' always at the end
			var cn = [
				"assert", "count", "debug", "dir", "dirxml", "error", "group",
				"groupEnd", "info", "profile", "profileEnd", "time", "timeEnd",
				"trace", "warn", "log"
			];
			var tn;
			i = 0;
			while((tn = cn[i++])){
				if(!console[tn]){
					(function(){
						var tcn = tn + "";
						console[tcn] = ('log' in console) ? function(){
							var a = Array.prototype.slice.call(arguments);
							a.unshift(tcn + ":");
							console["log"](a.join(" "));
						} : function(){};
						console[tcn]._fake = true;
					})();
				}else if(has("console-as-object")){
					console[tn] = Function.prototype.bind.call(console[tn], console);
				}
			}
		}
	
		has.add("dojo-debug-messages",
			// include dojo.deprecated/dojo.experimental implementations
			!!config.isDebug
		);
		dojo.deprecated = dojo.experimental =  function(){};
		if(has("dojo-debug-messages")){
			dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
				// summary:
				//		Log a debug message to indicate that a behavior has been
				//		deprecated.
				// behaviour: String
				//		The API or behavior being deprecated. Usually in the form
				//		of "myApp.someFunction()".
				// extra: String?
				//		Text to append to the message. Often provides advice on a
				//		new function or facility to achieve the same goal during
				//		the deprecation period.
				// removal: String?
				//		Text to indicate when in the future the behavior will be
				//		removed. Usually a version number.
				// example:
				//	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");
	
				var message = "DEPRECATED: " + behaviour;
				if(extra){ message += " " + extra; }
				if(removal){ message += " -- will be removed in version: " + removal; }
				console.warn(message);
			};
	
			dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
				// summary:
				//		Marks code as experimental.
				// description:
				//		This can be used to mark a function, file, or module as
				//		experimental.	 Experimental code is not ready to be used, and the
				//		APIs are subject to change without notice.	Experimental code may be
				//		completed deleted without going through the normal deprecation
				//		process.
				// moduleName: String
				//		The name of a module, or the name of a module file or a specific
				//		function
				// extra: String?
				//		some additional message for the user
				// example:
				//	| dojo.experimental("dojo.data.Result");
				// example:
				//	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");
	
				var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
				if(extra){ message += " " + extra; }
				console.warn(message);
			};
		}
	
		has.add("dojo-modulePaths",
			// consume dojo.modulePaths processing
			1
		);
		if(has("dojo-modulePaths")){
			// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
			// this is the v1.6- behavior.
			if(config.modulePaths){
				dojo.deprecated("dojo.modulePaths", "use paths configuration");
				var paths = {};
				for(p in config.modulePaths){
					paths[p.replace(/\./g, "/")] = config.modulePaths[p];
				}
				require({paths:paths});
			}
		}
	
		has.add("dojo-moduleUrl",
			// include dojo.moduleUrl
			1
		);
		if(has("dojo-moduleUrl")){
			dojo.moduleUrl = function(/*String*/module, /*String?*/url){
				// summary:
				//		Returns a URL relative to a module.
				// example:
				//	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
				//	|	console.dir(pngPath); // list the object properties
				//	|	// create an image and set it's source to pngPath's value:
				//	|	var img = document.createElement("img");
				//	|	img.src = pngPath;
				//	|	// add our image to the document
				//	|	dojo.body().appendChild(img);
				// example:
				//		you may de-reference as far as you like down the package
				//		hierarchy.  This is sometimes handy to avoid lengthy relative
				//		urls or for building portable sub-packages. In this example,
				//		the `acme.widget` and `acme.util` directories may be located
				//		under different roots (see `dojo.registerModulePath`) but the
				//		the modules which reference them can be unaware of their
				//		relative locations on the filesystem:
				//	|	// somewhere in a configuration block
				//	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
				//	|	dojo.registerModulePath("acme.util", "../../util");
				//	|
				//	|	// ...
				//	|
				//	|	// code in a module using acme resources
				//	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
				//	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");
	
				dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");
	
				// require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
				// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
				// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
				// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
				var result = null;
				if(module){
					result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
				}
				return result;
			};
		}
	
		dojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling
	
		return dojo;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(require){var module = { config: function(){ return {"config-deferredInstrumentation":0,"config-dojo-loader-catches":0,"config-tlmSiblingOfDojo":0,"dojo-amd-factory-scan":0,"dojo-combo-api":0,"dojo-config-api":1,"dojo-config-require":0,"dojo-debug-messages":0,"dojo-dom-ready-api":1,"dojo-firebug":0,"dojo-guarantee-console":1,"dojo-has-api":1,"dojo-inject-api":1,"dojo-loader":1,"dojo-log-api":0,"dojo-modulePaths":0,"dojo-moduleUrl":0,"dojo-publish-privates":0,"dojo-requirejs-api":0,"dojo-sniff":1,"dojo-sync-loader":0,"dojo-test-sniff":0,"dojo-timeout-api":0,"dojo-trace-api":0,"dojo-undef-api":0,"dojo-v1x-i18n-Api":1,"dom":1,"host-browser":1,"extend-dojo":1,"touch":0}; } };
		// module:
		//		dojo/has
		// summary:
		//		Defines the has.js API and several feature tests used by dojo.
		// description:
		//		This module defines the has API as described by the project has.js with the following additional features:
		//
		//		- the has test cache is exposed at has.cache.
		//		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
		//		- the loader's has cache may be optionally copied into this module's has cahce.
		//
		//		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!
	
		// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
		// if using a foreign loader, then the has cache may be initialized via the config object for this module
		// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
		var has = require.has || function(){};
		if(!has("dojo-has-api")){
			var
				isBrowser =
					// the most fundamental decision: are we in the browser?
					typeof window != "undefined" &&
					typeof location != "undefined" &&
					typeof document != "undefined" &&
					window.location == location && window.document == document,
	
				// has API variables
				global = (function () { return this; })(),
				doc = isBrowser && document,
				element = doc && doc.createElement("DiV"),
				cache = (module.config && module.config()) || {};
	
			has = function(name){
				// summary:
				//		Return the current value of the named feature.
				//
				// name: String|Integer
				//		The name (if a string) or identifier (if an integer) of the feature to test.
				//
				// description:
				//		Returns the value of the feature named by name. The feature must have been
				//		previously added to the cache by has.add.
	
				return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean
			};
	
			has.cache = cache;
	
			has.add = function(name, test, now, force){
				// summary:
				//	 	Register a new feature test for some named feature.
				// name: String|Integer
				//	 	The name (if a string) or identifier (if an integer) of the feature to test.
				// test: Function
				//		 A test function to register. If a function, queued for testing until actually
				//		 needed. The test function should return a boolean indicating
				//	 	the presence of a feature or bug.
				// now: Boolean?
				//		 Optional. Omit if `test` is not a function. Provides a way to immediately
				//		 run the test and cache the result.
				// force: Boolean?
				//	 	Optional. If the test already exists and force is truthy, then the existing
				//	 	test will be replaced; otherwise, add does not replace an existing test (that
				//	 	is, by default, the first test advice wins).
				// example:
				//		A redundant test, testFn with immediate execution:
				//	|	has.add("javascript", function(){ return true; }, true);
				//
				// example:
				//		Again with the redundantness. You can do this in your tests, but we should
				//		not be doing this in any internal has.js tests
				//	|	has.add("javascript", true);
				//
				// example:
				//		Three things are passed to the testFunction. `global`, `document`, and a generic element
				//		from which to work your test should the need arise.
				//	|	has.add("bug-byid", function(g, d, el){
				//	|		// g	== global, typically window, yadda yadda
				//	|		// d	== document object
				//	|		// el == the generic element. a `has` element.
				//	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
				//	|	});
	
				(typeof cache[name]=="undefined" || force) && (cache[name]= test);
				return now && has(name);
			};
	
			// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
			// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
			// can optimize these away iff desired
			has.add("host-browser", isBrowser);
			has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
			has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
			has.add("dom", isBrowser);
			has.add("dojo-dom-ready-api", 1);
			has.add("dojo-sniff", 1);
		}
	
		if(has("host-browser")){
			// Common application level tests
			has.add("dom-addeventlistener", !!document.addEventListener);
	
			// Do the device and browser have touch capability?
			has.add("touch", "ontouchstart" in document
				|| ("onpointerdown" in document && navigator.maxTouchPoints > 0)
				|| window.navigator.msMaxTouchPoints);
	
			// Touch events support
			has.add("touch-events", "ontouchstart" in document);
	
			// Test if pointer events are supported and enabled, with either standard names ("pointerdown" etc.) or
			// IE specific names ("MSPointerDown" etc.).  Tests are designed to work on embedded C# WebBrowser Controls
			// in addition to IE, Edge, and future versions of Firefox and Chrome.
			// Note that on IE11, has("pointer-events") and has("MSPointer") are both true.
			has.add("pointer-events", "pointerEnabled" in window.navigator ?
					window.navigator.pointerEnabled : "PointerEvent" in window);
			has.add("MSPointer", window.navigator.msPointerEnabled);
	
			// I don't know if any of these tests are really correct, just a rough guess
			has.add("device-width", screen.availWidth || innerWidth);
	
			// Tests for DOMNode.attributes[] behavior:
			//	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
			//	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
			//	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
			var form = document.createElement("form");
			has.add("dom-attributes-explicit", form.attributes.length == 0); // W3C
			has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);	// IE8
		}
	
		has.clearElement = function(element){
			// summary:
			//	 Deletes the contents of the element passed to test functions.
			element.innerHTML= "";
			return element;
		};
	
		has.normalize = function(id, toAbsMid){
			// summary:
			//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
			//
			// toAbsMid: Function
			//	 Resolves a relative module id into an absolute module id
			var
				tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
				get = function(skip){
					var term = tokens[i++];
					if(term == ":"){
						// empty string module name, resolves to 0
						return 0;
					}else{
						// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
						if(tokens[i++] == "?"){
							if(!skip && has(term)){
								// matched the feature, get the first value from the options
								return get();
							}else{
								// did not match, get the second value, passing over the first
								get(true);
								return get(skip);
							}
						}
						// a module
						return term || 0;
					}
				};
			id = get();
			return id && toAbsMid(id);
		};
	
		has.load = function(id, parentRequire, loaded){
			// summary:
			//		Conditional loading of AMD modules based on a has feature test value.
			// id: String
			//		Gives the resolved module id to load.
			// parentRequire: Function
			//		The loader require function with respect to the module that contained the plugin resource in it's
			//		dependency list.
			// loaded: Function
			//	 Callback to loader that consumes result of plugin demand.
	
			if(id){
				parentRequire([id], loaded);
			}else{
				loaded();
			}
		};
	
		return has;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 6 */
/***/ function(module, exports) {

	var registered_modules = {};
	function dojoRequire(module, cb){
		if (module instanceof Array){
			var res = module.map(function(m){ return dojoRequire(m); });
			if (cb) cb.apply(this, res);
		}
		else {
			if (registered_modules[module]) {
				return registered_modules[module];
			}
			else {
				console.error('Dynamic dojo require is not supported. Trying to require "' + module + '"');
			}
		}
	}
	dojoRequire.async = true;
	dojoRequire.toUrl = function(url) {
		return url;
	};
	dojoRequire.register = function(module_name, module){
		registered_modules[module_name] = module;
		return module;
	};
	dojoRequire.unregister = function(module_name){
		delete registered_modules[module_name];
	};
	module.exports = dojoRequire;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, require){
		// module:
		//		dojo/_base/config
	
	/*=====
	return {
		// summary:
		//		This module defines the user configuration during bootstrap.
		// description:
		//		By defining user configuration as a module value, an entire configuration can be specified in a build,
		//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
		//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
		//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
		//		as a module allows for specifying unique, per-instance configurations.
		// example:
		//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
		//		dojo.js are already loaded).
		//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
		//		|	require({
		//		|		packages:[{
		//		|			name:"myDojo",
		//		|			location:".", //assume baseUrl points to dojo.js
		//		|		}]
		//		|	});
		//		|
		//		|	// specify a configuration for the myDojo instance
		//		|	define("myDojo/config", {
		//		|		// normal configuration variables go here, e.g.,
		//		|		locale:"fr-ca"
		//		|	});
		//		|
		//		|	// load and use the new instance of dojo
		//		|	require(["myDojo"], function(dojo){
		//		|		// dojo is the new instance of dojo
		//		|		// use as required
		//		|	});
	
		// isDebug: Boolean
		//		Defaults to `false`. If set to `true`, ensures that Dojo provides
		//		extended debugging feedback to the console.
		isDebug: false,
	
		// locale: String
		//		The locale to assume for loading localized resources in this page,
		//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
		//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
		//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
		//		for details on loading localized resources. If no locale is specified,
		//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
		//		or `navigator.language` properties.
		locale: undefined,
	
		// extraLocale: Array
		//		No default value. Specifies additional locales whose
		//		resources should also be loaded alongside the default locale when
		//		calls to `dojo.requireLocalization()` are processed.
		extraLocale: undefined,
	
		// baseUrl: String
		//		The directory in which `dojo.js` is located. Under normal
		//		conditions, Dojo auto-detects the correct location from which it
		//		was loaded. You may need to manually configure `baseUrl` in cases
		//		where you have renamed `dojo.js` or in which `<base>` tags confuse
		//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
		//		either the value of `djConfig.baseUrl` if one is provided or the
		//		auto-detected root if not. Other modules are located relative to
		//		this path. The path should end in a slash.
		baseUrl: undefined,
	
		// modulePaths: [deprecated] Object
		//		A map of module names to paths relative to `dojo.baseUrl`. The
		//		key/value pairs correspond directly to the arguments which
		//		`dojo.registerModulePath` accepts. Specifying
		//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
		//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
		//		modules may be configured via `djConfig.modulePaths`.
		modulePaths: {},
	
		// addOnLoad: Function|Array
		//		Adds a callback via dojo/ready. Useful when Dojo is added after
		//		the page loads and djConfig.afterOnLoad is true. Supports the same
		//		arguments as dojo/ready. When using a function reference, use
		//		`djConfig.addOnLoad = function(){};`. For object with function name use
		//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
		//		function reference use
		//		`djConfig.addOnLoad = [myObject, function(){}];`
		addOnLoad: null,
	
		// parseOnLoad: Boolean
		//		Run the parser after the page is loaded
		parseOnLoad: false,
	
		// require: String[]
		//		An array of module names to be loaded immediately after dojo.js has been included
		//		in a page.
		require: [],
	
		// defaultDuration: Number
		//		Default duration, in milliseconds, for wipe and fade animations within dijits.
		//		Assigned to dijit.defaultDuration.
		defaultDuration: 200,
	
		// dojoBlankHtmlUrl: String
		//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
		//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
		//		controls do not bleed through the popups. Normally this configuration variable
		//		does not need to be set, except when using cross-domain/CDN Dojo builds.
		//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
		//		to the path on your domain your copy of blank.html.
		dojoBlankHtmlUrl: undefined,
	
		// ioPublish: Boolean?
		//		Set this to true to enable publishing of topics for the different phases of
		//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
		//		of topics that are published.
		ioPublish: false,
	
		// transparentColor: Array
		//		Array containing the r, g, b components used as transparent color in dojo.Color;
		//		if undefined, [255,255,255] (white) will be used.
		transparentColor: undefined,
		
		// deps: Function|Array
		//		Defines dependencies to be used before the loader has been loaded.
		//		When provided, they cause the loader to execute require(deps, callback) 
		//		once it has finished loading. Should be used with callback.
		deps: undefined,
		
		// callback: Function|Array
		//		Defines a callback to be used when dependencies are defined before 
		//		the loader has been loaded. When provided, they cause the loader to 
		//		execute require(deps, callback) once it has finished loading. 
		//		Should be used with deps.
		callback: undefined,
		
		// deferredInstrumentation: Boolean
		//		Whether deferred instrumentation should be loaded or included
		//		in builds.
		deferredInstrumentation: true,
	
		// useDeferredInstrumentation: Boolean|String
		//		Whether the deferred instrumentation should be used.
		//
		//		* `"report-rejections"`: report each rejection as it occurs.
		//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
		//			in an attempt to detect unhandled rejections.
		useDeferredInstrumentation: "report-unhandled-rejections"
	};
	=====*/
	
		var result = {};
		if(has("dojo-config-api")){
			// must be the dojo loader; take a shallow copy of require.rawConfig
			var src = require.rawConfig, p;
			for(p in src){
				result[p] = src[p];
			}
		}else{
			var adviseHas = function(featureSet, prefix, booting){
				for(p in featureSet){
					p!="has" && has.add(prefix + p, featureSet[p], 0, booting);
				}
			};
			var global = (function () { return this; })();
			result = has("dojo-loader") ?
				// must be a built version of the dojo loader; all config stuffed in require.rawConfig
				require.rawConfig :
				// a foreign loader
				global.dojoConfig || global.djConfig || {};
			adviseHas(result, "config", 1);
			adviseHas(result.has, "", 1);
		}
	
		if(!result.locale && typeof navigator != "undefined"){
			// Default locale for browsers (ensure it's read from user-settings not download locale).
			var language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :
				(navigator.language || navigator.userLanguage);
			if(language){
				result.locale = language.toLowerCase();
			}
		}
	
		return result;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has){
		// module:
		//		dojo/_base/lang
	
		has.add("bug-for-in-skips-shadowed", function(){
			// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
			for(var i in {toString: 1}){
				return 0;
			}
			return 1;
		});
	
		// Helper methods
		var _extraNames =
				has("bug-for-in-skips-shadowed") ?
					"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [],
	
			_extraLen = _extraNames.length,
	
			getProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){
				if(!context){
					if(parts[0] && dojo.scopeMap[parts[0]]) {
						// Voodoo code from the old days where "dojo" or "dijit" maps to some special object
						// rather than just window.dojo
						context = dojo.scopeMap[parts.shift()][1];
					}else{
						context = dojo.global;
					}
				}
	
				try{
					for(var i = 0; i < parts.length; i++){
						var p = parts[i];
						if(!(p in context)){
							if(create){
								context[p] = {};
							}else{
								return;		// return undefined
							}
						}
						context = context[p];
					}
					return context; // mixed
				}catch(e){
					// "p in context" throws an exception when context is a number, boolean, etc. rather than an object,
					// so in that corner case just return undefined (by having no return statement)
				}
			},
	
			opts = Object.prototype.toString,
	
			efficient = function(obj, offset, startWith){
				return (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));
			},
	
			_pattern = /\{([^\}]+)\}/g;
	
		// Module export
		var lang = {
			// summary:
			//		This module defines Javascript language extensions.
	
			// _extraNames: String[]
			//		Lists property names that must be explicitly processed during for-in iteration
			//		in environments that have has("bug-for-in-skips-shadowed") true.
			_extraNames:_extraNames,
	
			_mixin: function(dest, source, copyFunc){
				// summary:
				//		Copies/adds all properties of source to dest; returns dest.
				// dest: Object
				//		The object to which to copy/add all properties contained in source.
				// source: Object
				//		The object from which to draw all properties to copy into dest.
				// copyFunc: Function?
				//		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
				// returns:
				//		dest, as modified
				// description:
				//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
				//		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
				//		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
				//		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
				var name, s, i, empty = {};
				for(name in source){
					// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
					// inherited from Object.prototype.	 For example, if dest has a custom toString() method,
					// don't overwrite it with the toString() method that source inherited from Object.prototype
					s = source[name];
					if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
						dest[name] = copyFunc ? copyFunc(s) : s;
					}
				}
	
				if(has("bug-for-in-skips-shadowed")){
					if(source){
						for(i = 0; i < _extraLen; ++i){
							name = _extraNames[i];
							s = source[name];
							if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){
								dest[name] = copyFunc ? copyFunc(s) : s;
							}
						}
					}
				}
	
				return dest; // Object
			},
	
			mixin: function(dest, sources){
				// summary:
				//		Copies/adds all properties of one or more sources to dest; returns dest.
				// dest: Object
				//		The object to which to copy/add all properties contained in source. If dest is falsy, then
				//		a new object is manufactured before copying/adding properties begins.
				// sources: Object...
				//		One of more objects from which to draw all properties to copy into dest. sources are processed
				//		left-to-right and if more than one of these objects contain the same property name, the right-most
				//		value "wins".
				// returns: Object
				//		dest, as modified
				// description:
				//		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
				//		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
				//		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
				//		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
				// example:
				//		make a shallow copy of an object
				//	|	var copy = lang.mixin({}, source);
				// example:
				//		many class constructors often take an object which specifies
				//		values to be configured on the object. In this case, it is
				//		often simplest to call `lang.mixin` on the `this` object:
				//	|	declare("acme.Base", null, {
				//	|		constructor: function(properties){
				//	|			// property configuration:
				//	|			lang.mixin(this, properties);
				//	|
				//	|			console.log(this.quip);
				//	|			//	...
				//	|		},
				//	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
				//	|		// ...
				//	|	});
				//	|
				//	|	// create an instance of the class and configure it
				//	|	var b = new acme.Base({quip: "That's what it does!" });
				// example:
				//		copy in properties from multiple objects
				//	|	var flattened = lang.mixin(
				//	|		{
				//	|			name: "Frylock",
				//	|			braces: true
				//	|		},
				//	|		{
				//	|			name: "Carl Brutanananadilewski"
				//	|		}
				//	|	);
				//	|
				//	|	// will print "Carl Brutanananadilewski"
				//	|	console.log(flattened.name);
				//	|	// will print "true"
				//	|	console.log(flattened.braces);
	
				if(!dest){ dest = {}; }
				for(var i = 1, l = arguments.length; i < l; i++){
					lang._mixin(dest, arguments[i]);
				}
				return dest; // Object
			},
	
			setObject: function(name, value, context){
				// summary:
				//		Set a property from a dot-separated string, such as "A.B.C"
				// description:
				//		Useful for longer api chains where you have to test each object in
				//		the chain, or when you have an object reference in string format.
				//		Objects are created as needed along `path`. Returns the passed
				//		value if setting is successful or `undefined` if not.
				// name: String
				//		Path to a property, in the form "A.B.C".
				// value: anything
				//		value or object to place at location given by name
				// context: Object?
				//		Optional. Object to use as root of path. Defaults to
				//		`dojo.global`.
				// example:
				//		set the value of `foo.bar.baz`, regardless of whether
				//		intermediate objects already exist:
				//	| lang.setObject("foo.bar.baz", value);
				// example:
				//		without `lang.setObject`, we often see code like this:
				//	| // ensure that intermediate objects are available
				//	| if(!obj["parent"]){ obj.parent = {}; }
				//	| if(!obj.parent["child"]){ obj.parent.child = {}; }
				//	| // now we can safely set the property
				//	| obj.parent.child.prop = "some value";
				//		whereas with `lang.setObject`, we can shorten that to:
				//	| lang.setObject("parent.child.prop", "some value", obj);
	
				var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
				return obj && p ? (obj[p] = value) : undefined; // Object
			},
	
			getObject: function(name, create, context){
				// summary:
				//		Get a property from a dot-separated string, such as "A.B.C"
				// description:
				//		Useful for longer api chains where you have to test each object in
				//		the chain, or when you have an object reference in string format.
				// name: String
				//		Path to an property, in the form "A.B.C".
				// create: Boolean?
				//		Optional. Defaults to `false`. If `true`, Objects will be
				//		created at any point along the 'path' that is undefined.
				// context: Object?
				//		Optional. Object to use as root of path. Defaults to
				//		'dojo.global'. Null may be passed.
				return !name ? context : getProp(name.split("."), create, context); // Object
			},
	
			exists: function(name, obj){
				// summary:
				//		determine if an object supports a given method
				// description:
				//		useful for longer api chains where you have to test each object in
				//		the chain. Useful for object and method detection.
				// name: String
				//		Path to an object, in the form "A.B.C".
				// obj: Object?
				//		Object to use as root of path. Defaults to
				//		'dojo.global'. Null may be passed.
				// example:
				//	| // define an object
				//	| var foo = {
				//	|		bar: { }
				//	| };
				//	|
				//	| // search the global scope
				//	| lang.exists("foo.bar"); // true
				//	| lang.exists("foo.bar.baz"); // false
				//	|
				//	| // search from a particular scope
				//	| lang.exists("bar", foo); // true
				//	| lang.exists("bar.baz", foo); // false
				return lang.getObject(name, false, obj) !== undefined; // Boolean
			},
	
			// Crockford (ish) functions
	
			isString: function(it){
				// summary:
				//		Return true if it is a String
				// it: anything
				//		Item to test.
				return (typeof it == "string" || it instanceof String); // Boolean
			},
	
			isArray: Array.isArray || function(it){
				// summary:
				//		Return true if it is an Array.
				// it: anything
				//		Item to test.
				return opts.call(it) == "[object Array]"; // Boolean
			},
	
			isFunction: function(it){
				// summary:
				//		Return true if it is a Function
				// it: anything
				//		Item to test.
				return opts.call(it) === "[object Function]";
			},
	
			isObject: function(it){
				// summary:
				//		Returns true if it is a JavaScript object (or an Array, a Function
				//		or null)
				// it: anything
				//		Item to test.
				return it !== undefined &&
					(it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it)); // Boolean
			},
	
			isArrayLike: function(it){
				// summary:
				//		similar to isArray() but more permissive
				// it: anything
				//		Item to test.
				// returns:
				//		If it walks like a duck and quacks like a duck, return `true`
				// description:
				//		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
				//		a string or number and has a length property". Arguments objects
				//		and DOM collections will return true when passed to
				//		isArrayLike(), but will return false when passed to
				//		isArray().
				return !!it && // Boolean
					// keep out built-in constructors (Number, String, ...) which have length
					// properties
					!lang.isString(it) && !lang.isFunction(it) &&
					!(it.tagName && it.tagName.toLowerCase() == 'form') &&
					(lang.isArray(it) || isFinite(it.length));
			},
	
			isAlien: function(it){
				// summary:
				//		Returns true if it is a built-in function or some other kind of
				//		oddball that *should* report as a function but doesn't
				return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
			},
	
			extend: function(ctor, props){
				// summary:
				//		Adds all properties and methods of props to constructor's
				//		prototype, making them available to all instances created with
				//		constructor.
				// ctor: Object
				//		Target constructor to extend.
				// props: Object
				//		One or more objects to mix into ctor.prototype
				for(var i=1, l=arguments.length; i<l; i++){
					lang._mixin(ctor.prototype, arguments[i]);
				}
				return ctor; // Object
			},
	
			_hitchArgs: function(scope, method){
				var pre = lang._toArray(arguments, 2);
				var named = lang.isString(method);
				return function(){
					// arrayify arguments
					var args = lang._toArray(arguments);
					// locate our method
					var f = named ? (scope||dojo.global)[method] : method;
					// invoke with collected args
					return f && f.apply(scope || this, pre.concat(args)); // mixed
				}; // Function
			},
	
			hitch: function(scope, method){
				// summary:
				//		Returns a function that will only ever execute in the given scope.
				//		This allows for easy use of object member functions
				//		in callbacks and other places in which the "this" keyword may
				//		otherwise not reference the expected scope.
				//		Any number of default positional arguments may be passed as parameters
				//		beyond "method".
				//		Each of these values will be used to "placehold" (similar to curry)
				//		for the hitched function.
				// scope: Object
				//		The scope to use when method executes. If method is a string,
				//		scope is also the object containing method.
				// method: Function|String...
				//		A function to be hitched to scope, or the name of the method in
				//		scope to be hitched.
				// example:
				//	|	lang.hitch(foo, "bar")();
				//		runs foo.bar() in the scope of foo
				// example:
				//	|	lang.hitch(foo, myFunction);
				//		returns a function that runs myFunction in the scope of foo
				// example:
				//		Expansion on the default positional arguments passed along from
				//		hitch. Passed args are mixed first, additional args after.
				//	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
				//	|	var fn = lang.hitch(foo, "bar", 1, 2);
				//	|	fn(3); // logs "1, 2, 3"
				// example:
				//	|	var foo = { bar: 2 };
				//	|	lang.hitch(foo, function(){ this.bar = 10; })();
				//		execute an anonymous function in scope of foo
				if(arguments.length > 2){
					return lang._hitchArgs.apply(dojo, arguments); // Function
				}
				if(!method){
					method = scope;
					scope = null;
				}
				if(lang.isString(method)){
					scope = scope || dojo.global;
					if(!scope[method]){ throw(['lang.hitch: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
					return function(){ return scope[method].apply(scope, arguments || []); }; // Function
				}
				return !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function
			},
	
			delegate: (function(){
				// boodman/crockford delegation w/ cornford optimization
				function TMP(){}
				return function(obj, props){
					TMP.prototype = obj;
					var tmp = new TMP();
					TMP.prototype = null;
					if(props){
						lang._mixin(tmp, props);
					}
					return tmp; // Object
				};
			})(),
			/*=====
			delegate: function(obj, props){
				// summary:
				//		Returns a new object which "looks" to obj for properties which it
				//		does not have a value for. Optionally takes a bag of properties to
				//		seed the returned object with initially.
				// description:
				//		This is a small implementation of the Boodman/Crockford delegation
				//		pattern in JavaScript. An intermediate object constructor mediates
				//		the prototype chain for the returned object, using it to delegate
				//		down to obj for property lookup when object-local lookup fails.
				//		This can be thought of similarly to ES4's "wrap", save that it does
				//		not act on types but rather on pure objects.
				// obj: Object
				//		The object to delegate to for properties not found directly on the
				//		return object or in props.
				// props: Object...
				//		an object containing properties to assign to the returned object
				// returns:
				//		an Object of anonymous type
				// example:
				//	|	var foo = { bar: "baz" };
				//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
				//	|	thinger.bar == "baz"; // delegated to foo
				//	|	foo.thud == undefined; // by definition
				//	|	thinger.thud == "xyzzy"; // mixed in from props
				//	|	foo.bar = "thonk";
				//	|	thinger.bar == "thonk"; // still delegated to foo's bar
			},
			=====*/
	
			_toArray: has("ie") ?
				(function(){
					function slow(obj, offset, startWith){
						var arr = startWith||[];
						for(var x = offset || 0; x < obj.length; x++){
							arr.push(obj[x]);
						}
						return arr;
					}
					return function(obj){
						return ((obj.item) ? slow : efficient).apply(this, arguments);
					};
				})() : efficient,
			/*=====
			 _toArray: function(obj, offset, startWith){
				 // summary:
				 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
				 //		array. Returns a new Array with the elements of obj.
				 // obj: Object
				 //		the object to "arrayify". We expect the object to have, at a
				 //		minimum, a length property which corresponds to integer-indexed
				 //		properties.
				 // offset: Number?
				 //		the location in obj to start iterating from. Defaults to 0.
				 //		Optional.
				 // startWith: Array?
				 //		An array to pack with the properties of obj. If provided,
				 //		properties in obj are appended at the end of startWith and
				 //		startWith is the returned array.
			 },
			 =====*/
	
			partial: function(/*Function|String*/ method /*, ...*/){
				// summary:
				//		similar to hitch() except that the scope object is left to be
				//		whatever the execution context eventually becomes.
				// description:
				//		Calling lang.partial is the functional equivalent of calling:
				//		|	lang.hitch(null, funcName, ...);
				// method:
				//		The function to "wrap"
				var arr = [ null ];
				return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function
			},
	
			clone: function(/*anything*/ src){
				// summary:
				//		Clones objects (including DOM nodes) and all children.
				//		Warning: do not clone cyclic structures.
				// src:
				//		The object to clone
				if(!src || typeof src != "object" || lang.isFunction(src)){
					// null, undefined, any non-object, or function
					return src;	// anything
				}
				if(src.nodeType && "cloneNode" in src){
					// DOM Node
					return src.cloneNode(true); // Node
				}
				if(src instanceof Date){
					// Date
					return new Date(src.getTime());	// Date
				}
				if(src instanceof RegExp){
					// RegExp
					return new RegExp(src);   // RegExp
				}
				var r, i, l;
				if(lang.isArray(src)){
					// array
					r = [];
					for(i = 0, l = src.length; i < l; ++i){
						if(i in src){
							r[i] = lang.clone(src[i]);
						}
					}
					// we don't clone functions for performance reasons
					//		}else if(d.isFunction(src)){
					//			// function
					//			r = function(){ return src.apply(this, arguments); };
				}else{
					// generic objects
					r = src.constructor ? new src.constructor() : {};
				}
				return lang._mixin(r, src, lang.clone);
			},
	
	
			trim: String.prototype.trim ?
				function(str){ return str.trim(); } :
				function(str){ return str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
			/*=====
			 trim: function(str){
				 // summary:
				 //		Trims whitespace from both sides of the string
				 // str: String
				 //		String to be trimmed
				 // returns: String
				 //		Returns the trimmed string
				 // description:
				 //		This version of trim() was selected for inclusion into the base due
				 //		to its compact size and relatively good performance
				 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
				 //		Uses String.prototype.trim instead, if available.
				 //		The fastest but longest version of this function is located at
				 //		lang.string.trim()
			 },
			 =====*/
	
			replace: function(tmpl, map, pattern){
				// summary:
				//		Performs parameterized substitutions on a string. Throws an
				//		exception if any parameter is unmatched.
				// tmpl: String
				//		String to be used as a template.
				// map: Object|Function
				//		If an object, it is used as a dictionary to look up substitutions.
				//		If a function, it is called for every substitution with following parameters:
				//		a whole match, a name, an offset, and the whole template
				//		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
				//		for more details).
				// pattern: RegEx?
				//		Optional regular expression objects that overrides the default pattern.
				//		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
				//		which matches patterns like that: "{xxx}", where "xxx" is any sequence
				//		of characters, which doesn't include "}".
				// returns: String
				//		Returns the substituted string.
				// example:
				//	|	// uses a dictionary for substitutions:
				//	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
				//	|		{
				//	|			nick: "Bob",
				//	|			name: {
				//	|				first:	"Robert",
				//	|				middle: "X",
				//	|				last:		"Cringely"
				//	|			}
				//	|		});
				//	|	// returns: Hello, Robert Cringely AKA Bob!
				// example:
				//	|	// uses an array for substitutions:
				//	|	lang.replace("Hello, {0} {2}!",
				//	|		["Robert", "X", "Cringely"]);
				//	|	// returns: Hello, Robert Cringely!
				// example:
				//	|	// uses a function for substitutions:
				//	|	function sum(a){
				//	|		var t = 0;
				//	|		arrayforEach(a, function(x){ t += x; });
				//	|		return t;
				//	|	}
				//	|	lang.replace(
				//	|		"{count} payments averaging {avg} USD per payment.",
				//	|		lang.hitch(
				//	|			{ payments: [11, 16, 12] },
				//	|			function(_, key){
				//	|				switch(key){
				//	|					case "count": return this.payments.length;
				//	|					case "min":		return Math.min.apply(Math, this.payments);
				//	|					case "max":		return Math.max.apply(Math, this.payments);
				//	|					case "sum":		return sum(this.payments);
				//	|					case "avg":		return sum(this.payments) / this.payments.length;
				//	|				}
				//	|			}
				//	|		)
				//	|	);
				//	|	// prints: 3 payments averaging 13 USD per payment.
				// example:
				//	|	// uses an alternative PHP-like pattern for substitutions:
				//	|	lang.replace("Hello, ${0} ${2}!",
				//	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
				//	|	// returns: Hello, Robert Cringely!
	
				return tmpl.replace(pattern || _pattern, lang.isFunction(map) ?
					map : function(_, k){ return lang.getObject(k, false, map); });
			}
		};
	
		has("extend-dojo") && lang.mixin(dojo, lang);
	
		return lang;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has){
		// module:
		//		dojo/sniff
	
		/*=====
		return function(){
			// summary:
			//		This module sets has() flags based on the current browser.
			//		It returns the has() function.
		};
		=====*/
	
		if(has("host-browser")){
			var n = navigator,
				dua = n.userAgent,
				dav = n.appVersion,
				tv = parseFloat(dav);
			has.add("air", dua.indexOf("AdobeAIR") >= 0);
			has.add("wp", parseFloat(dua.split("Windows Phone")[1]) || undefined);
			has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
			has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
			has.add("edge", parseFloat(dua.split("Edge/")[1]) || undefined);
			has.add("opr", parseFloat(dua.split("OPR/")[1]) || undefined);
			// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/
			has.add("webkit", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
				&& !has("edge") && parseFloat(dua.split("WebKit/")[1]) || undefined);
			has.add("chrome", !has("edge") && !has("opr")
					&& parseFloat(dua.split("Chrome/")[1]) || undefined);
			has.add("android", !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
					&& parseFloat(dua.split("Android ")[1]) || undefined);
			has.add("safari", dav.indexOf("Safari") >= 0
					&& !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540
					&& !has("chrome") && !has("android") && !has("edge") && !has("opr") ?
				parseFloat(dav.split("Version/")[1]) : undefined);
			has.add("mac", dav.indexOf("Macintosh") >= 0);
			has.add("quirks", document.compatMode == "BackCompat");
			if(!has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528
					&& dua.match(/(iPhone|iPod|iPad)/)){
				var p = RegExp.$1.replace(/P/, "p");
				var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
				var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
				has.add(p, os);		// "iphone", "ipad" or "ipod"
				has.add("ios", os);
			}
			has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
			has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);
	
			has.add("svg", typeof SVGAngle !== "undefined");
	
			if(!has("webkit")){
				// Opera
				if(dua.indexOf("Opera") >= 0){
					// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
					// 9.8 has both styles; <9.8, 9.9 only old style
					has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
				}
	
				// Mozilla and firefox
				if(dua.indexOf("Gecko") >= 0 && !has("wp") // NOTE: necessary since Windows Phone 8.1 Update 1
						&& !has("khtml") && !has("trident") && !has("edge")){
					has.add("mozilla", tv);
				}
				if(has("mozilla")){
					//We really need to get away from this. Consider a sane isGecko approach for the future.
					has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
				}
	
				// IE
				if(document.all && !has("opera")){
					var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;
	
					//In cases where the page has an HTTP header or META tag with
					//X-UA-Compatible, then it is in emulation mode.
					//Make sure isIE reflects the desired version.
					//document.documentMode of 5 means quirks mode.
					//Only switch the value if documentMode's major version
					//is different from isIE's major version.
					var mode = document.documentMode;
					if(mode && mode != 5 && Math.floor(isIE) != mode){
						isIE = mode;
					}
	
					has.add("ie", isIE);
				}
	
				// Wii
				has.add("wii", typeof opera != "undefined" && opera.wiiremote);
			}
		}
	
		return has;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 10 */,
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(2), __webpack_require__(9), __webpack_require__(12), __webpack_require__(13), __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = function(exports, dojo, has, win, dom, attr){
		// module:
		//		dojo/dom-construct
		// summary:
		//		This module defines the core dojo DOM construction API.
	
		// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42
	
		// support stuff for toDom()
		var tagWrap = {
				option: ["select"],
				tbody: ["table"],
				thead: ["table"],
				tfoot: ["table"],
				tr: ["table", "tbody"],
				td: ["table", "tbody", "tr"],
				th: ["table", "thead", "tr"],
				legend: ["fieldset"],
				caption: ["table"],
				colgroup: ["table"],
				col: ["table", "colgroup"],
				li: ["ul"]
			},
			reTag = /<\s*([\w\:]+)/,
			masterNode = {}, masterNum = 0,
			masterName = "__" + dojo._scopeName + "ToDomId";
	
		// generate start/end tag strings to use
		// for the injection for each special tag wrap case.
		for(var param in tagWrap){
			if(tagWrap.hasOwnProperty(param)){
				var tw = tagWrap[param];
				tw.pre = param == "option" ? '<select multiple="multiple">' : "<" + tw.join("><") + ">";
				tw.post = "</" + tw.reverse().join("></") + ">";
				// the last line is destructive: it reverses the array,
				// but we don't care at this point
			}
		}
	
		var html5domfix;
		if(has("ie") <= 8){
			html5domfix = function(doc){
				doc.__dojo_html5_tested = "yes";
				var div = create('div', {innerHTML: "<nav>a</nav>", style: {visibility: "hidden"}}, doc.body);
				if(div.childNodes.length !== 1){
					('abbr article aside audio canvas details figcaption figure footer header ' +
					'hgroup mark meter nav output progress section summary time video').replace(
						/\b\w+\b/g, function(n){
							doc.createElement(n);
						}
					);
				}
				destroy(div);
			}
		}
	
		function _insertBefore(/*DomNode*/ node, /*DomNode*/ ref){
			var parent = ref.parentNode;
			if(parent){
				parent.insertBefore(node, ref);
			}
		}
	
		function _insertAfter(/*DomNode*/ node, /*DomNode*/ ref){
			// summary:
			//		Try to insert node after ref
			var parent = ref.parentNode;
			if(parent){
				if(parent.lastChild == ref){
					parent.appendChild(node);
				}else{
					parent.insertBefore(node, ref.nextSibling);
				}
			}
		}
	
		exports.toDom = function toDom(frag, doc){
			// summary:
			//		instantiates an HTML fragment returning the corresponding DOM.
			// frag: String
			//		the HTML fragment
			// doc: DocumentNode?
			//		optional document to use when creating DOM nodes, defaults to
			//		dojo/_base/window.doc if not specified.
			// returns:
			//		Document fragment, unless it's a single node in which case it returns the node itself
			// example:
			//		Create a table row:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
			//	|	});
	
			doc = doc || win.doc;
			var masterId = doc[masterName];
			if(!masterId){
				doc[masterName] = masterId = ++masterNum + "";
				masterNode[masterId] = doc.createElement("div");
			}
	
			if(has("ie") <= 8){
				if(!doc.__dojo_html5_tested && doc.body){
					html5domfix(doc);
				}
			}
	
			// make sure the frag is a string.
			frag += "";
	
			// find the starting tag, and get node wrapper
			var match = frag.match(reTag),
				tag = match ? match[1].toLowerCase() : "",
				master = masterNode[masterId],
				wrap, i, fc, df;
			if(match && tagWrap[tag]){
				wrap = tagWrap[tag];
				master.innerHTML = wrap.pre + frag + wrap.post;
				for(i = wrap.length; i; --i){
					master = master.firstChild;
				}
			}else{
				master.innerHTML = frag;
			}
	
			// one node shortcut => return the node itself
			if(master.childNodes.length == 1){
				return master.removeChild(master.firstChild); // DOMNode
			}
	
			// return multiple nodes as a document fragment
			df = doc.createDocumentFragment();
			while((fc = master.firstChild)){ // intentional assignment
				df.appendChild(fc);
			}
			return df; // DocumentFragment
		};
	
		exports.place = function place(node, refNode, position){
			// summary:
			//		Attempt to insert node into the DOM, choosing from various positioning options.
			//		Returns the first argument resolved to a DOM node.
			// node: DOMNode|DocumentFragment|String
			//		id or node reference, or HTML fragment starting with "<" to place relative to refNode
			// refNode: DOMNode|String
			//		id or node reference to use as basis for placement
			// position: String|Number?
			//		string noting the position of node relative to refNode or a
			//		number indicating the location in the childNodes collection of refNode.
			//		Accepted string values are:
			//
			//		- before
			//		- after
			//		- replace
			//		- only
			//		- first
			//		- last
			//
			//		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
			//		"only" replaces all children.  position defaults to "last" if not specified
			// returns: DOMNode
			//		Returned values is the first argument resolved to a DOM node.
			//
			//		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
			// example:
			//		Place a node by string id as the last child of another node by string id:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("someNode", "anotherNode");
			//	|	});
			// example:
			//		Place a node by string id before another node by string id
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("someNode", "anotherNode", "before");
			//	|	});
			// example:
			//		Create a Node, and place it in the body element (last child):
			//	|	require(["dojo/dom-construct", "dojo/_base/window"
			//	|	], function(domConstruct, win){
			//	|		domConstruct.place("<div></div>", win.body());
			//	|	});
			// example:
			//		Put a new LI as the first child of a list by id:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.place("<li></li>", "someUl", "first");
			//	|	});
	
			refNode = dom.byId(refNode);
			if(typeof node == "string"){ // inline'd type check
				node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
			}
			if(typeof position == "number"){ // inline'd type check
				var cn = refNode.childNodes;
				if(!cn.length || cn.length <= position){
					refNode.appendChild(node);
				}else{
					_insertBefore(node, cn[position < 0 ? 0 : position]);
				}
			}else{
				switch(position){
					case "before":
						_insertBefore(node, refNode);
						break;
					case "after":
						_insertAfter(node, refNode);
						break;
					case "replace":
						refNode.parentNode.replaceChild(node, refNode);
						break;
					case "only":
						exports.empty(refNode);
						refNode.appendChild(node);
						break;
					case "first":
						if(refNode.firstChild){
							_insertBefore(node, refNode.firstChild);
							break;
						}
						// else fallthrough...
					default: // aka: last
						refNode.appendChild(node);
				}
			}
			return node; // DomNode
		};
	
		var create = exports.create = function create(/*DOMNode|String*/ tag, /*Object*/ attrs, /*DOMNode|String?*/ refNode, /*String?*/ pos){
			// summary:
			//		Create an element, allowing for optional attribute decoration
			//		and placement.
			// description:
			//		A DOM Element creation function. A shorthand method for creating a node or
			//		a fragment, and allowing for a convenient optional attribute setting step,
			//		as well as an optional DOM placement reference.
			//
			//		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
			//		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
			//
			//		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
			//		the action node, passing along the optional reference node and position.
			// tag: DOMNode|String
			//		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
			//		or an existing DOM node to process.
			// attrs: Object
			//		An object-hash of attributes to set on the newly created node.
			//		Can be null, if you don't want to set any attributes/styles.
			//		See: `dojo/dom-attr.set` for a description of available attributes.
			// refNode: DOMNode|String?
			//		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
			//		node somewhere in the dom relative to refNode. Can be a DomNode reference
			//		or String ID of a node.
			// pos: String?
			//		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
			//		though can be set to "first","after","before","last", "replace" or "only"
			//		to further control the placement of the new node relative to the refNode.
			//		'refNode' is required if a 'pos' is specified.
			// example:
			//		Create a DIV:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var n = domConstruct.create("div");
			//	|	});
			//
			// example:
			//		Create a DIV with content:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
			//	|	});
			//
			// example:
			//		Place a new DIV in the BODY, with no attributes set
			//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
			//	|		var n = domConstruct.create("div", null, win.body());
			//	|	});
			//
			// example:
			//		Create an UL, and populate it with LI's. Place the list as the first-child of a
			//		node with id="someId":
			//	|	require(["dojo/dom-construct", "dojo/_base/array"],
			//	|	function(domConstruct, arrayUtil){
			//	|		var ul = domConstruct.create("ul", null, "someId", "first");
			//	|		var items = ["one", "two", "three", "four"];
			//	|		arrayUtil.forEach(items, function(data){
			//	|			domConstruct.create("li", { innerHTML: data }, ul);
			//	|		});
			//	|	});
			//
			// example:
			//		Create an anchor, with an href. Place in BODY:
			//	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
			//	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
			//	|	});
	
			var doc = win.doc;
			if(refNode){
				refNode = dom.byId(refNode);
				doc = refNode.ownerDocument;
			}
			if(typeof tag == "string"){ // inline'd type check
				tag = doc.createElement(tag);
			}
			if(attrs){ attr.set(tag, attrs); }
			if(refNode){ exports.place(tag, refNode, pos); }
			return tag; // DomNode
		};
	
		function _empty(/*DomNode*/ node){
			// TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
			// and then uncomment the emptyGrandchildren() test case from html.html.
			// Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
			// see http://jsperf.com/clear-dom-node.
			if("innerHTML" in node){
				try{
					// fast path
					node.innerHTML = "";
					return;
				}catch(e){
					// innerHTML is readOnly (e.g. TABLE (sub)elements in quirks mode)
					// Fall through (saves bytes)
				}
			}
	
			// SVG/strict elements don't support innerHTML
			for(var c; c = node.lastChild;){ // intentional assignment
				node.removeChild(c);
			}
		}
	
		exports.empty = function empty(/*DOMNode|String*/ node){
			// summary:
			//		safely removes all children of the node.
			// node: DOMNode|String
			//		a reference to a DOM node or an id.
			// example:
			//		Destroy node's children byId:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.empty("someId");
			//	|	});
	
			_empty(dom.byId(node));
		};
	
	
		function _destroy(/*DomNode*/ node, /*DomNode*/ parent){
			// in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
			if(node.firstChild){
				_empty(node);
			}
			if(parent){
				// removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
				// In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
				// the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
				// In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
				has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
			}
		}
		var destroy = exports.destroy = function destroy(/*DOMNode|String*/ node){
			// summary:
			//		Removes a node from its parent, clobbering it and all of its
			//		children.
			//
			// description:
			//		Removes a node from its parent, clobbering it and all of its
			//		children. Function only works with DomNodes, and returns nothing.
			//
			// node: DOMNode|String
			//		A String ID or DomNode reference of the element to be destroyed
			//
			// example:
			//		Destroy a node byId:
			//	|	require(["dojo/dom-construct"], function(domConstruct){
			//	|		domConstruct.destroy("someId");
			//	|	});
	
			node = dom.byId(node);
			if(!node){ return; }
			_destroy(node, node.parentNode);
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, lang, has){
	// module:
	//		dojo/_base/window
	
	var ret = {
		// summary:
		//		API to save/set/restore the global/document scope.
	
		global: dojo.global,
		/*=====
		 global: {
			 // summary:
			 //		Alias for the current window. 'global' can be modified
			 //		for temporary context shifting. See also withGlobal().
			 // description:
			 //		Use this rather than referring to 'window' to ensure your code runs
			 //		correctly in managed contexts.
		 },
		 =====*/
	
		doc: dojo.global["document"] || null,
		/*=====
		doc: {
			// summary:
			//		Alias for the current document. 'doc' can be modified
			//		for temporary context shifting. See also withDoc().
			// description:
			//		Use this rather than referring to 'window.document' to ensure your code runs
			//		correctly in managed contexts.
			// example:
			//	|	n.appendChild(dojo.doc.createElement('div'));
		},
		=====*/
	
		body: function(/*Document?*/ doc){
			// summary:
			//		Return the body element of the specified document or of dojo/_base/window::doc.
			// example:
			//	|	win.body().appendChild(dojo.doc.createElement('div'));
	
			// Note: document.body is not defined for a strict xhtml document
			// Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
			doc = doc || dojo.doc;
			return doc.body || doc.getElementsByTagName("body")[0]; // Node
		},
	
		setContext: function(/*Object*/ globalObject, /*DocumentElement*/ globalDocument){
			// summary:
			//		changes the behavior of many core Dojo functions that deal with
			//		namespace and DOM lookup, changing them to work in a new global
			//		context (e.g., an iframe). The varibles dojo.global and dojo.doc
			//		are modified as a result of calling this function and the result of
			//		`dojo.body()` likewise differs.
			dojo.global = ret.global = globalObject;
			dojo.doc = ret.doc = globalDocument;
		},
	
		withGlobal: function(	/*Object*/ globalObject,
								/*Function*/ callback,
								/*Object?*/ thisObject,
								/*Array?*/ cbArguments){
			// summary:
			//		Invoke callback with globalObject as dojo.global and
			//		globalObject.document as dojo.doc.
			// description:
			//		Invoke callback with globalObject as dojo.global and
			//		globalObject.document as dojo.doc. If provided, globalObject
			//		will be executed in the context of object thisObject
			//		When callback() returns or throws an error, the dojo.global
			//		and dojo.doc will be restored to its previous state.
	
			var oldGlob = dojo.global;
			try{
				dojo.global = ret.global = globalObject;
				return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
			}finally{
				dojo.global = ret.global = oldGlob;
			}
		},
	
		withDoc: function(	/*DocumentElement*/ documentObject,
							/*Function*/ callback,
							/*Object?*/ thisObject,
							/*Array?*/ cbArguments){
			// summary:
			//		Invoke callback with documentObject as dojo/_base/window::doc.
			// description:
			//		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
			//		callback will be executed in the context of object thisObject
			//		When callback() returns or throws an error, the dojo/_base/window::doc will
			//		be restored to its previous state.
	
			var oldDoc = ret.doc,
				oldQ = has("quirks"),
				oldIE = has("ie"), isIE, mode, pwin;
	
			try{
				dojo.doc = ret.doc = documentObject;
				// update dojo.isQuirks and the value of the has feature "quirks".
				// remove setting dojo.isQuirks and dojo.isIE for 2.0
				dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true); // no need to check for QuirksMode which was Opera 7 only
	
				if(has("ie")){
					if((pwin = documentObject.parentWindow) && pwin.navigator){
						// re-run IE detection logic and update dojo.isIE / has("ie")
						// (the only time parentWindow/navigator wouldn't exist is if we were not
						// passed an actual legitimate document object)
						isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
						mode = documentObject.documentMode;
						if(mode && mode != 5 && Math.floor(isIE) != mode){
							isIE = mode;
						}
						dojo.isIE = has.add("ie", isIE, true, true);
					}
				}
	
				if(thisObject && typeof callback == "string"){
					callback = thisObject[callback];
				}
	
				return callback.apply(thisObject, cbArguments || []);
			}finally{
				dojo.doc = ret.doc = oldDoc;
				dojo.isQuirks = has.add("quirks", oldQ, true, true);
				dojo.isIE = has.add("ie", oldIE, true, true);
			}
		}
	};
	
	has("extend-dojo") && lang.mixin(dojo, ret);
	
	return ret;
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(12), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, win, kernel){
		// module:
		//		dojo/dom
	
		// FIXME: need to add unit tests for all the semi-public methods
	
		if(has("ie") <= 7){
			try{
				document.execCommand("BackgroundImageCache", false, true);
			}catch(e){
				// sane browsers don't have cache "issues"
			}
		}
	
		// =============================
		// DOM Functions
		// =============================
	
		// the result object
		var dom = {
			// summary:
			//		This module defines the core dojo DOM API.
		};
	
		if(has("ie")){
			dom.byId = function(id, doc){
				if(typeof id != "string"){
					return id;
				}
				var _d = doc || win.doc, te = id && _d.getElementById(id);
				// attributes.id.value is better than just id in case the
				// user has a name=id inside a form
				if(te && (te.attributes.id.value == id || te.id == id)){
					return te;
				}else{
					var eles = _d.all[id];
					if(!eles || eles.nodeName){
						eles = [eles];
					}
					// if more than 1, choose first with the correct id
					var i = 0;
					while((te = eles[i++])){
						if((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id){
							return te;
						}
					}
				}
			};
		}else{
			dom.byId = function(id, doc){
				// inline'd type check.
				// be sure to return null per documentation, to match IE branch.
				return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null; // DOMNode
			};
		}
		/*=====
		 dom.byId = function(id, doc){
			// summary:
			//		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
			//		if not found.  If `id` is a DomNode, this function is a no-op.
			//
			// id: String|DOMNode
			//		A string to match an HTML id attribute or a reference to a DOM Node
			//
			// doc: Document?
			//		Document to work in. Defaults to the current value of
			//		dojo/_base/window.doc.  Can be used to retrieve
			//		node references from other documents.
			//
			// example:
			//		Look up a node by ID:
			//	|	require(["dojo/dom"], function(dom){
			//	|		var n = dom.byId("foo");
			//	|	});
			//
			// example:
			//		Check if a node exists, and use it.
			//	|	require(["dojo/dom"], function(dom){
			//	|		var n = dom.byId("bar");
			//	|		if(n){ doStuff() ... }
			//	|	});
			//
			// example:
			//		Allow string or DomNode references to be passed to a custom function:
			//	|	require(["dojo/dom"], function(dom){
			//	|		var foo = function(nodeOrId){
			//	|			nodeOrId = dom.byId(nodeOrId);
			//	|			// ... more stuff
			//	|		}
			//	|	});
		 };
		 =====*/
	
		// Test for DOMNode.contains() method, available everywhere except FF8-
		// and IE8-, where it's available in general, but not on document itself,
		// and also problems when either ancestor or node are text nodes.
	
		var doc = kernel.global["document"] || null;
		has.add("dom-contains", !!(doc && doc.contains));
		dom.isDescendant = has("dom-contains") ?
			// FF9+, IE9+, webkit, opera, iOS, Android, Edge, etc.
			function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
				return !!( (ancestor = dom.byId(ancestor)) && ancestor.contains(dom.byId(node)) );
			} :
			function(/*DOMNode|String*/ node, /*DOMNode|String*/ ancestor){
				// summary:
				//		Returns true if node is a descendant of ancestor
				// node: DOMNode|String
				//		string id or node reference to test
				// ancestor: DOMNode|String
				//		string id or node reference of potential parent to test against
				//
				// example:
				//		Test is node id="bar" is a descendant of node id="foo"
				//	|	require(["dojo/dom"], function(dom){
				//	|		if(dom.isDescendant("bar", "foo")){ ... }
				//	|	});
	
				try{
					node = dom.byId(node);
					ancestor = dom.byId(ancestor);
					while(node){
						if(node == ancestor){
							return true; // Boolean
						}
						node = node.parentNode;
					}
				}catch(e){ /* squelch, return false */ }
				return false; // Boolean
			};
	
		// TODO: do we need setSelectable in the base?
	
		// Add feature test for user-select CSS property
		// (currently known to work in all but IE < 10 and Opera)
		// TODO: The user-select CSS property as of May 2014 is no longer part of
		// any CSS specification. In IE, -ms-user-select does not do the same thing
		// as the unselectable attribute on elements; namely, dijit Editor buttons
		// do not properly prevent the content of the editable content frame from
		// unblurring. As a result, the -ms- prefixed version is omitted here.
		has.add("css-user-select", function(global, doc, element){
			// Avoid exception when dom.js is loaded in non-browser environments
			if(!element){ return false; }
	
			var style = element.style;
			var prefixes = ["Khtml", "O", "Moz", "Webkit"],
				i = prefixes.length,
				name = "userSelect",
				prefix;
	
			// Iterate prefixes from most to least likely
			do{
				if(typeof style[name] !== "undefined"){
					// Supported; return property name
					return name;
				}
			}while(i-- && (name = prefixes[i] + "UserSelect"));
	
			// Not supported if we didn't return before now
			return false;
		});
	
		/*=====
		dom.setSelectable = function(node, selectable){
			// summary:
			//		Enable or disable selection on a node
			// node: DOMNode|String
			//		id or reference to node
			// selectable: Boolean
			//		state to put the node in. false indicates unselectable, true
			//		allows selection.
			// example:
			//		Make the node id="bar" unselectable
			//	|	require(["dojo/dom"], function(dom){
			//	|		dom.setSelectable("bar");
			//	|	});
			// example:
			//		Make the node id="bar" selectable
			//	|	require(["dojo/dom"], function(dom){
			//	|		dom.setSelectable("bar", true);
			//	|	});
		};
		=====*/
	
		var cssUserSelect = has("css-user-select");
		dom.setSelectable = cssUserSelect ? function(node, selectable){
			// css-user-select returns a (possibly vendor-prefixed) CSS property name
			dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
		} : function(node, selectable){
			node = dom.byId(node);
	
			// (IE < 10 / Opera) Fall back to setting/removing the
			// unselectable attribute on the element and all its children
			var nodes = node.getElementsByTagName("*"),
				i = nodes.length;
	
			if(selectable){
				node.removeAttribute("unselectable");
				while(i--){
					nodes[i].removeAttribute("unselectable");
				}
			}else{
				node.setAttribute("unselectable", "on");
				while(i--){
					nodes[i].setAttribute("unselectable", "on");
				}
			}
		};
	
		return dom;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(9), __webpack_require__(8), __webpack_require__(13), __webpack_require__(15), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function(exports, has, lang, dom, style, prop){
		// module:
		//		dojo/dom-attr
		// summary:
		//		This module defines the core dojo DOM attributes API.
	
		// TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42
	
		// =============================
		// Element attribute Functions
		// =============================
	
		// This module will be obsolete soon. Use dojo/prop instead.
	
		// dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/
	
		// attribute-related functions (to be obsolete soon)
		var forcePropNames = {
				innerHTML:	1,
				textContent:1,
				className:	1,
				htmlFor:	has("ie"),
				value:		1
			},
			attrNames = {
				// original attribute names
				classname: "class",
				htmlfor: "for",
				// for IE
				tabindex: "tabIndex",
				readonly: "readOnly"
			};
	
		function _hasAttr(node, name){
			var attr = node.getAttributeNode && node.getAttributeNode(name);
			return !!attr && attr.specified; // Boolean
		}
		
		// There is a difference in the presence of certain properties and their default values
		// between browsers. For example, on IE "disabled" is present on all elements,
		// but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
		// can return -1.
	
		exports.has = function hasAttr(/*DOMNode|String*/ node, /*String*/ name){
			// summary:
			//		Returns true if the requested attribute is specified on the
			//		given element, and false otherwise.
			// node: DOMNode|String
			//		id or reference to the element to check
			// name: String
			//		the name of the attribute
			// returns: Boolean
			//		true if the requested attribute is specified on the
			//		given element, and false otherwise
	
			var lc = name.toLowerCase();
			return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);	// Boolean
		};
	
		exports.get = function getAttr(/*DOMNode|String*/ node, /*String*/ name){
			// summary:
			//		Gets an attribute on an HTML element.
			// description:
			//		Handles normalized getting of attributes on DOM Nodes.
			// node: DOMNode|String
			//		id or reference to the element to get the attribute on
			// name: String
			//		the name of the attribute to get.
			// returns:
			//		the value of the requested attribute or null if that attribute does not have a specified or
			//		default value;
			//
			// example:
			//	|	// get the current value of the "foo" attribute on a node
			//	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
			//	|		domAttr.get(dom.byId("nodeId"), "foo");
			//	|		// or we can just pass the id:
			//	|		domAttr.get("nodeId", "foo");
			//	|	});	
			//	|	
	
			node = dom.byId(node);
			var lc = name.toLowerCase(),
				propName = prop.names[lc] || name,
				forceProp = forcePropNames[propName],
				value = node[propName];		// should we access this attribute via a property or via getAttribute()?
	
			if(forceProp && typeof value != "undefined"){
				// node's property
				return value;	// Anything
			}
			
			if(propName == "textContent"){
				return prop.get(node, propName);
			}
			
			if(propName != "href" && (typeof value == "boolean" || lang.isFunction(value))){
				// node's property
				return value;	// Anything
			}
			// node's attribute
			// we need _hasAttr() here to guard against IE returning a default value
			var attrName = attrNames[lc] || name;
			return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
		};
	
		exports.set = function setAttr(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
			// summary:
			//		Sets an attribute on an HTML element.
			// description:
			//		Handles normalized setting of attributes on DOM Nodes.
			//
			//		When passing functions as values, note that they will not be
			//		directly assigned to slots on the node, but rather the default
			//		behavior will be removed and the new behavior will be added
			//		using `dojo.connect()`, meaning that event handler properties
			//		will be normalized and that some caveats with regards to
			//		non-standard behaviors for onsubmit apply. Namely that you
			//		should cancel form submission using `dojo.stopEvent()` on the
			//		passed event object instead of returning a boolean value from
			//		the handler itself.
			// node: DOMNode|String
			//		id or reference to the element to set the attribute on
			// name: String|Object
			//		the name of the attribute to set, or a hash of key-value pairs to set.
			// value: String?
			//		the value to set for the attribute, if the name is a string.
			// returns:
			//		the DOM node
			//
			// example:
			//	|	// use attr() to set the tab index
			//	|	require(["dojo/dom-attr"], function(domAttr){
			//	|		domAttr.set("nodeId", "tabIndex", 3);
			//	|	});
			//
			// example:
			//	Set multiple values at once, including event handlers:
			//	|	require(["dojo/dom-attr"],
			//	|	function(domAttr){
			//	|		domAttr.set("formId", {
			//	|			"foo": "bar",
			//	|			"tabIndex": -1,
			//	|			"method": "POST"
			//	|		}
			//	|	});
	
			node = dom.byId(node);
			if(arguments.length == 2){ // inline'd type check
				// the object form of setter: the 2nd argument is a dictionary
				for(var x in name){
					exports.set(node, x, name[x]);
				}
				return node; // DomNode
			}
			var lc = name.toLowerCase(),
				propName = prop.names[lc] || name,
				forceProp = forcePropNames[propName];
			if(propName == "style" && typeof value != "string"){ // inline'd type check
				// special case: setting a style
				style.set(node, value);
				return node; // DomNode
			}
			if(forceProp || typeof value == "boolean" || lang.isFunction(value)){
				return prop.set(node, name, value);
			}
			// node's attribute
			node.setAttribute(attrNames[lc] || name, value);
			return node; // DomNode
		};
	
		exports.remove = function removeAttr(/*DOMNode|String*/ node, /*String*/ name){
			// summary:
			//		Removes an attribute from an HTML element.
			// node: DOMNode|String
			//		id or reference to the element to remove the attribute from
			// name: String
			//		the name of the attribute to remove
	
			dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
		};
	
		exports.getNodeProp = function getNodeProp(/*DomNode|String*/ node, /*String*/ name){
			// summary:
			//		Returns an effective value of a property or an attribute.
			// node: DOMNode|String
			//		id or reference to the element to remove the attribute from
			// name: String
			//		the name of the attribute
			// returns:
			//		the value of the attribute
	
			node = dom.byId(node);
			var lc = name.toLowerCase(), propName = prop.names[lc] || name;
			if((propName in node) && propName != "href"){
				// node's property
				return node[propName];	// Anything
			}
			// node's attribute
			var attrName = attrNames[lc] || name;
			return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null; // Anything
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, dom){
		// module:
		//		dojo/dom-style
	
		// =============================
		// Style Functions
		// =============================
	
		// getComputedStyle drives most of the style code.
		// Wherever possible, reuse the returned object.
		//
		// API functions below that need to access computed styles accept an
		// optional computedStyle parameter.
		// If this parameter is omitted, the functions will call getComputedStyle themselves.
		// This way, calling code can access computedStyle once, and then pass the reference to
		// multiple API functions.
	
		// Although we normally eschew argument validation at this
		// level, here we test argument 'node' for (duck)type,
		// by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
		// it is frequently sent to this function even
		// though it is not Element.
		var getComputedStyle, style = {
			// summary:
			//		This module defines the core dojo DOM style API.
		};
		if(has("webkit")){
			getComputedStyle = function(/*DomNode*/ node){
				var s;
				if(node.nodeType == 1){
					var dv = node.ownerDocument.defaultView;
					s = dv.getComputedStyle(node, null);
					if(!s && node.style){
						node.style.display = "";
						s = dv.getComputedStyle(node, null);
					}
				}
				return s || {};
			};
		}else if(has("ie") && (has("ie") < 9 || has("quirks"))){
			getComputedStyle = function(node){
				// IE (as of 7) doesn't expose Element like sane browsers
				// currentStyle can be null on IE8!
				return node.nodeType == 1 /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
			};
		}else{
			getComputedStyle = function(node){
				return node.nodeType == 1 /* ELEMENT_NODE*/ ?
					node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
			};
		}
		style.getComputedStyle = getComputedStyle;
		/*=====
		style.getComputedStyle = function(node){
			// summary:
			//		Returns a "computed style" object.
			//
			// description:
			//		Gets a "computed style" object which can be used to gather
			//		information about the current state of the rendered node.
			//
			//		Note that this may behave differently on different browsers.
			//		Values may have different formats and value encodings across
			//		browsers.
			//
			//		Note also that this method is expensive.  Wherever possible,
			//		reuse the returned object.
			//
			//		Use the dojo/dom-style.get() method for more consistent (pixelized)
			//		return values.
			//
			// node: DOMNode
			//		A reference to a DOM node. Does NOT support taking an
			//		ID string for speed reasons.
			// example:
			//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
			//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
			//	|	});
			//
			// example:
			//		Reusing the returned object, avoiding multiple lookups:
			//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
			//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
			//	|		var w = cs.width, h = cs.height;
			//	|	});
			return; // CSS2Properties
		};
		=====*/
	
		var toPixel;
		if(!has("ie")){
			toPixel = function(element, value){
				// style values can be floats, client code may want
				// to round for integer pixels.
				return parseFloat(value) || 0;
			};
		}else{
			toPixel = function(element, avalue){
				if(!avalue){ return 0; }
				// on IE7, medium is usually 4 pixels
				if(avalue == "medium"){ return 4; }
				// style values can be floats, client code may
				// want to round this value for integer pixels.
				if(avalue.slice && avalue.slice(-2) == 'px'){ return parseFloat(avalue); }
				var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle,
					sLeft = s.left, rsLeft = rs.left;
				rs.left = cs.left;
				try{
					// 'avalue' may be incompatible with style.left, which can cause IE to throw
					// this has been observed for border widths using "thin", "medium", "thick" constants
					// those particular constants could be trapped by a lookup
					// but perhaps there are more
					s.left = avalue;
					avalue = s.pixelLeft;
				}catch(e){
					avalue = 0;
				}
				s.left = sLeft;
				rs.left = rsLeft;
				return avalue;
			};
		}
		style.toPixelValue = toPixel;
		/*=====
		style.toPixelValue = function(node, value){
			// summary:
			//		converts style value to pixels on IE or return a numeric value.
			// node: DOMNode
			// value: String
			// returns: Number
		};
		=====*/
	
		// FIXME: there opacity quirks on FF that we haven't ported over. Hrm.
	
		var astr = "DXImageTransform.Microsoft.Alpha";
		var af = function(n, f){
			try{
				return n.filters.item(astr);
			}catch(e){
				return f ? {} : null;
			}
		};
	
		var _getOpacity =
			has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(node){
				try{
					return af(node).Opacity / 100; // Number
				}catch(e){
					return 1; // Number
				}
			} :
			function(node){
				return getComputedStyle(node).opacity;
			};
	
		var _setOpacity =
			has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function(/*DomNode*/ node, /*Number*/ opacity){
				if(opacity === ""){ opacity = 1; }
				var ov = opacity * 100, fullyOpaque = opacity === 1;
	
				// on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
				// but still update the opacity value so we can get a correct reading if it is read later:
				// af(node, 1).Enabled = !fullyOpaque;
	
				if(fullyOpaque){
					node.style.zoom = "";
					if(af(node)){
						node.style.filter = node.style.filter.replace(
							new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
					}
				}else{
					node.style.zoom = 1;
					if(af(node)){
						af(node, 1).Opacity = ov;
					}else{
						node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
					}
					af(node, 1).Enabled = true;
				}
	
				if(node.tagName.toLowerCase() == "tr"){
					for(var td = node.firstChild; td; td = td.nextSibling){
						if(td.tagName.toLowerCase() == "td"){
							_setOpacity(td, opacity);
						}
					}
				}
				return opacity;
			} :
			function(node, opacity){
				return node.style.opacity = opacity;
			};
	
		var _pixelNamesCache = {
			left: true, top: true
		};
		var _pixelRegExp = /margin|padding|width|height|max|min|offset/; // |border
		function _toStyleValue(node, type, value){
			//TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
			type = type.toLowerCase();
	
			// Adjustments for IE and Edge
			if(value == "auto"){
				if(type == "height"){ return node.offsetHeight; }
				if(type == "width"){ return node.offsetWidth; }
			}
			if(type == "fontweight"){
				switch(value){
					case 700: return "bold";
					case 400:
					default: return "normal";
				}
			}
	
			if(!(type in _pixelNamesCache)){
				_pixelNamesCache[type] = _pixelRegExp.test(type);
			}
			return _pixelNamesCache[type] ? toPixel(node, value) : value;
		}
	
		var _floatAliases = {cssFloat: 1, styleFloat: 1, "float": 1};
	
		// public API
	
		style.get = function getStyle(/*DOMNode|String*/ node, /*String?*/ name){
			// summary:
			//		Accesses styles on a node.
			// description:
			//		Getting the style value uses the computed style for the node, so the value
			//		will be a calculated value, not just the immediate node.style value.
			//		Also when getting values, use specific style names,
			//		like "borderBottomWidth" instead of "border" since compound values like
			//		"border" are not necessarily reflected as expected.
			//		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
			//		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
			// node: DOMNode|String
			//		id or reference to node to get style for
			// name: String?
			//		the style property to get
			// example:
			//		Passing only an ID or node returns the computed style object of
			//		the node:
			//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
			//	|		domStyle.get("thinger");
			//	|	});
			// example:
			//		Passing a node and a style property returns the current
			//		normalized, computed value for that property:
			//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
			//	|		domStyle.get("thinger", "opacity"); // 1 by default
			//	|	});
	
			var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
			if(l == 2 && op){
				return _getOpacity(n);
			}
			name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
			var s = style.getComputedStyle(n);
			return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]); /* CSS2Properties||String||Number */
		};
	
		style.set = function setStyle(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
			// summary:
			//		Sets styles on a node.
			// node: DOMNode|String
			//		id or reference to node to set style for
			// name: String|Object
			//		the style property to set in DOM-accessor format
			//		("borderWidth", not "border-width") or an object with key/value
			//		pairs suitable for setting each property.
			// value: String?
			//		If passed, sets value on the node for style, handling
			//		cross-browser concerns.  When setting a pixel value,
			//		be sure to include "px" in the value. For instance, top: "200px".
			//		Otherwise, in some cases, some browsers will not apply the style.
			//
			// example:
			//		Passing a node, a style property, and a value changes the
			//		current display of the node and returns the new computed value
			//	|	require(["dojo/dom-style"], function(domStyle){
			//	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
			//	|	});
			//
			// example:
			//		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
			//	|	require(["dojo/dom-style"], function(domStyle){
			//	|		domStyle.set("thinger", {
			//	|			"opacity": 0.5,
			//	|			"border": "3px solid black",
			//	|			"height": "300px"
			//	|		});
			//	|	});
			//
			// example:
			//		When the CSS style property is hyphenated, the JavaScript property is camelCased.
			//		font-size becomes fontSize, and so on.
			//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
			//	|		domStyle.set("thinger",{
			//	|			fontSize:"14pt",
			//	|			letterSpacing:"1.2em"
			//	|		});
			//	|	});
			//
			// example:
			//		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
			//		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
			//	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
			//	|	function(domStyle, query){
			//	|		query(".someClassName").style("visibility","hidden");
			//	|		// or
			//	|		query("#baz > div").style({
			//	|			opacity:0.75,
			//	|			fontSize:"13pt"
			//	|		});
			//	|	});
	
			var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
			name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
			if(l == 3){
				return op ? _setOpacity(n, value) : n.style[name] = value; // Number
			}
			for(var x in name){
				style.set(node, x, name[x]);
			}
			return style.getComputedStyle(n);
		};
	
		return style;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(2), __webpack_require__(9), __webpack_require__(8), __webpack_require__(13), __webpack_require__(15), __webpack_require__(11), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function(exports, dojo, has, lang, dom, style, ctr, conn){
		// module:
		//		dojo/dom-prop
		// summary:
		//		This module defines the core dojo DOM properties API.
	
		// TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42
	
		// =============================
		// Element properties Functions
		// =============================
	
		// helper to connect events
		var _evtHdlrMap = {}, _ctr = 1, _attrId = dojo._scopeName + "attrid";
		has.add('dom-textContent', function (global, doc, element) { return 'textContent' in element; });
	
		exports.names = {
			// properties renamed to avoid clashes with reserved words
			"class": "className",
			"for": "htmlFor",
			// properties written as camelCase
			tabindex: "tabIndex",
			readonly: "readOnly",
			colspan: "colSpan",
			frameborder: "frameBorder",
			rowspan: "rowSpan",
			textcontent: "textContent",
			valuetype: "valueType"
		};
		
		function getText(/*DOMNode*/node){
			// summary:
			//		recursion method for get('textContent') to use. Gets text value for a node.
			// description:
			//		Juse uses nodedValue so things like <br/> tags do not end up in
			//		the text as any sort of line return.
			var text = "", ch = node.childNodes;
			for(var i = 0, n; n = ch[i]; i++){
				//Skip comments.
				if(n.nodeType != 8){
					if(n.nodeType == 1){
						text += getText(n);
					}else{
						text += n.nodeValue;
					}
				}
			}
			return text;
		}
	
		exports.get = function getProp(/*DOMNode|String*/ node, /*String*/ name){
			// summary:
			//		Gets a property on an HTML element.
			// description:
			//		Handles normalized getting of properties on DOM nodes.
			//
			// node: DOMNode|String
			//		id or reference to the element to get the property on
			// name: String
			//		the name of the property to get.
			// returns:
			//		the value of the requested property or its default value
			//
			// example:
			//	|	// get the current value of the "foo" property on a node
			//	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
			//	|		domProp.get(dom.byId("nodeId"), "foo");
			//	|		// or we can just pass the id:
			//	|		domProp.get("nodeId", "foo");
			//	|	});
	
			node = dom.byId(node);
			var lc = name.toLowerCase(), propName = exports.names[lc] || name;
			
			if(propName == "textContent" && !has("dom-textContent")){
				return getText(node);
			}
			
			return node[propName];	// Anything
		};
	
		exports.set = function setProp(/*DOMNode|String*/ node, /*String|Object*/ name, /*String?*/ value){
			// summary:
			//		Sets a property on an HTML element.
			// description:
			//		Handles normalized setting of properties on DOM nodes.
			//
			//		When passing functions as values, note that they will not be
			//		directly assigned to slots on the node, but rather the default
			//		behavior will be removed and the new behavior will be added
			//		using `dojo.connect()`, meaning that event handler properties
			//		will be normalized and that some caveats with regards to
			//		non-standard behaviors for onsubmit apply. Namely that you
			//		should cancel form submission using `dojo.stopEvent()` on the
			//		passed event object instead of returning a boolean value from
			//		the handler itself.
			// node: DOMNode|String
			//		id or reference to the element to set the property on
			// name: String|Object
			//		the name of the property to set, or a hash object to set
			//		multiple properties at once.
			// value: String?
			//		The value to set for the property
			// returns:
			//		the DOM node
			//
			// example:
			//	|	// use prop() to set the tab index
			//	|	require(["dojo/dom-prop"], function(domProp){
			//	|		domProp.set("nodeId", "tabIndex", 3);
			//	|	});
			//
			// example:
			//	Set multiple values at once, including event handlers:
			//	|	require(["dojo/dom-prop"], function(domProp){
			//	|		domProp.set("formId", {
			//	|			"foo": "bar",
			//	|			"tabIndex": -1,
			//	|			"method": "POST",
			//	|		});
			//	|	});
	
			node = dom.byId(node);
			var l = arguments.length;
			if(l == 2 && typeof name != "string"){ // inline'd type check
				// the object form of setter: the 2nd argument is a dictionary
				for(var x in name){
					exports.set(node, x, name[x]);
				}
				return node; // DomNode
			}
			var lc = name.toLowerCase(), propName = exports.names[lc] || name;
			if(propName == "style" && typeof value != "string"){ // inline'd type check
				// special case: setting a style
				style.set(node, value);
				return node; // DomNode
			}
			if(propName == "innerHTML"){
				// special case: assigning HTML
				// the hash lists elements with read-only innerHTML on IE
				if(has("ie") && node.tagName.toLowerCase() in {col: 1, colgroup: 1,
							table: 1, tbody: 1, tfoot: 1, thead: 1, tr: 1, title: 1}){
					ctr.empty(node);
					node.appendChild(ctr.toDom(value, node.ownerDocument));
				}else{
					node[propName] = value;
				}
				return node; // DomNode
			}
			if(propName == "textContent" && !has("dom-textContent")) {
				ctr.empty(node);
				node.appendChild(node.ownerDocument.createTextNode(value));
				return node;
			}
			if(lang.isFunction(value)){
				// special case: assigning an event handler
				// clobber if we can
				var attrId = node[_attrId];
				if(!attrId){
					attrId = _ctr++;
					node[_attrId] = attrId;
				}
				if(!_evtHdlrMap[attrId]){
					_evtHdlrMap[attrId] = {};
				}
				var h = _evtHdlrMap[attrId][propName];
				if(h){
					//h.remove();
					conn.disconnect(h);
				}else{
					try{
						delete node[propName];
					}catch(e){}
				}
				// ensure that event objects are normalized, etc.
				if(value){
					//_evtHdlrMap[attrId][propName] = on(node, propName, value);
					_evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
				}else{
					node[propName] = null;
				}
				return node; // DomNode
			}
			node[propName] = value;
			return node;	// DomNode
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(18), __webpack_require__(20), __webpack_require__(19), __webpack_require__(22), __webpack_require__(24), __webpack_require__(25), __webpack_require__(8), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, on, hub, aspect, eventModule, mouse, has, lang){
	// module:
	//		dojo/_base/connect
	
	has.add("events-keypress-typed", function(){ // keypresses should only occur a printable character is hit
		var testKeyEvent = {charCode: 0};
		try{
			testKeyEvent = document.createEvent("KeyboardEvent");
			(testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
		}catch(e){}
		return testKeyEvent.charCode == 0 && !has("opera");
	});
	
	function connect_(obj, event, context, method, dontFix){
		method = lang.hitch(context, method);
		if(!obj || !(obj.addEventListener || obj.attachEvent)){
			// it is a not a DOM node and we are using the dojo.connect style of treating a
			// method like an event, must go right to aspect
			return aspect.after(obj || dojo.global, event, method, true);
		}
		if(typeof event == "string" && event.substring(0, 2) == "on"){
			event = event.substring(2);
		}
		if(!obj){
			obj = dojo.global;
		}
		if(!dontFix){
			switch(event){
				// dojo.connect has special handling for these event types
				case "keypress":
					event = keypress;
					break;
				case "mouseenter":
					event = mouse.enter;
					break;
				case "mouseleave":
					event = mouse.leave;
					break;
			}
		}
		return on(obj, event, method, dontFix);
	}
	
	var _punctMap = {
		106:42,
		111:47,
		186:59,
		187:43,
		188:44,
		189:45,
		190:46,
		191:47,
		192:96,
		219:91,
		220:92,
		221:93,
		222:39,
		229:113
	};
	var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";
	
	
	var _synthesizeEvent = function(evt, props){
		var faux = lang.mixin({}, evt, props);
		setKeyChar(faux);
		// FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
		// but it throws an error when preventDefault is invoked on Safari
		// does Event.preventDefault not support "apply" on Safari?
		faux.preventDefault = function(){ evt.preventDefault(); };
		faux.stopPropagation = function(){ evt.stopPropagation(); };
		return faux;
	};
	function setKeyChar(evt){
		evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
		evt.charOrCode = evt.keyChar || evt.keyCode;
	}
	var keypress;
	if(has("events-keypress-typed")){
		// this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
		var _trySetKeyCode = function(e, code){
			try{
				// squelch errors when keyCode is read-only
				// (e.g. if keyCode is ctrl or shift)
				return (e.keyCode = code);
			}catch(e){
				return 0;
			}
		};
		keypress = function(object, listener){
			var keydownSignal = on(object, "keydown", function(evt){
				// munge key/charCode
				var k=evt.keyCode;
				// These are Windows Virtual Key Codes
				// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
				var unprintable = (k!=13) && k!=32 && (k!=27||!has("ie")) && (k<48||k>90) && (k<96||k>111) && (k<186||k>192) && (k<219||k>222) && k!=229;
				// synthesize keypress for most unprintables and CTRL-keys
				if(unprintable||evt.ctrlKey){
					var c = unprintable ? 0 : k;
					if(evt.ctrlKey){
						if(k==3 || k==13){
							return listener.call(evt.currentTarget, evt); // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
						}else if(c>95 && c<106){
							c -= 48; // map CTRL-[numpad 0-9] to ASCII
						}else if((!evt.shiftKey)&&(c>=65&&c<=90)){
							c += 32; // map CTRL-[A-Z] to lowercase
						}else{
							c = _punctMap[c] || c; // map other problematic CTRL combinations to ASCII
						}
					}
					// simulate a keypress event
					var faux = _synthesizeEvent(evt, {type: 'keypress', faux: true, charCode: c});
					listener.call(evt.currentTarget, faux);
					if(has("ie")){
						_trySetKeyCode(evt, faux.keyCode);
					}
				}
			});
			var keypressSignal = on(object, "keypress", function(evt){
				var c = evt.charCode;
				c = c>=32 ? c : 0;
				evt = _synthesizeEvent(evt, {charCode: c, faux: true});
				return listener.call(this, evt);
			});
			return {
				remove: function(){
					keydownSignal.remove();
					keypressSignal.remove();
				}
			};
		};
	}else{
		if(has("opera")){
			keypress = function(object, listener){
				return on(object, "keypress", function(evt){
					var c = evt.which;
					if(c==3){
						c=99; // Mozilla maps CTRL-BREAK to CTRL-c
					}
					// can't trap some keys at all, like INSERT and DELETE
					// there is no differentiating info between DELETE and ".", or INSERT and "-"
					c = c<32 && !evt.shiftKey ? 0 : c;
					if(evt.ctrlKey && !evt.shiftKey && c>=65 && c<=90){
						// lowercase CTRL-[A-Z] keys
						c += 32;
					}
					return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
				});
			};
		}else{
			keypress = function(object, listener){
				return on(object, "keypress", function(evt){
					setKeyChar(evt);
					return listener.call(this, evt);
				});
			};
		}
	}
	
	var connect = {
		// summary:
		//		This module defines the dojo.connect API.
		//		This modules also provides keyboard event handling helpers.
		//		This module exports an extension event for emulating Firefox's keypress handling.
		//		However, this extension event exists primarily for backwards compatibility and
		//		is not recommended. WebKit and IE uses an alternate keypress handling (only
		//		firing for printable characters, to distinguish from keydown events), and most
		//		consider the WebKit/IE behavior more desirable.
	
		_keypress:keypress,
	
		connect:function(obj, event, context, method, dontFix){
			// summary:
			//		`dojo.connect` is a deprecated event handling and delegation method in
			//		Dojo. It allows one function to "listen in" on the execution of
			//		any other, triggering the second whenever the first is called. Many
			//		listeners may be attached to a function, and source functions may
			//		be either regular function calls or DOM events.
			//
			// description:
			//		Connects listeners to actions, so that after event fires, a
			//		listener is called with the same arguments passed to the original
			//		function.
			//
			//		Since `dojo.connect` allows the source of events to be either a
			//		"regular" JavaScript function or a DOM event, it provides a uniform
			//		interface for listening to all the types of events that an
			//		application is likely to deal with though a single, unified
			//		interface. DOM programmers may want to think of it as
			//		"addEventListener for everything and anything".
			//
			//		When setting up a connection, the `event` parameter must be a
			//		string that is the name of the method/event to be listened for. If
			//		`obj` is null, `kernel.global` is assumed, meaning that connections
			//		to global methods are supported but also that you may inadvertently
			//		connect to a global by passing an incorrect object name or invalid
			//		reference.
			//
			//		`dojo.connect` generally is forgiving. If you pass the name of a
			//		function or method that does not yet exist on `obj`, connect will
			//		not fail, but will instead set up a stub method. Similarly, null
			//		arguments may simply be omitted such that fewer than 4 arguments
			//		may be required to set up a connection See the examples for details.
			//
			//		The return value is a handle that is needed to
			//		remove this connection with `dojo.disconnect`.
			//
			// obj: Object?
			//		The source object for the event function.
			//		Defaults to `kernel.global` if null.
			//		If obj is a DOM node, the connection is delegated
			//		to the DOM event manager (unless dontFix is true).
			//
			// event: String
			//		String name of the event function in obj.
			//		I.e. identifies a property `obj[event]`.
			//
			// context: Object|null
			//		The object that method will receive as "this".
			//
			//		If context is null and method is a function, then method
			//		inherits the context of event.
			//
			//		If method is a string then context must be the source
			//		object object for method (context[method]). If context is null,
			//		kernel.global is used.
			//
			// method: String|Function
			//		A function reference, or name of a function in context.
			//		The function identified by method fires after event does.
			//		method receives the same arguments as the event.
			//		See context argument comments for information on method's scope.
			//
			// dontFix: Boolean?
			//		If obj is a DOM node, set dontFix to true to prevent delegation
			//		of this connection to the DOM event manager.
			//
			// example:
			//		When obj.onchange(), do ui.update():
			//	|	dojo.connect(obj, "onchange", ui, "update");
			//	|	dojo.connect(obj, "onchange", ui, ui.update); // same
			//
			// example:
			//		Using return value for disconnect:
			//	|	var link = dojo.connect(obj, "onchange", ui, "update");
			//	|	...
			//	|	dojo.disconnect(link);
			//
			// example:
			//		When onglobalevent executes, watcher.handler is invoked:
			//	|	dojo.connect(null, "onglobalevent", watcher, "handler");
			//
			// example:
			//		When ob.onCustomEvent executes, customEventHandler is invoked:
			//	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
			//	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
			//
			// example:
			//		When ob.onCustomEvent executes, customEventHandler is invoked
			//		with the same scope (this):
			//	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
			//	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
			//
			// example:
			//		When globalEvent executes, globalHandler is invoked
			//		with the same scope (this):
			//	|	dojo.connect(null, "globalEvent", null, globalHandler);
			//	|	dojo.connect("globalEvent", globalHandler); // same
	
			// normalize arguments
			var a=arguments, args=[], i=0;
			// if a[0] is a String, obj was omitted
			args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
			// if the arg-after-next is a String or Function, context was NOT omitted
			var a1 = a[i+1];
			args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
			// absorb any additional arguments
			for(var l=a.length; i<l; i++){	args.push(a[i]); }
			return connect_.apply(this, args);
		},
	
		disconnect:function(handle){
			// summary:
			//		Remove a link created by dojo.connect.
			// description:
			//		Removes the connection between event and the method referenced by handle.
			// handle: Handle
			//		the return value of the dojo.connect call that created the connection.
	
			if(handle){
				handle.remove();
			}
		},
	
		subscribe:function(topic, context, method){
			// summary:
			//		Attach a listener to a named topic. The listener function is invoked whenever the
			//		named topic is published (see: dojo.publish).
			//		Returns a handle which is needed to unsubscribe this listener.
			// topic: String
			//		The topic to which to subscribe.
			// context: Object?
			//		Scope in which method will be invoked, or null for default scope.
			// method: String|Function
			//		The name of a function in context, or a function reference. This is the function that
			//		is invoked when topic is published.
			// example:
			//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
			//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
			return hub.subscribe(topic, lang.hitch(context, method));
		},
	
		publish:function(topic, args){
			// summary:
			//		Invoke all listener method subscribed to topic.
			// topic: String
			//		The name of the topic to publish.
			// args: Array?
			//		An array of arguments. The arguments will be applied
			//		to each topic subscriber (as first class parameters, via apply).
			// example:
			//	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
			//	|	dojo.publish("alerts", [ "read this", "hello world" ]);
			return hub.publish.apply(hub, [topic].concat(args));
		},
	
		connectPublisher:function(topic, obj, event){
			// summary:
			//		Ensure that every time obj.event() is called, a message is published
			//		on the topic. Returns a handle which can be passed to
			//		dojo.disconnect() to disable subsequent automatic publication on
			//		the topic.
			// topic: String
			//		The name of the topic to publish.
			// obj: Object?
			//		The source object for the event function. Defaults to kernel.global
			//		if null.
			// event: String
			//		The name of the event function in obj.
			//		I.e. identifies a property obj[event].
			// example:
			//	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
			var pf = function(){ connect.publish(topic, arguments); };
			return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf); //Handle
		},
	
		isCopyKey: function(e){
			// summary:
			//		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
			// e: Event
			//		Event object to examine
			return e[evtCopyKey];	// Boolean
		}
	};
	
	connect.unsubscribe = connect.disconnect;
	/*=====
	 connect.unsubscribe = function(handle){
		 // summary:
		 //		Remove a topic listener.
		 // handle: Handle
		 //		The handle returned from a call to subscribe.
		 // example:
		 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
		 //	|	...
		 //	|	dojo.unsubscribe(alerter);
	 };
	 =====*/
	
	has("extend-dojo") && lang.mixin(dojo, connect);
	return connect;
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(2), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(aspect, dojo, has){
	
		"use strict";
		if(has("dom")){ // check to make sure we are in a browser, this module should work anywhere
			var major = window.ScriptEngineMajorVersion;
			has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
			has.add("event-orientationchange", has("touch") && !has("android")); // TODO: how do we detect this?
			has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
			has.add("event-focusin", function(global, doc, element){
				return 'onfocusin' in element;
			});
	
			if(has("touch")){
				has.add("touch-can-modify-event-delegate", function(){
					// This feature test checks whether deleting a property of an event delegate works
					// for a touch-enabled device. If it works, event delegation can be used as fallback
					// for browsers such as Safari in older iOS where deleting properties of the original
					// event does not work.
					var EventDelegate = function(){};
					EventDelegate.prototype =
						document.createEvent("MouseEvents"); // original event
					// Attempt to modify a property of an event delegate and check if
					// it succeeds. Depending on browsers and on whether dojo/on's
					// strict mode is stripped in a Dojo build, there are 3 known behaviors:
					// it may either succeed, or raise an error, or fail to set the property
					// without raising an error.
					try{
						var eventDelegate = new EventDelegate;
						eventDelegate.target = null;
						return eventDelegate.target === null;
					}catch(e){
						return false; // cannot use event delegation
					}
				});
			}
		}
		var on = function(target, type, listener, dontFix){
			// summary:
			//		A function that provides core event listening functionality. With this function
			//		you can provide a target, event type, and listener to be notified of
			//		future matching events that are fired.
			// target: Element|Object
			//		This is the target object or DOM element that to receive events from
			// type: String|Function
			//		This is the name of the event to listen for or an extension event type.
			// listener: Function
			//		This is the function that should be called when the event fires.
			// returns: Object
			//		An object with a remove() method that can be used to stop listening for this
			//		event.
			// description:
			//		To listen for "click" events on a button node, we can do:
			//		|	define(["dojo/on"], function(on){
			//		|		on(button, "click", clickHandler);
			//		|		...
			//		Evented JavaScript objects can also have their own events.
			//		|	var obj = new Evented;
			//		|	on(obj, "foo", fooHandler);
			//		And then we could publish a "foo" event:
			//		|	on.emit(obj, "foo", {key: "value"});
			//		We can use extension events as well. For example, you could listen for a tap gesture:
			//		|	define(["dojo/on", "dojo/gesture/tap", function(on, tap){
			//		|		on(button, tap, tapHandler);
			//		|		...
			//		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
			//		|	obj.onfoo({key:"value"});
			//		If you use on.emit on a DOM node, it will use native event dispatching when possible.
	
			if(typeof target.on == "function" && typeof type != "function" && !target.nodeType){
				// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
				// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
				// Element prototype
				return target.on(type, listener);
			}
			// delegate to main listener code
			return on.parse(target, type, listener, addListener, dontFix, this);
		};
		on.pausable =  function(target, type, listener, dontFix){
			// summary:
			//		This function acts the same as on(), but with pausable functionality. The
			//		returned signal object has pause() and resume() functions. Calling the
			//		pause() method will cause the listener to not be called for future events. Calling the
			//		resume() method will cause the listener to again be called for future events.
			var paused;
			var signal = on(target, type, function(){
				if(!paused){
					return listener.apply(this, arguments);
				}
			}, dontFix);
			signal.pause = function(){
				paused = true;
			};
			signal.resume = function(){
				paused = false;
			};
			return signal;
		};
		on.once = function(target, type, listener, dontFix){
			// summary:
			//		This function acts the same as on(), but will only call the listener once. The
			//		listener will be called for the first
			//		event that takes place and then listener will automatically be removed.
			var signal = on(target, type, function(){
				// remove this listener
				signal.remove();
				// proceed to call the listener
				return listener.apply(this, arguments);
			});
			return signal;
		};
		on.parse = function(target, type, listener, addListener, dontFix, matchesTarget){
			var events;
			if(type.call){
				// event handler function
				// on(node, touch.press, touchListener);
				return type.call(matchesTarget, target, listener);
			}
	
			if(type instanceof Array){
				// allow an array of event names (or event handler functions)
				events = type;
			}else if(type.indexOf(",") > -1){
				// we allow comma delimited event names, so you can register for multiple events at once
				events = type.split(/\s*,\s*/);
			}
			if(events){
				var handles = [];
				var i = 0;
				var eventName;
				while(eventName = events[i++]){ // intentional assignment
					handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
				}
				handles.remove = function(){
					for(var i = 0; i < handles.length; i++){
						handles[i].remove();
					}
				};
				return handles;
			}
			return addListener(target, type, listener, dontFix, matchesTarget);
		};
		var touchEvents = /^touch/;
		function addListener(target, type, listener, dontFix, matchesTarget){
			// event delegation:
			var selector = type.match(/(.*):(.*)/);
			// if we have a selector:event, the last one is interpreted as an event, and we use event delegation
			if(selector){
				type = selector[2];
				selector = selector[1];
				// create the extension event for selectors and directly call it
				return on.selector(selector, type).call(matchesTarget, target, listener);
			}
			// test to see if it a touch event right now, so we don't have to do it every time it fires
			if(has("touch")){
				if(touchEvents.test(type)){
					// touch event, fix it
					listener = fixTouchListener(listener);
				}
				if(!has("event-orientationchange") && (type == "orientationchange")){
					//"orientationchange" not supported <= Android 2.1,
					//but works through "resize" on window
					type = "resize";
					target = window;
					listener = fixTouchListener(listener);
				}
			}
			if(addStopImmediate){
				// add stopImmediatePropagation if it doesn't exist
				listener = addStopImmediate(listener);
			}
			// normal path, the target is |this|
			if(target.addEventListener){
				// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
				// check for capture conversions
				var capture = type in captures,
					adjustedType = capture ? captures[type] : type;
				target.addEventListener(adjustedType, listener, capture);
				// create and return the signal
				return {
					remove: function(){
						target.removeEventListener(adjustedType, listener, capture);
					}
				};
			}
			type = "on" + type;
			if(fixAttach && target.attachEvent){
				return fixAttach(target, type, listener);
			}
			throw new Error("Target must be an event emitter");
		}
		on.matches = function(node, selector, context, children, matchesTarget) {
			// summary:
			//		Check if a node match the current selector within the constraint of a context
			// node: DOMNode
			//		The node that originate the event
			// selector: String
			//		The selector to check against
			// context: DOMNode
			//		The context to search in.
			// children: Boolean
			//		Indicates if children elements of the selector should be allowed. This defaults to
			//		true
			// matchesTarget: Object|dojo/query?
			//		An object with a property "matches" as a function. Default is dojo/query.
			//		Matching DOMNodes will be done against this function
			//		The function must return a Boolean.
			//		It will have 3 arguments: "node", "selector" and "context"
			//		True is expected if "node" is matching the current "selector" in the passed "context"
			// returns: DOMNode?
			//		The matching node, if any. Else you get false
	
			// see if we have a valid matchesTarget or default to dojo/query
			matchesTarget = matchesTarget && (typeof matchesTarget.matches == "function") ? matchesTarget : dojo.query;
			children = children !== false;
			// there is a selector, so make sure it matches
			if(node.nodeType != 1){
				// text node will fail in native match selector
				node = node.parentNode;
			}
			while(!matchesTarget.matches(node, selector, context)){
				if(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment
					return false;
				}
			}
			return node;
		};
		on.selector = function(selector, eventType, children){
			// summary:
			//		Creates a new extension event with event delegation. This is based on
			//		the provided event type (can be extension event) that
			//		only calls the listener when the CSS selector matches the target of the event.
			//
			//		The application must require() an appropriate level of dojo/query to handle the selector.
			// selector:
			//		The CSS selector to use for filter events and determine the |this| of the event listener.
			// eventType:
			//		The event to listen for
			// children:
			//		Indicates if children elements of the selector should be allowed. This defaults to
			//		true
			// example:
			// |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(on, mouse){
			// |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
			return function(target, listener){
				// if the selector is function, use it to select the node, otherwise use the matches method
				var matchesTarget = typeof selector == "function" ? {matches: selector} : this,
					bubble = eventType.bubble;
				function select(eventTarget){
					return on.matches(eventTarget, selector, target, children, matchesTarget);
				}
				if(bubble){
					// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
					return on(target, bubble(select), listener);
				}
				// standard event delegation
				return on(target, eventType, function(event){
					// call select to see if we match
					var eventTarget = select(event.target);
					// if it matches we call the listener
					if (eventTarget) {
						// We save the matching target into the event, so it can be accessed even when hitching (see #18355)
						event.selectorTarget = eventTarget;
						return listener.call(eventTarget, event);
					}
				});
			};
		};
	
		function syntheticPreventDefault(){
			this.cancelable = false;
			this.defaultPrevented = true;
		}
		function syntheticStopPropagation(){
			this.bubbles = false;
		}
		var slice = [].slice,
			syntheticDispatch = on.emit = function(target, type, event){
			// summary:
			//		Fires an event on the target object.
			// target:
			//		The target object to fire the event on. This can be a DOM element or a plain
			//		JS object. If the target is a DOM element, native event emitting mechanisms
			//		are used when possible.
			// type:
			//		The event type name. You can emulate standard native events like "click" and
			//		"mouseover" or create custom events like "open" or "finish".
			// event:
			//		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
			//		for some of the properties. These properties are copied to the event object.
			//		Of particular importance are the cancelable and bubbles properties. The
			//		cancelable property indicates whether or not the event has a default action
			//		that can be cancelled. The event is cancelled by calling preventDefault() on
			//		the event object. The bubbles property indicates whether or not the
			//		event will bubble up the DOM tree. If bubbles is true, the event will be called
			//		on the target and then each parent successively until the top of the tree
			//		is reached or stopPropagation() is called. Both bubbles and cancelable
			//		default to false.
			// returns:
			//		If the event is cancelable and the event is not cancelled,
			//		emit will return true. If the event is cancelable and the event is cancelled,
			//		emit will return false.
			// details:
			//		Note that this is designed to emit events for listeners registered through
			//		dojo/on. It should actually work with any event listener except those
			//		added through IE's attachEvent (IE8 and below's non-W3C event emitting
			//		doesn't support custom event types). It should work with all events registered
			//		through dojo/on. Also note that the emit method does do any default
			//		action, it only returns a value to indicate if the default action should take
			//		place. For example, emitting a keypress event would not cause a character
			//		to appear in a textbox.
			// example:
			//		To fire our own click event
			//	|	require(["dojo/on", "dojo/dom"
			//	|	], function(on, dom){
			//	|		on.emit(dom.byId("button"), "click", {
			//	|			cancelable: true,
			//	|			bubbles: true,
			//	|			screenX: 33,
			//	|			screenY: 44
			//	|		});
			//		We can also fire our own custom events:
			//	|		on.emit(dom.byId("slider"), "slide", {
			//	|			cancelable: true,
			//	|			bubbles: true,
			//	|			direction: "left-to-right"
			//	|		});
			//	|	});
			var args = slice.call(arguments, 2);
			var method = "on" + type;
			if("parentNode" in target){
				// node (or node-like), create event controller methods
				var newEvent = args[0] = {};
				for(var i in event){
					newEvent[i] = event[i];
				}
				newEvent.preventDefault = syntheticPreventDefault;
				newEvent.stopPropagation = syntheticStopPropagation;
				newEvent.target = target;
				newEvent.type = type;
				event = newEvent;
			}
			do{
				// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
				target[method] && target[method].apply(target, args);
				// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
			}while(event && event.bubbles && (target = target.parentNode));
			return event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
		};
		var captures = has("event-focusin") ? {} : {focusin: "focus", focusout: "blur"};
		if(!has("event-stopimmediatepropagation")){
			var stopImmediatePropagation =function(){
				this.immediatelyStopped = true;
				this.modified = true; // mark it as modified so the event will be cached in IE
			};
			var addStopImmediate = function(listener){
				return function(event){
					if(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately
						event.stopImmediatePropagation = stopImmediatePropagation;
						return listener.apply(this, arguments);
					}
				};
			};
		}
		if(has("dom-addeventlistener")){
			// emitter that works with native event handling
			on.emit = function(target, type, event){
				if(target.dispatchEvent && document.createEvent){
					// use the native event emitting mechanism if it is available on the target object
					// create a generic event
					// we could create branch into the different types of event constructors, but
					// that would be a lot of extra code, with little benefit that I can see, seems
					// best to use the generic constructor and copy properties over, making it
					// easy to have events look like the ones created with specific initializers
					var ownerDocument = target.ownerDocument || document;
					var nativeEvent = ownerDocument.createEvent("HTMLEvents");
					nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
					// and copy all our properties over
					for(var i in event){
						if(!(i in nativeEvent)){
							nativeEvent[i] = event[i];
						}
					}
					return target.dispatchEvent(nativeEvent) && nativeEvent;
				}
				return syntheticDispatch.apply(on, arguments); // emit for a non-node
			};
		}else{
			// no addEventListener, basically old IE event normalization
			on._fixEvent = function(evt, sender){
				// summary:
				//		normalizes properties on the event object including event
				//		bubbling methods, keystroke normalization, and x/y positions
				// evt:
				//		native event object
				// sender:
				//		node to treat as "currentTarget"
				if(!evt){
					var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
					evt = w.event;
				}
				if(!evt){return evt;}
				try{
					if(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){
						// should be same event, reuse event object (so it can be augmented);
						// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
						evt = lastEvent;
					}
				}catch(e){
					// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already
					// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet
				}
				if(!evt.target){ // check to see if it has been fixed yet
					evt.target = evt.srcElement;
					evt.currentTarget = (sender || evt.srcElement);
					if(evt.type == "mouseover"){
						evt.relatedTarget = evt.fromElement;
					}
					if(evt.type == "mouseout"){
						evt.relatedTarget = evt.toElement;
					}
					if(!evt.stopPropagation){
						evt.stopPropagation = stopPropagation;
						evt.preventDefault = preventDefault;
					}
					switch(evt.type){
						case "keypress":
							var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
							if (c==10){
								// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
								c=0;
								evt.keyCode = 13;
							}else if(c==13||c==27){
								c=0; // Mozilla considers ENTER and ESC non-printable
							}else if(c==3){
								c=99; // Mozilla maps CTRL-BREAK to CTRL-c
							}
							// Mozilla sets keyCode to 0 when there is a charCode
							// but that stops the event on IE.
							evt.charCode = c;
							_setKeyChar(evt);
							break;
					}
				}
				return evt;
			};
			var lastEvent, IESignal = function(handle){
				this.handle = handle;
			};
			IESignal.prototype.remove = function(){
				delete _dojoIEListeners_[this.handle];
			};
			var fixListener = function(listener){
				// this is a minimal function for closing on the previous listener with as few as variables as possible
				return function(evt){
					evt = on._fixEvent(evt, this);
					var result = listener.call(this, evt);
					if(evt.modified){
						// cache the last event and reuse it if we can
						if(!lastEvent){
							setTimeout(function(){
								lastEvent = null;
							});
						}
						lastEvent = evt;
					}
					return result;
				};
			};
			var fixAttach = function(target, type, listener){
				listener = fixListener(listener);
				if(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||
							has("jscript") < 5.8) &&
						!has("config-_allow_leaks")){
					// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
					// Here we use global redirection to solve the memory leaks
					if(typeof _dojoIEListeners_ == "undefined"){
						_dojoIEListeners_ = [];
					}
					var emitter = target[type];
					if(!emitter || !emitter.listeners){
						var oldListener = emitter;
						emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
						emitter.listeners = [];
						target[type] = emitter;
						emitter.global = this;
						if(oldListener){
							emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
						}
					}
					var handle;
					emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
					return new IESignal(handle);
				}
				return aspect.after(target, type, listener, true);
			};
	
			var _setKeyChar = function(evt){
				evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
				evt.charOrCode = evt.keyChar || evt.keyCode;	// TODO: remove for 2.0
			};
			// Called in Event scope
			var stopPropagation = function(){
				this.cancelBubble = true;
			};
			var preventDefault = on._preventDefault = function(){
				// Setting keyCode to 0 is the only way to prevent certain keypresses (namely
				// ctrl-combinations that correspond to menu accelerator keys).
				// Otoh, it prevents upstream listeners from getting this information
				// Try to split the difference here by clobbering keyCode only for ctrl
				// combinations. If you still need to access the key upstream, bubbledKeyCode is
				// provided as a workaround.
				this.bubbledKeyCode = this.keyCode;
				if(this.ctrlKey){
					try{
						// squelch errors when keyCode is read-only
						// (e.g. if keyCode is ctrl or shift)
						this.keyCode = 0;
					}catch(e){
					}
				}
				this.defaultPrevented = true;
				this.returnValue = false;
				this.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
			};
		}
		if(has("touch")){
			var EventDelegate = function(){};
			var windowOrientation = window.orientation;
			var fixTouchListener = function(listener){
				return function(originalEvent){
					//Event normalization(for ontouchxxx and resize):
					//1.incorrect e.pageX|pageY in iOS
					//2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
					//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY
	
					// see if it has already been corrected
					var event = originalEvent.corrected;
					if(!event){
						var type = originalEvent.type;
						try{
							delete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable
						}catch(e){}
						if(originalEvent.type){
							// Deleting the property of the original event did not work (this is the case of
							// browsers such as older Safari iOS), hence fallback:
							if(has("touch-can-modify-event-delegate")){
								// If deleting properties of delegated event works, use event delegation:
								EventDelegate.prototype = originalEvent;
								event = new EventDelegate;
							}else{
								// Otherwise last fallback: other browsers, such as mobile Firefox, do not like
								// delegated properties, so we have to copy
								event = {};
								for(var name in originalEvent){
									event[name] = originalEvent[name];
								}
							}
							// have to delegate methods to make them work
							event.preventDefault = function(){
								originalEvent.preventDefault();
							};
							event.stopPropagation = function(){
								originalEvent.stopPropagation();
							};
						}else{
							// deletion worked, use property as is
							event = originalEvent;
							event.type = type;
						}
						originalEvent.corrected = event;
						if(type == 'resize'){
							if(windowOrientation == window.orientation){
								return null;//double tap causes an unexpected 'resize' in Android
							}
							windowOrientation = window.orientation;
							event.type = "orientationchange";
							return listener.call(this, event);
						}
						// We use the original event and augment, rather than doing an expensive mixin operation
						if(!("rotation" in event)){ // test to see if it has rotation
							event.rotation = 0;
							event.scale = 1;
						}
						//use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
						var firstChangeTouch = event.changedTouches[0];
						for(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here
							delete event[i]; // delete it first to make it mutable
							event[i] = firstChangeTouch[i];
						}
					}
					return listener.call(this, event);
				};
			};
		}
		return on;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){
	
		// module:
		//		dojo/aspect
	
		"use strict";
		var undefined;
		function advise(dispatcher, type, advice, receiveArguments){
			var previous = dispatcher[type];
			var around = type == "around";
			var signal;
			if(around){
				var advised = advice(function(){
					return previous.advice(this, arguments);
				});
				signal = {
					remove: function(){
						if(advised){
							advised = dispatcher = advice = null;
						}
					},
					advice: function(target, args){
						return advised ?
							advised.apply(target, args) :  // called the advised function
							previous.advice(target, args); // cancelled, skip to next one
					}
				};
			}else{
				// create the remove handler
				signal = {
					remove: function(){
						if(signal.advice){
							var previous = signal.previous;
							var next = signal.next;
							if(!next && !previous){
								delete dispatcher[type];
							}else{
								if(previous){
									previous.next = next;
								}else{
									dispatcher[type] = next;
								}
								if(next){
									next.previous = previous;
								}
							}
	
							// remove the advice to signal that this signal has been removed
							dispatcher = advice = signal.advice = null;
						}
					},
					id: dispatcher.nextId++,
					advice: advice,
					receiveArguments: receiveArguments
				};
			}
			if(previous && !around){
				if(type == "after"){
					// add the listener to the end of the list
					// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
					while(previous.next && (previous = previous.next)){}
					previous.next = signal;
					signal.previous = previous;
				}else if(type == "before"){
					// add to beginning
					dispatcher[type] = signal;
					signal.next = previous;
					previous.previous = signal;
				}
			}else{
				// around or first one just replaces
				dispatcher[type] = signal;
			}
			return signal;
		}
		function aspect(type){
			return function(target, methodName, advice, receiveArguments){
				var existing = target[methodName], dispatcher;
				if(!existing || existing.target != target){
					// no dispatcher in place
					target[methodName] = dispatcher = function(){
						var executionId = dispatcher.nextId;
						// before advice
						var args = arguments;
						var before = dispatcher.before;
						while(before){
							if(before.advice){
								args = before.advice.apply(this, args) || args;
							}
							before = before.next;
						}
						// around advice
						if(dispatcher.around){
							var results = dispatcher.around.advice(this, args);
						}
						// after advice
						var after = dispatcher.after;
						while(after && after.id < executionId){
							if(after.advice){
								if(after.receiveArguments){
									var newResults = after.advice.apply(this, args);
									// change the return value only if a new value was returned
									results = newResults === undefined ? results : newResults;
								}else{
									results = after.advice.call(this, results, args);
								}
							}
							after = after.next;
						}
						return results;
					};
					if(existing){
						dispatcher.around = {advice: function(target, args){
							return existing.apply(target, args);
						}};
					}
					dispatcher.target = target;
					dispatcher.nextId = dispatcher.nextId || 0;
				}
				var results = advise((dispatcher || existing), type, advice, receiveArguments);
				advice = null;
				return results;
			};
		}
	
		// TODOC: after/before/around return object
	
		var after = aspect("after");
		/*=====
		after = function(target, methodName, advice, receiveArguments){
			// summary:
			//		The "after" export of the aspect module is a function that can be used to attach
			//		"after" advice to a method. This function will be executed after the original method
			//		is executed. By default the function will be called with a single argument, the return
			//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
			//		The fourth (optional) argument can be set to true to so the function receives the original
			//		arguments (from when the original method was called) rather than the return value.
			//		If there are multiple "after" advisors, they are executed in the order they were registered.
			// target: Object
			//		This is the target object
			// methodName: String
			//		This is the name of the method to attach to.
			// advice: Function
			//		This is function to be called after the original method
			// receiveArguments: Boolean?
			//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
			//		was called) rather than the return value of the original/previous method.
			// returns:
			//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
			//		stop the advice function from being executed.
		};
		=====*/
	
		var before = aspect("before");
		/*=====
		before = function(target, methodName, advice){
			// summary:
			//		The "before" export of the aspect module is a function that can be used to attach
			//		"before" advice to a method. This function will be executed before the original method
			//		is executed. This function will be called with the arguments used to call the method.
			//		This function may optionally return an array as the new arguments to use to call
			//		the original method (or the previous, next-to-execute before advice, if one exists).
			//		If the before method doesn't return anything (returns undefined) the original arguments
			//		will be preserved.
			//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
			// target: Object
			//		This is the target object
			// methodName: String
			//		This is the name of the method to attach to.
			// advice: Function
			//		This is function to be called before the original method
		};
		=====*/
	
		var around = aspect("around");
		/*=====
		 around = function(target, methodName, advice){
			// summary:
			//		The "around" export of the aspect module is a function that can be used to attach
			//		"around" advice to a method. The advisor function is immediately executed when
			//		the around() is called, is passed a single argument that is a function that can be
			//		called to continue execution of the original method (or the next around advisor).
			//		The advisor function should return a function, and this function will be called whenever
			//		the method is called. It will be called with the arguments used to call the method.
			//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
			// example:
			//		If there are multiple "around" advisors, the most recent one is executed first,
			//		which can then delegate to the next one and so on. For example:
			//		|	around(obj, "foo", function(originalFoo){
			//		|		return function(){
			//		|			var start = new Date().getTime();
			//		|			var results = originalFoo.apply(this, arguments); // call the original
			//		|			var end = new Date().getTime();
			//		|			console.log("foo execution took " + (end - start) + " ms");
			//		|			return results;
			//		|		};
			//		|	});
			// target: Object
			//		This is the target object
			// methodName: String
			//		This is the name of the method to attach to.
			// advice: Function
			//		This is function to be called around the original method
		};
		=====*/
	
		return {
			// summary:
			//		provides aspect oriented programming functionality, allowing for
			//		one to add before, around, or after advice on existing methods.
			// example:
			//	|	define(["dojo/aspect"], function(aspect){
			//	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
			//	|			this will be called when targetObject.methodName() is called, after the original function is called
			//	|		});
			//
			// example:
			//	The returned signal object can be used to cancel the advice.
			//	|	signal.remove(); // this will stop the advice from being executed anymore
			//	|	aspect.before(targetObject, "methodName", function(someArgument){
			//	|		// this will be called when targetObject.methodName() is called, before the original function is called
			//	|	 });
	
			before: before,
			around: around,
			after: after
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(21)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Evented){
	
		// module:
		//		dojo/topic
	
		var hub = new Evented;
		return {
			// summary:
			//		Pubsub hub.
			// example:
			//		| 	topic.subscribe("some/topic", function(event){
			//		|	... do something with event
			//		|	});
			//		|	topic.publish("some/topic", {name:"some event", ...});
	
			publish: function(topic, event){
				// summary:
				//		Publishes a message to a topic on the pub/sub hub. All arguments after
				//		the first will be passed to the subscribers, so any number of arguments
				//		can be provided (not just event).
				// topic: String
				//		The name of the topic to publish to
				// event: Object
				//		An event to distribute to the topic listeners
				return hub.emit.apply(hub, arguments);
			},
	
			subscribe: function(topic, listener){
				// summary:
				//		Subscribes to a topic on the pub/sub hub
				// topic: String
				//		The topic to subscribe to
				// listener: Function
				//		A function to call when a message is published to the given topic
				return hub.on.apply(hub, arguments);
			}
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(18)], __WEBPACK_AMD_DEFINE_RESULT__ = function(aspect, on){
		// module:
		//		dojo/Evented
	
	 	"use strict";
	 	var after = aspect.after;
		function Evented(){
			// summary:
			//		A class that can be used as a mixin or base class,
			//		to add on() and emit() methods to a class
			//		for listening for events and emitting events:
			// example:
			//		|	define(["dojo/Evented", "dojo/_base/declare", "dojo/Stateful"
			//		|	], function(Evented, declare, Stateful){
			//		|		var EventedStateful = declare([Evented, Stateful], {...});
			//		|		var instance = new EventedStateful();
			//		|		instance.on("open", function(event){
			//		|		... do something with event
			//		|	 });
			//		|
			//		|	instance.emit("open", {name:"some event", ...});
		}
		Evented.prototype = {
			on: function(type, listener){
				return on.parse(this, type, listener, function(target, type){
					return after(target, 'on' + type, listener, true);
				});
			},
			emit: function(type, event){
				var args = [this];
				args.push.apply(args, arguments);
				return on.emit.apply(on, args);
			}
		};
		return Evented;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(18), __webpack_require__(4), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, on, has, dom){
		// module:
		//		dojo/_base/event
	
		if(on._fixEvent){
			var fixEvent = on._fixEvent;
			on._fixEvent = function(evt, se){
				// add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
				evt = fixEvent(evt, se);
				if(evt){
					dom.normalizeEvent(evt);
				}
				return evt;
			};		
		}
		
		var ret = {
			// summary:
			//		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
			//		evt.preventDefault(), rather than this module.
	
			fix: function(/*Event*/ evt, /*DOMNode*/ sender){
				// summary:
				//		normalizes properties on the event object including event
				//		bubbling methods, keystroke normalization, and x/y positions
				// evt: Event
				//		native event object
				// sender: DOMNode
				//		node to treat as "currentTarget"
				if(on._fixEvent){
					return on._fixEvent(evt, sender);
				}
				return evt;	// Event
			},
		
			stop: function(/*Event*/ evt){
				// summary:
				//		prevents propagation and clobbers the default action of the
				//		passed event
				// evt: Event
				//		The event object. If omitted, window.event is used on IE.
				if(has("dom-addeventlistener") || (evt && evt.preventDefault)){
					evt.preventDefault();
					evt.stopPropagation();
				}else{
					evt = evt || window.event;
					evt.cancelBubble = true;
					on._preventDefault.call(evt);
				}
			}
		};
	
		if(has("extend-dojo")){
			dojo.fixEvent = ret.fix;
			dojo.stopEvent = ret.stop;
		}
	
		return ret;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(9), __webpack_require__(12),__webpack_require__(13), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, win, dom, style){
		// module:
		//		dojo/dom-geometry
	
		// the result object
		var geom = {
			// summary:
			//		This module defines the core dojo DOM geometry API.
		};
	
		// Box functions will assume this model.
		// On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
		// Can be set to change behavior of box setters.
	
		// can be either:
		//	"border-box"
		//	"content-box" (default)
		geom.boxModel = "content-box";
	
		// We punt per-node box mode testing completely.
		// If anybody cares, we can provide an additional (optional) unit
		// that overrides existing code to include per-node box sensitivity.
	
		// Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
		// but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
		// IIRC, earlier versions of Opera did in fact use border-box.
		// Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.
	
		if(has("ie") /*|| has("opera")*/){
			// client code may have to adjust if compatMode varies across iframes
			geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
		}
	
		geom.getPadExtents = function getPadExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		Returns object with special values specifically useful for node
			//		fitting.
			// description:
			//		Returns an object with `w`, `h`, `l`, `t` properties:
			//	|		l/t/r/b = left/top/right/bottom padding (respectively)
			//	|		w = the total of the left and right padding
			//	|		h = the total of the top and bottom padding
			//		If 'node' has position, l/t forms the origin for child nodes.
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
				l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};
	
		var none = "none";
	
		geom.getBorderExtents = function getBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object with properties useful for noting the border
			//		dimensions.
			// description:
			//		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
			//		- w = the sum of the left and right border
			//		- h = the sum of the top and bottom border
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node),
				l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0,
				t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0,
				r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0,
				b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};
	
		geom.getPadBorderExtents = function getPadBorderExtents(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		Returns object with properties useful for box fitting with
			//		regards to padding.
			// description:
			//		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
			//		- w = the sum of the left and right padding and border
			//		- h = the sum of the top and bottom padding and border
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node),
				p = geom.getPadExtents(node, s),
				b = geom.getBorderExtents(node, s);
			return {
				l: p.l + b.l,
				t: p.t + b.t,
				r: p.r + b.r,
				b: p.b + b.b,
				w: p.w + b.w,
				h: p.h + b.h
			};
		};
	
		geom.getMarginExtents = function getMarginExtents(node, computedStyle){
			// summary:
			//		returns object with properties useful for box fitting with
			//		regards to box margins (i.e., the outer-box).
			//
			//		- l/t = marginLeft, marginTop, respectively
			//		- w = total width, margin inclusive
			//		- h = total height, margin inclusive
			//
			//		The w/h are used for calculating boxes.
			//		Normally application code will not need to invoke this
			//		directly, and will use the ...box... functions instead.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue,
				l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
			return {l: l, t: t, r: r, b: b, w: l + r, h: t + b};
		};
	
		// Box getters work in any box context because offsetWidth/clientWidth
		// are invariant wrt box context
		//
		// They do *not* work for display: inline objects that have padding styles
		// because the user agent ignores padding (it's bogus styling in any case)
		//
		// Be careful with IMGs because they are inline or block depending on
		// browser and browser mode.
	
		// Although it would be easier to read, there are not separate versions of
		// _getMarginBox for each browser because:
		// 1. the branching is not expensive
		// 2. factoring the shared code wastes cycles (function call overhead)
		// 3. duplicating the shared code wastes bytes
	
		geom.getMarginBox = function getMarginBox(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object that encodes the width, height, left and top
			//		positions of the node's margin box.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s),
				l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
			if(has("mozilla")){
				// Mozilla:
				// If offsetParent has a computed overflow != visible, the offsetLeft is decreased
				// by the parent's border.
				// We don't want to compute the parent's style, so instead we examine node's
				// computed left/top which is more stable.
				var sl = parseFloat(s.left), st = parseFloat(s.top);
				if(!isNaN(sl) && !isNaN(st)){
					l = sl;
					t = st;
				}else{
					// If child's computed left/top are not parseable as a number (e.g. "auto"), we
					// have no choice but to examine the parent's computed style.
					if(p && p.style){
						pcs = style.getComputedStyle(p);
						if(pcs.overflow != "visible"){
							l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
							t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
						}
					}
				}
			}else if(has("opera") || (has("ie") == 8 && !has("quirks"))){
				// On Opera and IE 8, offsetLeft/Top includes the parent's border
				if(p){
					pcs = style.getComputedStyle(p);
					l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
					t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
				}
			}
			return {l: l, t: t, w: node.offsetWidth + me.w, h: node.offsetHeight + me.h};
		};
	
		geom.getContentBox = function getContentBox(node, computedStyle){
			// summary:
			//		Returns an object that encodes the width, height, left and top
			//		positions of the node's content box, irrespective of the
			//		current box model.
			// node: DOMNode
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			// clientWidth/Height are important since the automatically account for scrollbars
			// fallback to offsetWidth/Height for special cases (see #3378)
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h,
				pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
			if(!w){
				w = node.offsetWidth;
				h = node.offsetHeight;
			}else{
				h = node.clientHeight;
				be.w = be.h = 0;
			}
			// On Opera, offsetLeft includes the parent's border
			if(has("opera")){
				pe.l += be.l;
				pe.t += be.t;
			}
			return {l: pe.l, t: pe.t, w: w - pe.w - be.w, h: h - pe.h - be.h};
		};
	
		// Box setters depend on box context because interpretation of width/height styles
		// vary wrt box context.
		//
		// The value of boxModel is used to determine box context.
		// boxModel can be set directly to change behavior.
		//
		// Beware of display: inline objects that have padding styles
		// because the user agent ignores padding (it's a bogus setup anyway)
		//
		// Be careful with IMGs because they are inline or block depending on
		// browser and browser mode.
		//
		// Elements other than DIV may have special quirks, like built-in
		// margins or padding, or values not detectable via computedStyle.
		// In particular, margins on TABLE do not seems to appear
		// at all in computedStyle on Mozilla.
	
		function setBox(/*DomNode*/ node, /*Number?*/ l, /*Number?*/ t, /*Number?*/ w, /*Number?*/ h, /*String?*/ u){
			// summary:
			//		sets width/height/left/top in the current (native) box-model
			//		dimensions. Uses the unit passed in u.
			// node:
			//		DOM Node reference. Id string not supported for performance
			//		reasons.
			// l:
			//		left offset from parent.
			// t:
			//		top offset from parent.
			// w:
			//		width in current box model.
			// h:
			//		width in current box model.
			// u:
			//		unit measure to use for other measures. Defaults to "px".
			u = u || "px";
			var s = node.style;
			if(!isNaN(l)){
				s.left = l + u;
			}
			if(!isNaN(t)){
				s.top = t + u;
			}
			if(w >= 0){
				s.width = w + u;
			}
			if(h >= 0){
				s.height = h + u;
			}
		}
	
		function isButtonTag(/*DomNode*/ node){
			// summary:
			//		True if the node is BUTTON or INPUT.type="button".
			return node.tagName.toLowerCase() == "button" ||
				node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button"; // boolean
		}
	
		function usesBorderBox(/*DomNode*/ node){
			// summary:
			//		True if the node uses border-box layout.
	
			// We could test the computed style of node to see if a particular box
			// has been specified, but there are details and we choose not to bother.
	
			// TABLE and BUTTON (and INPUT type=button) are always border-box by default.
			// If you have assigned a different box to either one via CSS then
			// box functions will break.
	
			return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node); // boolean
		}
	
		geom.setContentSize = function setContentSize(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
			// summary:
			//		Sets the size of the node's contents, irrespective of margins,
			//		padding, or borders.
			// node: DOMNode
			// box: Object
			//		hash with optional "w", and "h" properties for "width", and "height"
			//		respectively. All specified properties should have numeric values in whole pixels.
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var w = box.w, h = box.h;
			if(usesBorderBox(node)){
				var pb = geom.getPadBorderExtents(node, computedStyle);
				if(w >= 0){
					w += pb.w;
				}
				if(h >= 0){
					h += pb.h;
				}
			}
			setBox(node, NaN, NaN, w, h);
		};
	
		var nilExtents = {l: 0, t: 0, w: 0, h: 0};
	
		geom.setMarginBox = function setMarginBox(/*DomNode*/ node, /*Object*/ box, /*Object*/ computedStyle){
			// summary:
			//		sets the size of the node's margin box and placement
			//		(left/top), irrespective of box model. Think of it as a
			//		passthrough to setBox that handles box-model vagaries for
			//		you.
			// node: DOMNode
			// box: Object
			//		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
			//		respectively. All specified properties should have numeric values in whole pixels.
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
			// Some elements have special padding, margin, and box-model settings.
			// To use box functions you may need to set padding, margin explicitly.
			// Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
				pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s),
				mb = geom.getMarginExtents(node, s);
			if(has("webkit")){
				// on Safari (3.1.2), button nodes with no explicit size have a default margin
				// setting an explicit size eliminates the margin.
				// We have to swizzle the width to get correct margin reading.
				if(isButtonTag(node)){
					var ns = node.style;
					if(w >= 0 && !ns.width){
						ns.width = "4px";
					}
					if(h >= 0 && !ns.height){
						ns.height = "4px";
					}
				}
			}
			if(w >= 0){
				w = Math.max(w - pb.w - mb.w, 0);
			}
			if(h >= 0){
				h = Math.max(h - pb.h - mb.h, 0);
			}
			setBox(node, box.l, box.t, w, h);
		};
	
		// =============================
		// Positioning
		// =============================
	
		geom.isBodyLtr = function isBodyLtr(/*Document?*/ doc){
			// summary:
			//		Returns true if the current language is left-to-right, and false otherwise.
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Boolean
	
			doc = doc || win.doc;
			return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr"; // Boolean
		};
	
		geom.docScroll = function docScroll(/*Document?*/ doc){
			// summary:
			//		Returns an object with {node, x, y} with corresponding offsets.
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Object
	
			doc = doc || win.doc;
			var node = win.doc.parentWindow || win.doc.defaultView;   // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
			return "pageXOffset" in node ? {x: node.pageXOffset, y: node.pageYOffset } :
				(node = has("quirks") ? win.body(doc) : doc.documentElement) &&
					{x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y: node.scrollTop || 0 };
		};
	
		geom.getIeDocumentElementOffset = function(/*Document?*/ doc){
			// summary:
			//		Deprecated method previously used for IE6-IE7.  Now, just returns `{x:0, y:0}`.
			return {
				x: 0,
				y: 0
			};
		};
	
		geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(/*Integer*/ scrollLeft, /*Document?*/ doc){
			// summary:
			//		In RTL direction, scrollLeft should be a negative value, but IE
			//		returns a positive one. All codes using documentElement.scrollLeft
			//		must call this function to fix this error, otherwise the position
			//		will offset to right when there is a horizontal scrollbar.
			// scrollLeft: Number
			// doc: Document?
			//		Optional document to query.   If unspecified, use win.doc.
			// returns: Number
	
			// In RTL direction, scrollLeft should be a negative value, but IE
			// returns a positive one. All codes using documentElement.scrollLeft
			// must call this function to fix this error, otherwise the position
			// will offset to right when there is a horizontal scrollbar.
	
			doc = doc || win.doc;
			var ie = has("ie");
			if(ie && !geom.isBodyLtr(doc)){
				var qk = has("quirks"),
					de = qk ? win.body(doc) : doc.documentElement,
					pwin = win.global;	// TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
				if(ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight){
					scrollLeft += de.clientLeft; // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
				}
				return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft; // Integer
			}
			return scrollLeft; // Integer
		};
	
		geom.position = function(/*DomNode*/ node, /*Boolean?*/ includeScroll){
			// summary:
			//		Gets the position and size of the passed element relative to
			//		the viewport (if includeScroll==false), or relative to the
			//		document root (if includeScroll==true).
			//
			// description:
			//		Returns an object of the form:
			//		`{ x: 100, y: 300, w: 20, h: 15 }`.
			//		If includeScroll==true, the x and y values will include any
			//		document offsets that may affect the position relative to the
			//		viewport.
			//		Uses the border-box model (inclusive of border and padding but
			//		not margin).  Does not act as a setter.
			// node: DOMNode|String
			// includeScroll: Boolean?
			// returns: Object
	
			node = dom.byId(node);
			var	db = win.body(node.ownerDocument),
				ret = node.getBoundingClientRect();
			ret = {x: ret.left, y: ret.top, w: ret.right - ret.left, h: ret.bottom - ret.top};
	
			if(has("ie") < 9){
				// fixes the position in IE, quirks mode
				ret.x -= (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
				ret.y -= (has("quirks") ? db.clientTop + db.offsetTop : 0);
			}
	
			// account for document scrolling
			// if offsetParent is used, ret value already includes scroll position
			// so we may have to actually remove that value if !includeScroll
			if(includeScroll){
				var scroll = geom.docScroll(node.ownerDocument);
				ret.x += scroll.x;
				ret.y += scroll.y;
			}
	
			return ret; // Object
		};
	
		// random "private" functions wildly used throughout the toolkit
	
		geom.getMarginSize = function getMarginSize(/*DomNode*/ node, /*Object*/ computedStyle){
			// summary:
			//		returns an object that encodes the width and height of
			//		the node's margin box
			// node: DOMNode|String
			// computedStyle: Object?
			//		This parameter accepts computed styles object.
			//		If this parameter is omitted, the functions will call
			//		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
			//		dojo/dom-style.getComputedStyle once, and then pass the reference to this
			//		computedStyle parameter. Wherever possible, reuse the returned
			//		object of dojo/dom-style.getComputedStyle().
	
			node = dom.byId(node);
			var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
			var size = node.getBoundingClientRect();
			return {
				w: (size.right - size.left) + me.w,
				h: (size.bottom - size.top) + me.h
			};
		};
	
		geom.normalizeEvent = function(event){
			// summary:
			//		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
			//		offsetX, offsetY, layerX, and layerX properties
			// event: Object
			if(!("layerX" in event)){
				event.layerX = event.offsetX;
				event.layerY = event.offsetY;
			}
	
			if(!("pageX" in event)){
				// FIXME: scroll position query is duped from dojo/_base/html to
				// avoid dependency on that entire module. Now that HTML is in
				// Base, we should convert back to something similar there.
				var se = event.target;
				var doc = (se && se.ownerDocument) || document;
				// DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
				// here rather than document.body
				var docBody = has("quirks") ? doc.body : doc.documentElement;
				event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc);
				event.pageY = event.clientY + (docBody.scrollTop || 0);
			}
		};
	
		// TODO: evaluate separate getters/setters for position and sizes?
	
		return geom;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(18), __webpack_require__(4), __webpack_require__(13), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, on, has, dom, win){
	
		// module:
		//		dojo/mouse
	
	    has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
		has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
		has.add("events-mousewheel", win.doc && 'onmousewheel' in win.doc);
	
		var mouseButtons;
		if((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")){
			mouseButtons = {
				LEFT:   1,
				MIDDLE: 4,
				RIGHT:  2,
				// helper functions
				isButton: function(e, button){ return e.button & button; },
				isLeft:   function(e){ return e.button & 1; },
				isMiddle: function(e){ return e.button & 4; },
				isRight:  function(e){ return e.button & 2; }
			};
		}else{
			mouseButtons = {
				LEFT:   0,
				MIDDLE: 1,
				RIGHT:  2,
				// helper functions
				isButton: function(e, button){ return e.button == button; },
				isLeft:   function(e){ return e.button == 0; },
				isMiddle: function(e){ return e.button == 1; },
				isRight:  function(e){ return e.button == 2; }
			};
		}
		dojo.mouseButtons = mouseButtons;
	
	/*=====
		dojo.mouseButtons = {
			// LEFT: Number
			//		Numeric value of the left mouse button for the platform.
			LEFT:   0,
			// MIDDLE: Number
			//		Numeric value of the middle mouse button for the platform.
			MIDDLE: 1,
			// RIGHT: Number
			//		Numeric value of the right mouse button for the platform.
			RIGHT:  2,
	
			isButton: function(e, button){
				// summary:
				//		Checks an event object for a pressed button
				// e: Event
				//		Event object to examine
				// button: Number
				//		The button value (example: dojo.mouseButton.LEFT)
				return e.button == button; // Boolean
			},
			isLeft: function(e){
				// summary:
				//		Checks an event object for the pressed left button
				// e: Event
				//		Event object to examine
				return e.button == 0; // Boolean
			},
			isMiddle: function(e){
				// summary:
				//		Checks an event object for the pressed middle button
				// e: Event
				//		Event object to examine
				return e.button == 1; // Boolean
			},
			isRight: function(e){
				// summary:
				//		Checks an event object for the pressed right button
				// e: Event
				//		Event object to examine
				return e.button == 2; // Boolean
			}
		};
	=====*/
	
		function eventHandler(type, selectHandler){
			// emulation of mouseenter/leave with mouseover/out using descendant checking
			var handler = function(node, listener){
				return on(node, type, function(evt){
					if(selectHandler){
						return selectHandler(evt, listener);
					}
					if(!dom.isDescendant(evt.relatedTarget, node)){
						return listener.call(this, evt);
					}
				});
			};
			handler.bubble = function(select){
				return eventHandler(type, function(evt, listener){
					// using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
					var target = select(evt.target);
					var relatedTarget = evt.relatedTarget;
					if(target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))){
						return listener.call(target, evt);
					} 
				});
			};
			return handler;
		}
		var wheel;
		if(has("events-mousewheel")){
			wheel = 'mousewheel';
		}else{ //firefox
			wheel = function(node, listener){
				return on(node, 'DOMMouseScroll', function(evt){
					evt.wheelDelta = -evt.detail;
					listener.call(this, evt);
				});
			};
		}
		return {
			// summary:
			//		This module provide mouse event handling utility functions and exports
			//		mouseenter and mouseleave event emulation.
			// example:
			//		To use these events, you register a mouseenter like this:
			//		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
			//		|		on(targetNode, mouse.enter, function(event){
			//		|			dojo.addClass(targetNode, "highlighted");
			//		|		});
			//		|		on(targetNode, mouse.leave, function(event){
			//		|			dojo.removeClass(targetNode, "highlighted");
			//		|		});
	
			_eventHandler: eventHandler,		// for dojo/touch
	
			// enter: Synthetic Event
			//		This is an extension event for the mouseenter that IE provides, emulating the
			//		behavior on other browsers.
			enter: eventHandler("mouseover"),
	
			// leave: Synthetic Event
			//		This is an extension event for the mouseleave that IE provides, emulating the
			//		behavior on other browsers.
			leave: eventHandler("mouseout"),
	
			// wheel: Normalized Mouse Wheel Event
			//		This is an extension event for the mousewheel that non-Mozilla browsers provide,
			//		emulating the behavior on Mozilla based browsers.
			wheel: wheel,
	
			isLeft: mouseButtons.isLeft,
			/*=====
			isLeft: function(){
				// summary:
				//		Test an event object (from a mousedown event) to see if the left button was pressed.
			},
			=====*/
	
			isMiddle: mouseButtons.isMiddle,
			/*=====
			 isMiddle: function(){
				 // summary:
				 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
			 },
			 =====*/
	
			isRight: mouseButtons.isRight
			/*=====
			 , isRight: function(){
				 // summary:
				 //		Test an event object (from a mousedown event) to see if the right button was pressed.
			 }
			 =====*/
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(8), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, lang, has){
		// module:
		//		dojo/_base/sniff
	
		/*=====
		return {
			// summary:
			//		Deprecated.   New code should use dojo/sniff.
			//		This module populates the dojo browser version sniffing properties like dojo.isIE.
		};
		=====*/
	
		if(!has("host-browser")){
			return has;
		}
	
		// no idea what this is for, or if it's used
		dojo._name = "browser";
	
		lang.mixin(dojo, {
			// isBrowser: Boolean
			//		True if the client is a web-browser
			isBrowser: true,
	
			// isFF: Number|undefined
			//		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
			//		major detected FireFox version (1.5, 2, 3, etc.)
			isFF: has("ff"),
	
			// isIE: Number|undefined
			//		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
			//		major detected IE version (6, 7, 8, etc.)
			isIE: has("ie"),
	
			// isKhtml: Number|undefined
			//		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
			//		detected version.
			isKhtml: has("khtml"),
	
			// isWebKit: Number|undefined
			//		Version as a Number if client is a WebKit-derived browser (Konqueror,
			//		Safari, Chrome, etc.). undefined otherwise.
			isWebKit: has("webkit"),
	
			// isMozilla: Number|undefined
			//		Version as a Number if client is a Mozilla-based browser (Firefox,
			//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
			isMozilla: has("mozilla"),
			// isMoz: Number|undefined
			//		Version as a Number if client is a Mozilla-based browser (Firefox,
			//		SeaMonkey). undefined otherwise. Corresponds to major detected version.
			isMoz: has("mozilla"),
	
			// isOpera: Number|undefined
			//		Version as a Number if client is Opera. undefined otherwise. Corresponds to
			//		major detected version.
			isOpera: has("opera"),
	
			// isSafari: Number|undefined
			//		Version as a Number if client is Safari or iPhone. undefined otherwise.
			isSafari: has("safari"),
	
			// isChrome: Number|undefined
			//		Version as a Number if client is Chrome browser. undefined otherwise.
			isChrome: has("chrome"),
	
			// isMac: Boolean
			//		True if the client runs on Mac
			isMac: has("mac"),
	
			// isIos: Number|undefined
			//		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
			isIos: has("ios"),
	
			// isAndroid: Number|undefined
			//		Version as a Number if client is android browser. undefined otherwise.
			isAndroid: has("android"),
	
			// isWii: Boolean
			//		True if client is Wii
			isWii: has("wii"),
	
			// isQuirks: Boolean
			//		Page is in quirks mode.
			isQuirks: has("quirks"),
	
			// isAir: Boolean
			//		True if client is Adobe Air
			isAir: has("air")
		});
	
		return has;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has){
	
		// module:
		//		dojo/keys
	
		return dojo.keys = {
			// summary:
			//		Definitions for common key values.  Client code should test keyCode against these named constants,
			//		as the actual codes can vary by browser.
	
			BACKSPACE: 8,
			TAB: 9,
			CLEAR: 12,
			ENTER: 13,
			SHIFT: 16,
			CTRL: 17,
			ALT: 18,
			META: has("webkit") ? 91 : 224,		// the apple key on macs
			PAUSE: 19,
			CAPS_LOCK: 20,
			ESCAPE: 27,
			SPACE: 32,
			PAGE_UP: 33,
			PAGE_DOWN: 34,
			END: 35,
			HOME: 36,
			LEFT_ARROW: 37,
			UP_ARROW: 38,
			RIGHT_ARROW: 39,
			DOWN_ARROW: 40,
			INSERT: 45,
			DELETE: 46,
			HELP: 47,
			LEFT_WINDOW: 91,
			RIGHT_WINDOW: 92,
			SELECT: 93,
			NUMPAD_0: 96,
			NUMPAD_1: 97,
			NUMPAD_2: 98,
			NUMPAD_3: 99,
			NUMPAD_4: 100,
			NUMPAD_5: 101,
			NUMPAD_6: 102,
			NUMPAD_7: 103,
			NUMPAD_8: 104,
			NUMPAD_9: 105,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_PLUS: 107,
			NUMPAD_ENTER: 108,
			NUMPAD_MINUS: 109,
			NUMPAD_PERIOD: 110,
			NUMPAD_DIVIDE: 111,
			F1: 112,
			F2: 113,
			F3: 114,
			F4: 115,
			F5: 116,
			F6: 117,
			F7: 118,
			F8: 119,
			F9: 120,
			F10: 121,
			F11: 122,
			F12: 123,
			F13: 124,
			F14: 125,
			F15: 126,
			NUM_LOCK: 144,
			SCROLL_LOCK: 145,
			UP_DPAD: 175,
			DOWN_DPAD: 176,
			LEFT_DPAD: 177,
			RIGHT_DPAD: 178,
			// virtual key mapping
			copyKey: has("mac") && !has("air") ? (has("safari") ? 91 : 224 ) : 17
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(28), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, array, dom){
		// module:
		//		dojo/dom-class
	
		var className = "className";
	
		/* Part I of classList-based implementation is preserved here for posterity
		var classList = "classList";
		has.add("dom-classList", function(){
			return classList in document.createElement("p");
		});
		*/
	
		// =============================
		// (CSS) Class Functions
		// =============================
	
		var cls, // exports object
			spaces = /\s+/, a1 = [""];
	
		function str2array(s){
			if(typeof s == "string" || s instanceof String){
				if(s && !spaces.test(s)){
					a1[0] = s;
					return a1;
				}
				var a = s.split(spaces);
				if(a.length && !a[0]){
					a.shift();
				}
				if(a.length && !a[a.length - 1]){
					a.pop();
				}
				return a;
			}
			// assumed to be an array
			if(!s){
				return [];
			}
			return array.filter(s, function(x){ return x; });
		}
	
		/* Part II of classList-based implementation is preserved here for posterity
		if(has("dom-classList")){
			// new classList version
			cls = {
				contains: function containsClass(node, classStr){
					var clslst = classStr && dom.byId(node)[classList];
					return clslst && clslst.contains(classStr); // Boolean
				},
	
				add: function addClass(node, classStr){
					node = dom.byId(node);
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length; i < len; ++i){
						node[classList].add(classStr[i]);
					}
				},
	
				remove: function removeClass(node, classStr){
					node = dom.byId(node);
					if(classStr === undefined){
						node[className] = "";
					}else{
						classStr = str2array(classStr);
						for(var i = 0, len = classStr.length; i < len; ++i){
							node[classList].remove(classStr[i]);
						}
					}
				},
	
				replace: function replaceClass(node, addClassStr, removeClassStr){
					node = dom.byId(node);
					if(removeClassStr === undefined){
						node[className] = "";
					}else{
						removeClassStr = str2array(removeClassStr);
						for(var i = 0, len = removeClassStr.length; i < len; ++i){
							node[classList].remove(removeClassStr[i]);
						}
					}
					addClassStr = str2array(addClassStr);
					for(i = 0, len = addClassStr.length; i < len; ++i){
						node[classList].add(addClassStr[i]);
					}
				},
	
				toggle: function toggleClass(node, classStr, condition){
					node = dom.byId(node);
					if(condition === undefined){
						classStr = str2array(classStr);
						for(var i = 0, len = classStr.length; i < len; ++i){
							node[classList].toggle(classStr[i]);
						}
					}else{
						cls[condition ? "add" : "remove"](node, classStr);
					}
					return condition;   // Boolean
				}
			}
		}
		*/
	
		// regular DOM version
		var fakeNode = {};  // for effective replacement
		cls = {
			// summary:
			//		This module defines the core dojo DOM class API.
	
			contains: function containsClass(/*DomNode|String*/ node, /*String*/ classStr){
				// summary:
				//		Returns whether or not the specified classes are a portion of the
				//		class list currently applied to the node.
				// node: String|DOMNode
				//		String ID or DomNode reference to check the class for.
				// classStr: String
				//		A string class name to look for.
				// example:
				//		Do something if a node with id="someNode" has class="aSillyClassName" present
				//	|	if(domClass.contains("someNode","aSillyClassName")){ ... }
	
				return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0); // Boolean
			},
	
			add: function addClass(/*DomNode|String*/ node, /*String|Array*/ classStr){
				// summary:
				//		Adds the specified classes to the end of the class list on the
				//		passed node. Will not re-apply duplicate classes.
				//
				// node: String|DOMNode
				//		String ID or DomNode reference to add a class string too
				//
				// classStr: String|Array
				//		A String class name to add, or several space-separated class names,
				//		or an array of class names.
				//
				// example:
				//		Add a class to some node:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.add("someNode", "anewClass");
				//	|	});
				//
				// example:
				//		Add two classes at once:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.add("someNode", "firstClass secondClass");
				//	|	});
				//
				// example:
				//		Add two classes at once (using array):
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.add("someNode", ["firstClass", "secondClass"]);
				//	|	});
				//
				// example:
				//		Available in `dojo/NodeList` for multiple additions
				//	|	require(["dojo/query"], function(query){
				//	|		query("ul > li").addClass("firstLevel");
				//	|	});
	
				node = dom.byId(node);
				classStr = str2array(classStr);
				var cls = node[className], oldLen;
				cls = cls ? " " + cls + " " : " ";
				oldLen = cls.length;
				for(var i = 0, len = classStr.length, c; i < len; ++i){
					c = classStr[i];
					if(c && cls.indexOf(" " + c + " ") < 0){
						cls += c + " ";
					}
				}
				if(oldLen < cls.length){
					node[className] = cls.substr(1, cls.length - 2);
				}
			},
	
			remove: function removeClass(/*DomNode|String*/ node, /*String|Array?*/ classStr){
				// summary:
				//		Removes the specified classes from node. No `contains()`
				//		check is required.
				//
				// node: String|DOMNode
				//		String ID or DomNode reference to remove the class from.
				//
				// classStr: String|Array
				//		An optional String class name to remove, or several space-separated
				//		class names, or an array of class names. If omitted, all class names
				//		will be deleted.
				//
				// example:
				//		Remove a class from some node:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.remove("someNode", "firstClass");
				//	|	});
				//
				// example:
				//		Remove two classes from some node:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.remove("someNode", "firstClass secondClass");
				//	|	});
				//
				// example:
				//		Remove two classes from some node (using array):
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
				//	|	});
				//
				// example:
				//		Remove all classes from some node:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.remove("someNode");
				//	|	});
				//
				// example:
				//		Available in `dojo/NodeList` for multiple removal
				//	|	require(["dojo/query"], function(query){
				//	|		query("ul > li").removeClass("foo");
				//	|	});
	
				node = dom.byId(node);
				var cls;
				if(classStr !== undefined){
					classStr = str2array(classStr);
					cls = " " + node[className] + " ";
					for(var i = 0, len = classStr.length; i < len; ++i){
						cls = cls.replace(" " + classStr[i] + " ", " ");
					}
					cls = lang.trim(cls);
				}else{
					cls = "";
				}
				if(node[className] != cls){ node[className] = cls; }
			},
	
			replace: function replaceClass(/*DomNode|String*/ node, /*String|Array*/ addClassStr, /*String|Array?*/ removeClassStr){
				// summary:
				//		Replaces one or more classes on a node if not present.
				//		Operates more quickly than calling domClass.remove and domClass.add
				//
				// node: String|DOMNode
				//		String ID or DomNode reference to remove the class from.
				//
				// addClassStr: String|Array
				//		A String class name to add, or several space-separated class names,
				//		or an array of class names.
				//
				// removeClassStr: String|Array?
				//		A String class name to remove, or several space-separated class names,
				//		or an array of class names.
				//
				// example:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
				//	|	});
				//
				// example:
				//	Replace all classes with addMe
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.replace("someNode", "addMe");
				//	|	});
				//
				// example:
				//	Available in `dojo/NodeList` for multiple toggles
				//	|	require(["dojo/query"], function(query){
				//	|		query(".findMe").replaceClass("addMe", "removeMe");
				//	|	});
	
				node = dom.byId(node);
				fakeNode[className] = node[className];
				cls.remove(fakeNode, removeClassStr);
				cls.add(fakeNode, addClassStr);
				if(node[className] !== fakeNode[className]){
					node[className] = fakeNode[className];
				}
			},
	
			toggle: function toggleClass(/*DomNode|String*/ node, /*String|Array*/ classStr, /*Boolean?*/ condition){
				// summary:
				//		Adds a class to node if not present, or removes if present.
				//		Pass a boolean condition if you want to explicitly add or remove.
				//		Returns the condition that was specified directly or indirectly.
				//
				// node: String|DOMNode
				//		String ID or DomNode reference to toggle a class string
				//
				// classStr: String|Array
				//		A String class name to toggle, or several space-separated class names,
				//		or an array of class names.
				//
				// condition:
				//		If passed, true means to add the class, false means to remove.
				//		Otherwise domClass.contains(node, classStr) is used to detect the class presence.
				//
				// example:
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.toggle("someNode", "hovered");
				//	|	});
				//
				// example:
				//		Forcefully add a class
				//	|	require(["dojo/dom-class"], function(domClass){
				//	|		domClass.toggle("someNode", "hovered", true);
				//	|	});
				//
				// example:
				//		Available in `dojo/NodeList` for multiple toggles
				//	|	require(["dojo/query"], function(query){
				//	|		query(".toggleMe").toggleClass("toggleMe");
				//	|	});
	
				node = dom.byId(node);
				if(condition === undefined){
					classStr = str2array(classStr);
					for(var i = 0, len = classStr.length, c; i < len; ++i){
						c = classStr[i];
						cls[cls.contains(node, c) ? "remove" : "add"](node, c);
					}
				}else{
					cls[condition ? "add" : "remove"](node, classStr);
				}
				return condition;   // Boolean
			}
		};
	
		return cls;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has, lang){
		// module:
		//		dojo/_base/array
	
		// our old simple function builder stuff
		var cache = {}, u;
	
		function buildFn(fn){
			return cache[fn] = new Function("item", "index", "array", fn); // Function
		}
		// magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
	
		// every & some
	
		function everyOrSome(some){
			var every = !some;
			return function(a, fn, o){
				var i = 0, l = a && a.length || 0, result;
				if(l && typeof a == "string") a = a.split("");
				if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
				if(o){
					for(; i < l; ++i){
						result = !fn.call(o, a[i], i, a);
						if(some ^ result){
							return !result;
						}
					}
				}else{
					for(; i < l; ++i){
						result = !fn(a[i], i, a);
						if(some ^ result){
							return !result;
						}
					}
				}
				return every; // Boolean
			};
		}
	
		// indexOf, lastIndexOf
	
		function index(up){
			var delta = 1, lOver = 0, uOver = 0;
			if(!up){
				delta = lOver = uOver = -1;
			}
			return function(a, x, from, last){
				if(last && delta > 0){
					// TODO: why do we use a non-standard signature? why do we need "last"?
					return array.lastIndexOf(a, x, from);
				}
				var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
				if(from === u){
					i = up ? lOver : l + uOver;
				}else{
					if(from < 0){
						i = l + from;
						if(i < 0){
							i = lOver;
						}
					}else{
						i = from >= l ? l + uOver : from;
					}
				}
				if(l && typeof a == "string") a = a.split("");
				for(; i != end; i += delta){
					if(a[i] == x){
						return i; // Number
					}
				}
				return -1; // Number
			};
		}
	
		var array = {
			// summary:
			//		The Javascript v1.6 array extensions.
	
			every: everyOrSome(false),
			/*=====
			 every: function(arr, callback, thisObject){
				 // summary:
				 //		Determines whether or not every item in arr satisfies the
				 //		condition implemented by callback.
				 // arr: Array|String
				 //		the array to iterate on. If a string, operates on individual characters.
				 // callback: Function|String
				 //		a function is invoked with three arguments: item, index,
				 //		and array and returns true if the condition is met.
				 // thisObject: Object?
				 //		may be used to scope the call to callback
				 // returns: Boolean
				 // description:
				 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
				 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
				 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
				 //		For more details, see:
				 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
				 // example:
				 //	|	// returns false
				 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
				 // example:
				 //	|	// returns true
				 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
			 },
			 =====*/
	
			some: everyOrSome(true),
			/*=====
			some: function(arr, callback, thisObject){
				// summary:
				//		Determines whether or not any item in arr satisfies the
				//		condition implemented by callback.
				// arr: Array|String
				//		the array to iterate over. If a string, operates on individual characters.
				// callback: Function|String
				//		a function is invoked with three arguments: item, index,
				//		and array and returns true if the condition is met.
				// thisObject: Object?
				//		may be used to scope the call to callback
				// returns: Boolean
				// description:
				//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
				//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
				//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
				//		For more details, see:
				//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
				// example:
				//	| // is true
				//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
				// example:
				//	| // is false
				//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
			},
			=====*/
	
			indexOf: index(true),
			/*=====
			indexOf: function(arr, value, fromIndex, findLast){
				// summary:
				//		locates the first index of the provided value in the
				//		passed array. If the value is not found, -1 is returned.
				// description:
				//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
				//
				//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
				//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
				//		2. uses equality (==) rather than strict equality (===)
				//
				//		For details on this method, see:
				//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
				// arr: Array
				// value: Object
				// fromIndex: Integer?
				// findLast: Boolean?
				//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
				// returns: Number
			},
			=====*/
	
			lastIndexOf: index(false),
			/*=====
			lastIndexOf: function(arr, value, fromIndex){
				// summary:
				//		locates the last index of the provided value in the passed
				//		array. If the value is not found, -1 is returned.
				// description:
			 	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
			 	//
			 	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
			 	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
			 	//		2. uses equality (==) rather than strict equality (===)
			 	//
			 	//		For details on this method, see:
			 	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
				// arr: Array,
				// value: Object,
				// fromIndex: Integer?
				// returns: Number
			},
			=====*/
	
			forEach: function(arr, callback, thisObject){
				// summary:
				//		for every item in arr, callback is invoked. Return values are ignored.
				//		If you want to break out of the loop, consider using array.every() or array.some().
				//		forEach does not allow breaking out of the loop over the items in arr.
				// arr:
				//		the array to iterate over. If a string, operates on individual characters.
				// callback:
				//		a function is invoked with three arguments: item, index, and array
				// thisObject:
				//		may be used to scope the call to callback
				// description:
				//		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
				//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
				//		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
				//		For more details, see:
				//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
				// example:
				//	| // log out all members of the array:
				//	| array.forEach(
				//	|		[ "thinger", "blah", "howdy", 10 ],
				//	|		function(item){
				//	|			console.log(item);
				//	|		}
				//	| );
				// example:
				//	| // log out the members and their indexes
				//	| array.forEach(
				//	|		[ "thinger", "blah", "howdy", 10 ],
				//	|		function(item, idx, arr){
				//	|			console.log(item, "at index:", idx);
				//	|		}
				//	| );
				// example:
				//	| // use a scoped object member as the callback
				//	|
				//	| var obj = {
				//	|		prefix: "logged via obj.callback:",
				//	|		callback: function(item){
				//	|			console.log(this.prefix, item);
				//	|		}
				//	| };
				//	|
				//	| // specifying the scope function executes the callback in that scope
				//	| array.forEach(
				//	|		[ "thinger", "blah", "howdy", 10 ],
				//	|		obj.callback,
				//	|		obj
				//	| );
				//	|
				//	| // alternately, we can accomplish the same thing with lang.hitch()
				//	| array.forEach(
				//	|		[ "thinger", "blah", "howdy", 10 ],
				//	|		lang.hitch(obj, "callback")
				//	| );
				// arr: Array|String
				// callback: Function|String
				// thisObject: Object?
	
				var i = 0, l = arr && arr.length || 0;
				if(l && typeof arr == "string") arr = arr.split("");
				if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
				if(thisObject){
					for(; i < l; ++i){
						callback.call(thisObject, arr[i], i, arr);
					}
				}else{
					for(; i < l; ++i){
						callback(arr[i], i, arr);
					}
				}
			},
	
			map: function(arr, callback, thisObject, Ctr){
				// summary:
				//		applies callback to each element of arr and returns
				//		an Array with the results
				// arr: Array|String
				//		the array to iterate on. If a string, operates on
				//		individual characters.
				// callback: Function|String
				//		a function is invoked with three arguments, (item, index,
				//		array),	 and returns a value
				// thisObject: Object?
				//		may be used to scope the call to callback
				// returns: Array
				// description:
				//		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
				//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
				//		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
				//		For more details, see:
				//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
				// example:
				//	| // returns [2, 3, 4, 5]
				//	| array.map([1, 2, 3, 4], function(item){ return item+1 });
	
				// TODO: why do we have a non-standard signature here? do we need "Ctr"?
				var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
				if(l && typeof arr == "string") arr = arr.split("");
				if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
				if(thisObject){
					for(; i < l; ++i){
						out[i] = callback.call(thisObject, arr[i], i, arr);
					}
				}else{
					for(; i < l; ++i){
						out[i] = callback(arr[i], i, arr);
					}
				}
				return out; // Array
			},
	
			filter: function(arr, callback, thisObject){
				// summary:
				//		Returns a new Array with those items from arr that match the
				//		condition implemented by callback.
				// arr: Array
				//		the array to iterate over.
				// callback: Function|String
				//		a function that is invoked with three arguments (item,
				//		index, array). The return of this function is expected to
				//		be a boolean which determines whether the passed-in item
				//		will be included in the returned array.
				// thisObject: Object?
				//		may be used to scope the call to callback
				// returns: Array
				// description:
				//		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
				//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
				//		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
				//		For more details, see:
				//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
				// example:
				//	| // returns [2, 3, 4]
				//	| array.filter([1, 2, 3, 4], function(item){ return item>1; });
	
				// TODO: do we need "Ctr" here like in map()?
				var i = 0, l = arr && arr.length || 0, out = [], value;
				if(l && typeof arr == "string") arr = arr.split("");
				if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
				if(thisObject){
					for(; i < l; ++i){
						value = arr[i];
						if(callback.call(thisObject, value, i, arr)){
							out.push(value);
						}
					}
				}else{
					for(; i < l; ++i){
						value = arr[i];
						if(callback(value, i, arr)){
							out.push(value);
						}
					}
				}
				return out; // Array
			},
	
			clearCache: function(){
				cache = {};
			}
		};
	
	
		has("extend-dojo") && lang.mixin(dojo, array);
	
		return array;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */
/***/ function(module, exports) {

	// Special module used when condition of dojo/has failed and no failback module specified
	module.exports = undefined;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(13), __webpack_require__(18), __webpack_require__(28), __webpack_require__(8), __webpack_require__(35), __webpack_require__(36)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has, dom, on, array, lang, loader, defaultEngine){
	
		"use strict";
	
		has.add("array-extensible", function(){
			// test to see if we can extend an array (not supported in old IE)
			return lang.delegate([], {length: 1}).length == 1 && !has("bug-for-in-skips-shadowed");
		});
		
		var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;
	
		var tnl = function(/*Array*/ a, /*dojo/NodeList?*/ parent, /*Function?*/ NodeListCtor){
			// summary:
			//		decorate an array to make it look like a `dojo/NodeList`.
			// a:
			//		Array of nodes to decorate.
			// parent:
			//		An optional parent NodeList that generated the current
			//		list of nodes. Used to call _stash() so the parent NodeList
			//		can be accessed via end() later.
			// NodeListCtor:
			//		An optional constructor function to use for any
			//		new NodeList calls. This allows a certain chain of
			//		NodeList calls to use a different object than dojo/NodeList.
			var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
			return parent ? nodeList._stash(parent) : nodeList;
		};
	
		var loopBody = function(f, a, o){
			a = [0].concat(aps.call(a, 0));
			o = o || dojo.global;
			return function(node){
				a[0] = node;
				return f.apply(o, a);
			};
		};
	
		// adapters
	
		var adaptAsForEach = function(f, o){
			// summary:
			//		adapts a single node function to be used in the forEach-type
			//		actions. The initial object is returned from the specialized
			//		function.
			// f: Function
			//		a function to adapt
			// o: Object?
			//		an optional context for f
			return function(){
				this.forEach(loopBody(f, arguments, o));
				return this;	// Object
			};
		};
	
		var adaptAsMap = function(f, o){
			// summary:
			//		adapts a single node function to be used in the map-type
			//		actions. The return is a new array of values, as via `dojo/_base/array.map`
			// f: Function
			//		a function to adapt
			// o: Object?
			//		an optional context for f
			return function(){
				return this.map(loopBody(f, arguments, o));
			};
		};
	
		var adaptAsFilter = function(f, o){
			// summary:
			//		adapts a single node function to be used in the filter-type actions
			// f: Function
			//		a function to adapt
			// o: Object?
			//		an optional context for f
			return function(){
				return this.filter(loopBody(f, arguments, o));
			};
		};
	
		var adaptWithCondition = function(f, g, o){
			// summary:
			//		adapts a single node function to be used in the map-type
			//		actions, behaves like forEach() or map() depending on arguments
			// f: Function
			//		a function to adapt
			// g: Function
			//		a condition function, if true runs as map(), otherwise runs as forEach()
			// o: Object?
			//		an optional context for f and g
			return function(){
				var a = arguments, body = loopBody(f, a, o);
				if(g.call(o || dojo.global, a)){
					return this.map(body);	// self
				}
				this.forEach(body);
				return this;	// self
			};
		};
	
		var NodeList = function(array){
			// summary:
			//		Array-like object which adds syntactic
			//		sugar for chaining, common iteration operations, animation, and
			//		node manipulation. NodeLists are most often returned as the
			//		result of dojo/query() calls.
			// description:
			//		NodeList instances provide many utilities that reflect
			//		core Dojo APIs for Array iteration and manipulation, DOM
			//		manipulation, and event handling. Instead of needing to dig up
			//		functions in the dojo package, NodeLists generally make the
			//		full power of Dojo available for DOM manipulation tasks in a
			//		simple, chainable way.
			// example:
			//		create a node list from a node
			//		|	require(["dojo/query", "dojo/dom"
			//		|	], function(query, dom){
			//		|		query.NodeList(dom.byId("foo"));
			//		|	});
			// example:
			//		get a NodeList from a CSS query and iterate on it
			//		|	require(["dojo/on", "dojo/dom"
			//		|	], function(on, dom){
			//		|		var l = query(".thinger");
			//		|		l.forEach(function(node, index, nodeList){
			//		|			console.log(index, node.innerHTML);
			//		|		});
			//		|	});
			// example:
			//		use native and Dojo-provided array methods to manipulate a
			//		NodeList without needing to use dojo.* functions explicitly:
			//		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
			//		|	], function(query, domConstruct, dom){
			//		|		var l = query(".thinger");
			//		|		// since NodeLists are real arrays, they have a length
			//		|		// property that is both readable and writable and
			//		|		// push/pop/shift/unshift methods
			//		|		console.log(l.length);
			//		|		l.push(domConstruct.create("span"));
			//		|
			//		|		// dojo's normalized array methods work too:
			//		|		console.log( l.indexOf(dom.byId("foo")) );
			//		|		// ...including the special "function as string" shorthand
			//		|		console.log( l.every("item.nodeType == 1") );
			//		|
			//		|		// NodeLists can be [..] indexed, or you can use the at()
			//		|		// function to get specific items wrapped in a new NodeList:
			//		|		var node = l[3]; // the 4th element
			//		|		var newList = l.at(1, 3); // the 2nd and 4th elements
			//		|	});
			// example:
			//		chainability is a key advantage of NodeLists:
			//		|	require(["dojo/query", "dojo/NodeList-dom"
			//		|	], function(query){
			//		|		query(".thinger")
			//		|			.onclick(function(e){ /* ... */ })
			//		|			.at(1, 3, 8) // get a subset
			//		|				.style("padding", "5px")
			//		|				.forEach(console.log);
			//		|	});
	
			var isNew = this instanceof nl && has("array-extensible");
			if(typeof array == "number"){
				array = Array(array);
			}
			var nodeArray = (array && "length" in array) ? array : arguments;
			if(isNew || !nodeArray.sort){
				// make sure it's a real array before we pass it on to be wrapped 
				var target = isNew ? this : [],
					l = target.length = nodeArray.length;
				for(var i = 0; i < l; i++){
					target[i] = nodeArray[i];
				}
				if(isNew){
					// called with new operator, this means we are going to use this instance and push
					// the nodes on to it. This is usually much faster since the NodeList properties
					//	don't need to be copied (unless the list of nodes is extremely large).
					return target;
				}
				nodeArray = target;
			}
			// called without new operator, use a real array and copy prototype properties,
			// this is slower and exists for back-compat. Should be removed in 2.0.
			lang._mixin(nodeArray, nlp);
			nodeArray._NodeListCtor = function(array){
				// call without new operator to preserve back-compat behavior
				return nl(array);
			};
			return nodeArray;
		};
		
		var nl = NodeList, nlp = nl.prototype = 
			has("array-extensible") ? [] : {};// extend an array if it is extensible
	
		// expose adapters and the wrapper as private functions
	
		nl._wrap = nlp._wrap = tnl;
		nl._adaptAsMap = adaptAsMap;
		nl._adaptAsForEach = adaptAsForEach;
		nl._adaptAsFilter  = adaptAsFilter;
		nl._adaptWithCondition = adaptWithCondition;
	
		// mass assignment
	
		// add array redirectors
		forEach(["slice", "splice"], function(name){
			var f = ap[name];
			//Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
			// CANNOT apply ._stash()/end() to splice since it currently modifies
			// the existing this array -- it would break backward compatibility if we copy the array before
			// the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
			nlp[name] = function(){ return this._wrap(f.apply(this, arguments), name == "slice" ? this : null); };
		});
		// concat should be here but some browsers with native NodeList have problems with it
	
		// add array.js redirectors
		forEach(["indexOf", "lastIndexOf", "every", "some"], function(name){
			var f = array[name];
			nlp[name] = function(){ return f.apply(dojo, [this].concat(aps.call(arguments, 0))); };
		});
	
		lang.extend(NodeList, {
			// copy the constructors
			constructor: nl,
			_NodeListCtor: nl,
			toString: function(){
				// Array.prototype.toString can't be applied to objects, so we use join
				return this.join(",");
			},
			_stash: function(parent){
				// summary:
				//		private function to hold to a parent NodeList. end() to return the parent NodeList.
				//
				// example:
				//		How to make a `dojo/NodeList` method that only returns the third node in
				//		the dojo/NodeList but allows access to the original NodeList by using this._stash:
				//	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
				//	|	], function(query, lang){
				//	|		lang.extend(NodeList, {
				//	|			third: function(){
				//	|				var newNodeList = NodeList(this[2]);
				//	|				return newNodeList._stash(this);
				//	|			}
				//	|		});
				//	|		// then see how _stash applies a sub-list, to be .end()'ed out of
				//	|		query(".foo")
				//	|			.third()
				//	|				.addClass("thirdFoo")
				//	|			.end()
				//	|			// access to the orig .foo list
				//	|			.removeClass("foo")
				//	|	});
				//
				this._parent = parent;
				return this; // dojo/NodeList
			},
	
			on: function(eventName, listener){
				// summary:
				//		Listen for events on the nodes in the NodeList. Basic usage is:
				//
				// example:
				//		|	require(["dojo/query"
				//		|	], function(query){
				//		|		query(".my-class").on("click", listener);
				//			This supports event delegation by using selectors as the first argument with the event names as
				//			pseudo selectors. For example:
				//		| 		query("#my-list").on("li:click", listener);
				//			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
				//			Because on supports CSS selector syntax, we can use comma-delimited events as well:
				//		| 		query("#my-list").on("li button:mouseover, li:click", listener);
				//		|	});
				var handles = this.map(function(node){
					return on(node, eventName, listener); // TODO: apply to the NodeList so the same selector engine is used for matches
				});
				handles.remove = function(){
					for(var i = 0; i < handles.length; i++){
						handles[i].remove();
					}
				};
				return handles;
			},
	
			end: function(){
				// summary:
				//		Ends use of the current `NodeList` by returning the previous NodeList
				//		that generated the current NodeList.
				// description:
				//		Returns the `NodeList` that generated the current `NodeList`. If there
				//		is no parent NodeList, an empty NodeList is returned.
				// example:
				//	|	require(["dojo/query", "dojo/NodeList-dom"
				//	|	], function(query){
				//	|		query("a")
				//	|			.filter(".disabled")
				//	|				// operate on the anchors that only have a disabled class
				//	|				.style("color", "grey")
				//	|			.end()
				//	|			// jump back to the list of anchors
				//	|			.style(...)
				//	|	});
				//
				if(this._parent){
					return this._parent;
				}else{
					//Just return empty list.
					return new this._NodeListCtor(0);
				}
			},
	
			// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods
	
			// FIXME: handle return values for #3244
			//		http://trac.dojotoolkit.org/ticket/3244
	
			// FIXME:
			//		need to wrap or implement:
			//			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
			//			reduce
			//			reduceRight
	
			/*=====
			slice: function(begin, end){
				// summary:
				//		Returns a new NodeList, maintaining this one in place
				// description:
				//		This method behaves exactly like the Array.slice method
				//		with the caveat that it returns a `dojo/NodeList` and not a
				//		raw Array. For more details, see Mozilla's [slice
				//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
				// begin: Integer
				//		Can be a positive or negative integer, with positive
				//		integers noting the offset to begin at, and negative
				//		integers denoting an offset from the end (i.e., to the left
				//		of the end)
				// end: Integer?
				//		Optional parameter to describe what position relative to
				//		the NodeList's zero index to end the slice at. Like begin,
				//		can be positive or negative.
				return this._wrap(a.slice.apply(this, arguments));
			},
	
			splice: function(index, howmany, item){
				// summary:
				//		Returns a new NodeList, manipulating this NodeList based on
				//		the arguments passed, potentially splicing in new elements
				//		at an offset, optionally deleting elements
				// description:
				//		This method behaves exactly like the Array.splice method
				//		with the caveat that it returns a `dojo/NodeList` and not a
				//		raw Array. For more details, see Mozilla's [splice
				//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
				//		For backwards compatibility, calling .end() on the spliced NodeList
				//		does not return the original NodeList -- splice alters the NodeList in place.
				// index: Integer
				//		begin can be a positive or negative integer, with positive
				//		integers noting the offset to begin at, and negative
				//		integers denoting an offset from the end (i.e., to the left
				//		of the end)
				// howmany: Integer?
				//		Optional parameter to describe what position relative to
				//		the NodeList's zero index to end the slice at. Like begin,
				//		can be positive or negative.
				// item: Object...?
				//		Any number of optional parameters may be passed in to be
				//		spliced into the NodeList
				return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
			},
	
			indexOf: function(value, fromIndex){
				// summary:
				//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
				//		array is implicitly this NodeList
				// value: Object
				//		The value to search for.
				// fromIndex: Integer?
				//		The location to start searching from. Optional. Defaults to 0.
				// description:
				//		For more details on the behavior of indexOf, see Mozilla's
				//		[indexOf
				//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
				// returns:
				//		Positive Integer or 0 for a match, -1 of not found.
				return d.indexOf(this, value, fromIndex); // Integer
			},
	
			lastIndexOf: function(value, fromIndex){
				// summary:
				//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
				//		acted-on array is implicitly this NodeList
				// description:
				//		For more details on the behavior of lastIndexOf, see
				//		Mozilla's [lastIndexOf
				//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
				// value: Object
				//		The value to search for.
				// fromIndex: Integer?
				//		The location to start searching from. Optional. Defaults to 0.
				// returns:
				//		Positive Integer or 0 for a match, -1 of not found.
				return d.lastIndexOf(this, value, fromIndex); // Integer
			},
	
			every: function(callback, thisObject){
				// summary:
				//		see `dojo/_base/array.every()` and the [Array.every
				//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
				//		Takes the same structure of arguments and returns as
				//		dojo/_base/array.every() with the caveat that the passed array is
				//		implicitly this NodeList
				// callback: Function
				//		the callback
				// thisObject: Object?
				//		the context
				return d.every(this, callback, thisObject); // Boolean
			},
	
			some: function(callback, thisObject){
				// summary:
				//		Takes the same structure of arguments and returns as
				//		`dojo/_base/array.some()` with the caveat that the passed array is
				//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
				//		[Array.some
				//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
				// callback: Function
				//		the callback
				// thisObject: Object?
				//		the context
				return d.some(this, callback, thisObject); // Boolean
			},
			=====*/
	
			concat: function(item){
				// summary:
				//		Returns a new NodeList comprised of items in this NodeList
				//		as well as items passed in as parameters
				// description:
				//		This method behaves exactly like the Array.concat method
				//		with the caveat that it returns a `NodeList` and not a
				//		raw Array. For more details, see the [Array.concat
				//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
				// item: Object?
				//		Any number of optional parameters may be passed in to be
				//		spliced into the NodeList
	
				//return this._wrap(apc.apply(this, arguments));
				// the line above won't work for the native NodeList, or for Dojo NodeLists either :-(
	
				// implementation notes:
				// Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
				// as arrays, and so does not inline them into a unioned array, but
				// appends them as single entities. Both the original NodeList and the
				// items passed in as parameters must be converted to raw Arrays
				// and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.
	
				var t = aps.call(this, 0),
					m = array.map(arguments, function(a){
						return aps.call(a, 0);
					});
				return this._wrap(apc.apply(t, m), this);	// dojo/NodeList
			},
	
			map: function(/*Function*/ func, /*Function?*/ obj){
				// summary:
				//		see `dojo/_base/array.map()`. The primary difference is that the acted-on
				//		array is implicitly this NodeList and the return is a
				//		NodeList (a subclass of Array)
				return this._wrap(array.map(this, func, obj), this); // dojo/NodeList
			},
	
			forEach: function(callback, thisObj){
				// summary:
				//		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
				//		array is implicitly this NodeList. If you want the option to break out
				//		of the forEach loop, use every() or some() instead.
				forEach(this, callback, thisObj);
				// non-standard return to allow easier chaining
				return this; // dojo/NodeList
			},
			filter: function(/*String|Function*/ filter){
				// summary:
				//		"masks" the built-in javascript filter() method (supported
				//		in Dojo via `dojo/_base/array.filter`) to support passing a simple
				//		string filter in addition to supporting filtering function
				//		objects.
				// filter:
				//		If a string, a CSS rule like ".thinger" or "div > span".
				// example:
				//		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
				//		|	require(["dojo/query", "dojo/NodeList-dom"
				//		|	], function(query){
				//		|		query("*").filter(function(item){
				//		|			// highlight every paragraph
				//		|			return (item.nodeName == "p");
				//		|		}).style("backgroundColor", "yellow");
				//		|	});
				// example:
				//		the same filtering using a CSS selector
				//		|	require(["dojo/query", "dojo/NodeList-dom"
				//		|	], function(query){
				//		|		query("*").filter("p").styles("backgroundColor", "yellow");
				//		|	});
	
				var a = arguments, items = this, start = 0;
				if(typeof filter == "string"){ // inline'd type check
					items = query._filterResult(this, a[0]);
					if(a.length == 1){
						// if we only got a string query, pass back the filtered results
						return items._stash(this); // dojo/NodeList
					}
					// if we got a callback, run it over the filtered items
					start = 1;
				}
				return this._wrap(array.filter(items, a[start], a[start + 1]), this);	// dojo/NodeList
			},
			instantiate: function(/*String|Object*/ declaredClass, /*Object?*/ properties){
				// summary:
				//		Create a new instance of a specified class, using the
				//		specified properties and each node in the NodeList as a
				//		srcNodeRef.
				// example:
				//		Grabs all buttons in the page and converts them to dijit/form/Button's.
				//	|	var buttons = query("button").instantiate(Button, {showLabel: true});
				var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
				properties = properties || {};
				return this.forEach(function(node){
					new c(properties, node);
				});	// dojo/NodeList
			},
			at: function(/*===== index =====*/){
				// summary:
				//		Returns a new NodeList comprised of items in this NodeList
				//		at the given index or indices.
				//
				// index: Integer...
				//		One or more 0-based indices of items in the current
				//		NodeList. A negative index will start at the end of the
				//		list and go backwards.
				//
				// example:
				//	Shorten the list to the first, second, and third elements
				//	|	require(["dojo/query"
				//	|	], function(query){
				//	|		query("a").at(0, 1, 2).forEach(fn);
				//	|	});
				//
				// example:
				//	Retrieve the first and last elements of a unordered list:
				//	|	require(["dojo/query"
				//	|	], function(query){
				//	|		query("ul > li").at(0, -1).forEach(cb);
				//	|	});
				//
				// example:
				//	Do something for the first element only, but end() out back to
				//	the original list and continue chaining:
				//	|	require(["dojo/query"
				//	|	], function(query){
				//	|		query("a").at(0).onclick(fn).end().forEach(function(n){
				//	|			console.log(n); // all anchors on the page.
				//	|	})
				//	|	});
	
				var t = new this._NodeListCtor(0);
				forEach(arguments, function(i){
					if(i < 0){ i = this.length + i; }
					if(this[i]){ t.push(this[i]); }
				}, this);
				return t._stash(this); // dojo/NodeList
			}
		});
	
		function queryForEngine(engine, NodeList){
			var query = function(/*String*/ query, /*String|DOMNode?*/ root){
				// summary:
				//		Returns nodes which match the given CSS selector, searching the
				//		entire document by default but optionally taking a node to scope
				//		the search by. Returns an instance of NodeList.
				if(typeof root == "string"){
					root = dom.byId(root);
					if(!root){
						return new NodeList([]);
					}
				}
				var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
				if(results.end && results.on){
					// already wrapped
					return results;
				}
				return new NodeList(results);
			};
			query.matches = engine.match || function(node, selector, root){
				// summary:
				//		Test to see if a node matches a selector
				return query.filter([node], selector, root).length > 0;
			};
			// the engine provides a filtering function, use it to for matching
			query.filter = engine.filter || function(nodes, selector, root){
				// summary:
				//		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
				return query(selector, root).filter(function(node){
					return array.indexOf(nodes, node) > -1;
				});
			};
			if(typeof engine != "function"){
				var search = engine.search;
				engine = function(selector, root){
					// Slick does it backwards (or everyone else does it backwards, probably the latter)
					return search(root || document, selector);
				};
			}
			return query;
		}
		var query = queryForEngine(defaultEngine, NodeList);
		/*=====
		query = function(selector, context){
			// summary:
			//		This modules provides DOM querying functionality. The module export is a function
			//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
			//		representing the matching nodes.
			// selector: String
			//		A CSS selector to search for.
			// context: String|DomNode?
			//		An optional context to limit the searching scope. Only nodes under `context` will be
			//		scanned.
			// example:
			//		add an onclick handler to every submit button in the document
			//		which causes the form to be sent via Ajax instead:
			//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
			//	|	], function(query, request, domForm, domConstruct, domStyle){
			//	|		query("input[type='submit']").on("click", function(e){
			//	|			e.preventDefault(); // prevent sending the form
			//	|			var btn = e.target;
			//	|			request.post("http://example.com/", {
			//	|				data: domForm.toObject(btn.form)
			//	|			}).then(function(response){
			//	|				// replace the form with the response
			//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
			//	|				domStyle.set(btn.form, "display", "none");
			//	|			});
			//	|		});
			//	|	});
			//
			// description:
			//		dojo/query is responsible for loading the appropriate query engine and wrapping
			//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
			//		by using it as a plugin. For example, if you installed the sizzle package, you could
			//		use it as the selector engine with:
			//		|	require(["dojo/query!sizzle"], function(query){
			//		|		query("div")...
			//
			//		The id after the ! can be a module id of the selector engine or one of the following values:
			//
			//		- acme: This is the default engine used by Dojo base, and will ensure that the full
			//		Acme engine is always loaded.
			//
			//		- css2: If the browser has a native selector engine, this will be used, otherwise a
			//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
			//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
			//		operators) and nothing more.
			//
			//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
			//		full Acme engine will be loaded.
			//
			//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
			//		selectors (most modern browsers except IE8), this will be used, otherwise the
			//		full Acme engine will be loaded.
			//
			//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
			//
			//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
			//		you will need support them with:
			//		|	require(["dojo/query!css3"], function(query){
			//		|		query('#t > h3:nth-child(odd)')...
			//
			//		You can also choose the selector engine/load configuration by setting the query-selector:
			//		For example:
			//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
			//
			return new NodeList(); // dojo/NodeList
		 };
		 =====*/
	
		// the query that is returned from this module is slightly different than dojo.query,
		// because dojo.query has to maintain backwards compatibility with returning a
		// true array which has performance problems. The query returned from the module
		// does not use true arrays, but rather inherits from Array, making it much faster to
		// instantiate.
		dojo.query = queryForEngine(defaultEngine, function(array){
			// call it without the new operator to invoke the back-compat behavior that returns a true array
			return NodeList(array);	// dojo/NodeList
		});
	
		query.load = function(id, parentRequire, loaded){
			// summary:
			//		can be used as AMD plugin to conditionally load new query engine
			// example:
			//	|	require(["dojo/query!custom"], function(qsa){
			//	|		// loaded selector/custom.js as engine
			//	|		qsa("#foobar").forEach(...);
			//	|	});
			loader.load(id, parentRequire, function(engine){
				loaded(queryForEngine(engine, NodeList));
			});
		};
	
		dojo._filterQueryResult = query._filterResult = function(nodes, selector, root){
			return new NodeList(query.filter(nodes, selector, root));
		};
		dojo.NodeList = query.NodeList = NodeList;
		return query;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, require){
	
	"use strict";
	var testDiv = document.createElement("div");
	has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
	has.add("dom-qsa3", function(){
				// test to see if we have a reasonable native selector engine available
				try{
					testDiv.innerHTML = "<p class='TEST'></p>"; // test kind of from sizzle
					// Safari can't handle uppercase or unicode characters when
					// in quirks mode, IE8 can't handle pseudos like :empty
					return testDiv.querySelectorAll(".TEST:empty").length == 1;
				}catch(e){}
			});
	var fullEngine;
	var acme = "./acme", lite = "./lite";
	return {
		// summary:
		//		This module handles loading the appropriate selector engine for the given browser
	
		load: function(id, parentRequire, loaded, config){
			var req = require;
			// here we implement the default logic for choosing a selector engine
			id = id == "default" ? has("config-selectorEngine") || "css3" : id;
			id = id == "css2" || id == "lite" ? lite :
					id == "css2.1" ? has("dom-qsa2.1") ? lite : acme :
					id == "css3" ? has("dom-qsa3") ? lite : acme :
					id == "acme" ? acme : (req = parentRequire) && id;
			if(id.charAt(id.length-1) == '?'){
				id = id.substring(0,id.length - 1);
				var optionalLoad = true;
			}
			// the query engine is optional, only load it if a native one is not available or existing one has not been loaded
			if(optionalLoad && (has("dom-compliant-qsa") || fullEngine)){
				return loaded(fullEngine);
			}
			// load the referenced selector engine
			req([id], function(engine){
				if(id != "./lite"){
					fullEngine = engine;
				}
				loaded(engine);
			});
		}
	};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, dojo){
	"use strict";
	
	var testDiv = document.createElement("div");
	var matchesSelector = testDiv.matches || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
	var querySelectorAll = testDiv.querySelectorAll;
	var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
	has.add("dom-matches-selector", !!matchesSelector);
	has.add("dom-qsa", !!querySelectorAll); 
	
	// this is a simple query engine. It has handles basic selectors, and for simple
	// common selectors is extremely fast
	var liteEngine = function(selector, root){
		// summary:
		//		A small lightweight query selector engine that implements CSS2.1 selectors
		//		minus pseudo-classes and the sibling combinator, plus CSS3 attribute selectors
	
		if(combine && selector.indexOf(',') > -1){
			return combine(selector, root);
		}
		// use the root's ownerDocument if provided, otherwise try to use dojo.doc. Note 
		// that we don't use dojo/_base/window's doc to reduce dependencies, and 
		// fallback to plain document if dojo.doc hasn't been defined (by dojo/_base/window).
		// presumably we will have a better way to do this in 2.0 
		var doc = root ? root.ownerDocument || root : dojo.doc || document, 
			match = (querySelectorAll ? 
				/^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : // this one only matches on simple queries where we can beat qSA with specific methods
				/^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/) // this one matches parts of the query that we can use to speed up manual filtering
				.exec(selector);
		root = root || doc;
		if(match){
			var isInsideDomTree = has('ie') === 8 && has('quirks')?
				root.nodeType === doc.nodeType:
				root.parentNode !== null && root.nodeType !== 9 && root.parentNode === doc;
	
			// fast path regardless of whether or not querySelectorAll exists
			if(match[2] && isInsideDomTree){
				// an #id
				// use dojo.byId if available as it fixes the id retrieval in IE, note that we can't use the dojo namespace in 2.0, but if there is a conditional module use, we will use that
				var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
				if(!found || (match[1] && match[1] != found.tagName.toLowerCase())){
					// if there is a tag qualifer and it doesn't match, no matches
					return [];
				}
				if(root != doc){
					// there is a root element, make sure we are a child of it
					var parent = found;
					while(parent != root){
						parent = parent.parentNode;
						if(!parent){
							return [];
						}
					}
				}
				return match[3] ?
						liteEngine(match[3], found) 
						: [found];
			}
			if(match[3] && root.getElementsByClassName){
				// a .class
				return root.getElementsByClassName(match[4]);
			}
			var found;
			if(match[5]){
				// a tag
				found = root.getElementsByTagName(match[5]);
				if(match[4] || match[6]){
					selector = (match[4] || "") + match[6];
				}else{
					// that was the entirety of the query, return results
					return found;
				}
			}
		}
		if(querySelectorAll){
			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object"){				
				return useRoot(root, selector, root.querySelectorAll);
			}else{
				// we can use the native qSA
				return root.querySelectorAll(selector);
			}
		}else if(!found){
			// search all children and then filter
			found = root.getElementsByTagName("*");
		}
		// now we filter the nodes that were found using the matchesSelector
		var results = [];
		for(var i = 0, l = found.length; i < l; i++){
			var node = found[i];
			if(node.nodeType == 1 && jsMatchesSelector(node, selector, root)){
				// keep the nodes that match the selector
				results.push(node);
			}
		}
		return results;
	};
	var useRoot = function(context, query, method){
		// this function creates a temporary id so we can do rooted qSA queries, this is taken from sizzle
		var oldContext = context,
			old = context.getAttribute("id"),
			nid = old || "__dojo__",
			hasParent = context.parentNode,
			relativeHierarchySelector = /^\s*[+~]/.test(query);
	
		if(relativeHierarchySelector && !hasParent){
			return [];
		}
		if(!old){
			context.setAttribute("id", nid);
		}else{
			nid = nid.replace(/'/g, "\\$&");
		}
		if(relativeHierarchySelector && hasParent){
			context = context.parentNode;
		}
		var selectors = query.match(unionSplit);
		for(var i = 0; i < selectors.length; i++){
			selectors[i] = "[id='" + nid + "'] " + selectors[i];
		}
		query = selectors.join(",");
	
		try{
			return method.call(context, query);
		}finally{
			if(!old){
				oldContext.removeAttribute("id");
			}
		}
	};
	
	if(!has("dom-matches-selector")){
		var jsMatchesSelector = (function(){
			// a JS implementation of CSS selector matching, first we start with the various handlers
			var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
			var selectorTypes = {
				"": function(tagName){
					tagName = tagName[caseFix]();
					return function(node){
						return node.tagName == tagName;
					};
				},
				".": function(className){
					var classNameSpaced = ' ' + className + ' ';
					return function(node){
						return node.className.indexOf(className) > -1 && (' ' + node.className + ' ').indexOf(classNameSpaced) > -1;
					};
				},
				"#": function(id){
					return function(node){
						return node.id == id;
					};
				}
			};
			var attrComparators = {
				"^=": function(attrValue, value){
					return attrValue.indexOf(value) == 0;
				},
				"*=": function(attrValue, value){
					return attrValue.indexOf(value) > -1;
				},
				"$=": function(attrValue, value){
					return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
				},
				"~=": function(attrValue, value){
					return (' ' + attrValue + ' ').indexOf(' ' + value + ' ') > -1;
				},
				"|=": function(attrValue, value){
					return (attrValue + '-').indexOf(value + '-') == 0;
				},
				"=": function(attrValue, value){
					return attrValue == value;
				},
				"": function(attrValue, value){
					return true;
				}
			};
			function attr(name, value, type){
				var firstChar = value.charAt(0);
				if(firstChar == '"' || firstChar == "'"){
					// it is quoted, remove the quotes
					value = value.slice(1, -1);
				}
				value = value.replace(/\\/g,'');
				var comparator = attrComparators[type || ""];
				return function(node){
					var attrValue = node.getAttribute(name);
					return attrValue && comparator(attrValue, value);
				};
			}
			function ancestor(matcher){
				return function(node, root){
					while((node = node.parentNode) != root){
						if(matcher(node, root)){
							return true;
						}
					}
				};
			}
			function parent(matcher){
				return function(node, root){
					node = node.parentNode;
					return matcher ? 
						node != root && matcher(node, root)
						: node == root;
				};
			}
			var cache = {};
			function and(matcher, next){
				return matcher ?
					function(node, root){
						return next(node) && matcher(node, root);
					}
					: next;
			}
			return function(node, selector, root){
				// this returns true or false based on if the node matches the selector (optionally within the given root)
				var matcher = cache[selector]; // check to see if we have created a matcher function for the given selector
				if(!matcher){
					// create a matcher function for the given selector
					// parse the selectors
					if(selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function(t, combinator, type, value, attrName, attrType, attrValue){
						if(value){
							matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, '')));
						}
						else if(combinator){
							matcher = (combinator == " " ? ancestor : parent)(matcher);
						}
						else if(attrName){
							matcher = and(matcher, attr(attrName, attrValue, attrType));
						}
						return "";
					})){
						throw new Error("Syntax error in query");
					}
					if(!matcher){
						return true;
					}
					cache[selector] = matcher;
				}
				// now run the matcher function on the node
				return matcher(node, root);
			};
		})();
	}
	if(!has("dom-qsa")){
		var combine = function(selector, root){
			// combined queries
			var selectors = selector.match(unionSplit);
			var indexed = [];
			// add all results and keep unique ones, this only runs in IE, so we take advantage 
			// of known IE features, particularly sourceIndex which is unique and allows us to 
			// order the results 
			for(var i = 0; i < selectors.length; i++){
				selector = new String(selectors[i].replace(/\s*$/,''));
				selector.indexOf = escape; // keep it from recursively entering combine
				var results = liteEngine(selector, root);
				for(var j = 0, l = results.length; j < l; j++){
					var node = results[j];
					indexed[node.sourceIndex] = node;
				}
			}
			// now convert from a sparse array to a dense array
			var totalResults = [];
			for(i in indexed){
				totalResults.push(indexed[i]);
			}
			return totalResults;
		};
	}
	
	liteEngine.match = matchesSelector ? function(node, selector, root){
		if(root && root.nodeType != 9){
			// doesn't support three args, use rooted id trick
			return useRoot(root, selector, function(query){
				return matchesSelector.call(node, query);
			});
		}
		// we have a native matchesSelector, use that
		return matchesSelector.call(node, selector);
	} : jsMatchesSelector; // otherwise use the JS matches impl
	
	return liteEngine;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 37 */,
/* 38 */,
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(40)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(request/*=====, declare, Promise =====*/){
		/*=====
		request = function(url, options){
			// summary:
			//		Send a request using the default transport for the current platform.
			// url: String
			//		The URL to request.
			// options: dojo/request.__Options?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		request.__Promise = declare(Promise, {
			// response: dojo/promise/Promise
			//		A promise resolving to an object representing
			//		the response from the server.
		});
		request.__BaseOptions = declare(null, {
			// query: String|Object?
			//		Query parameters to append to the URL.
			// data: String|Object?
			//		Data to transfer.  This is ignored for GET and DELETE
			//		requests.
			// preventCache: Boolean?
			//		Whether to append a cache-busting parameter to the URL.
			// timeout: Integer?
			//		Milliseconds to wait for the response.  If this time
			//		passes, the then the promise is rejected.
			// handleAs: String?
			//		How to handle the response from the server.  Default is
			//		'text'.  Other values are 'json', 'javascript', and 'xml'.
		});
		request.__MethodOptions = declare(null, {
			// method: String?
			//		The HTTP method to use to make the request.  Must be
			//		uppercase.
		});
		request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);
	
		request.get = function(url, options){
			// summary:
			//		Send an HTTP GET request using the default transport for the current platform.
			// url: String
			//		URL to request
			// options: dojo/request.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		request.post = function(url, options){
			// summary:
			//		Send an HTTP POST request using the default transport for the current platform.
			// url: String
			//		URL to request
			// options: dojo/request.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		request.put = function(url, options){
			// summary:
			//		Send an HTTP POST request using the default transport for the current platform.
			// url: String
			//		URL to request
			// options: dojo/request.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		request.del = function(url, options){
			// summary:
			//		Send an HTTP DELETE request using the default transport for the current platform.
			// url: String
			//		URL to request
			// options: dojo/request.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		=====*/
		return request;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(41),
		__webpack_require__(43),
		__webpack_require__(50),
		__webpack_require__(44),
		__webpack_require__(4)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(RequestError, watch, handlers, util, has/*=====, request, declare =====*/){
		has.add('native-xhr', function(){
			// if true, the environment has a native XHR implementation
			return typeof XMLHttpRequest !== 'undefined';
		});
		has.add('dojo-force-activex-xhr', function(){
			return has('activex') && window.location.protocol === 'file:';
		});
	
		has.add('native-xhr2', function(){
			if(!has('native-xhr') || has('dojo-force-activex-xhr')){ return; }
			var x = new XMLHttpRequest();
			return typeof x['addEventListener'] !== 'undefined' &&
				(typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
		});
	
		has.add('native-formdata', function(){
			// if true, the environment has a native FormData implementation
			return typeof FormData !== 'undefined';
		});
	
		has.add('native-response-type', function(){
			return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
		});
	
		has.add('native-xhr2-blob', function(){
			if(!has('native-response-type')){ return; }
			var x = new XMLHttpRequest();
			x.open('GET', '/', true);
			x.responseType = 'blob';
			// will not be set if unsupported
			var responseType = x.responseType;
			x.abort();
			return responseType === 'blob';
		});
	
		// Google Chrome doesn't support "json" response type
		// up to version 30, so it's intentionally not included here
		var nativeResponseTypes = {
			'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
			'document': 'document',
			'arraybuffer': 'arraybuffer'
		};
	
		function handleResponse(response, error){
			var _xhr = response.xhr;
			response.status = response.xhr.status;
	
			try {
				// Firefox throws an error when trying to access
				// xhr.responseText if response isn't text
				response.text = _xhr.responseText;
			} catch (e) {}
	
			if(response.options.handleAs === 'xml'){
				response.data = _xhr.responseXML;
			}
	
			if(!error){
				try{
					handlers(response);
				}catch(e){
					error = e;
				}
			}
			var handleError;
			if(error){
				this.reject(error);
			}else{
				try{
					handlers(response);
				}catch(e){
					handleError = e;
				}
				if(util.checkStatus(_xhr.status)){
					if(!handleError){
						this.resolve(response);
					}else{
						this.reject(handleError);
					}
				}else{
					if(!handleError){
						error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
						this.reject(error);
					}else{
						error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status +
							' and an error in handleAs: transformation of response', response);
	    				this.reject(error);
					}
				}
			}
		}
	
		var isValid, isReady, addListeners, cancel;
		if(has('native-xhr2')){
			// Any platform with XHR2 will only use the watch mechanism for timeout.
	
			isValid = function(response){
				// summary:
				//		Check to see if the request should be taken out of the watch queue
				return !this.isFulfilled();
			};
			cancel = function(dfd, response){
				// summary:
				//		Canceler for deferred
				response.xhr.abort();
			};
			addListeners = function(_xhr, dfd, response){
				// summary:
				//		Adds event listeners to the XMLHttpRequest object
				function onLoad(evt){
					dfd.handleResponse(response);
				}
				function onError(evt){
					var _xhr = evt.target;
					var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
					dfd.handleResponse(response, error);
				}
	
				function onProgress(evt){
					if(evt.lengthComputable){
						response.loaded = evt.loaded;
						response.total = evt.total;
						dfd.progress(response);
					} else if(response.xhr.readyState === 3){
						response.loaded = ('loaded' in evt) ? evt.loaded : evt.position;
						dfd.progress(response);
					}
				}
	
				_xhr.addEventListener('load', onLoad, false);
				_xhr.addEventListener('error', onError, false);
				_xhr.addEventListener('progress', onProgress, false);
	
				return function(){
					_xhr.removeEventListener('load', onLoad, false);
					_xhr.removeEventListener('error', onError, false);
					_xhr.removeEventListener('progress', onProgress, false);
					_xhr = null;
				};
			};
		}else{
			isValid = function(response){
				return response.xhr.readyState; //boolean
			};
			isReady = function(response){
				return 4 === response.xhr.readyState; //boolean
			};
			cancel = function(dfd, response){
				// summary:
				//		canceller function for util.deferred call.
				var xhr = response.xhr;
				var _at = typeof xhr.abort;
				if(_at === 'function' || _at === 'object' || _at === 'unknown'){
					xhr.abort();
				}
			};
		}
	
		function getHeader(headerName){
			return this.xhr.getResponseHeader(headerName);
		}
	
		var undefined,
			defaultOptions = {
				data: null,
				query: null,
				sync: false,
				method: 'GET'
			};
		function xhr(url, options, returnDeferred){
			var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
			var response = util.parseArgs(
				url,
				util.deepCreate(defaultOptions, options),
				isFormData
			);
			url = response.url;
			options = response.options;
	
			var remover,
				last = function(){
					remover && remover();
				};
	
			//Make the Deferred object for this xhr request.
			var dfd = util.deferred(
				response,
				cancel,
				isValid,
				isReady,
				handleResponse,
				last
			);
			var _xhr = response.xhr = xhr._create();
	
			if(!_xhr){
				// If XHR factory somehow returns nothings,
				// cancel the deferred.
				dfd.cancel(new RequestError('XHR was not created'));
				return returnDeferred ? dfd : dfd.promise;
			}
	
			response.getHeader = getHeader;
	
			if(addListeners){
				remover = addListeners(_xhr, dfd, response);
			}
	
			var data = options.data,
				async = !options.sync,
				method = options.method;
	
			try{
				// IE6 won't let you call apply() on the native function.
				_xhr.open(method, url, async, options.user || undefined, options.password || undefined);
	
				if(options.withCredentials){
					_xhr.withCredentials = options.withCredentials;
				}
	
				if(has('native-response-type') && options.handleAs in nativeResponseTypes) {
					_xhr.responseType = nativeResponseTypes[options.handleAs];
				}
	
				var headers = options.headers,
					contentType = isFormData ? false : 'application/x-www-form-urlencoded';
				if(headers){
					for(var hdr in headers){
						if(hdr.toLowerCase() === 'content-type'){
							contentType = headers[hdr];
						}else if(headers[hdr]){
							//Only add header if it has a value. This allows for instance, skipping
							//insertion of X-Requested-With by specifying empty value.
							_xhr.setRequestHeader(hdr, headers[hdr]);
						}
					}
				}
	
				if(contentType && contentType !== false){
					_xhr.setRequestHeader('Content-Type', contentType);
				}
				if(!headers || !('X-Requested-With' in headers)){
					_xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
				}
	
				if(util.notify){
					util.notify.emit('send', response, dfd.promise.cancel);
				}
				_xhr.send(data);
			}catch(e){
				dfd.reject(e);
			}
	
			watch(dfd);
			_xhr = null;
	
			return returnDeferred ? dfd : dfd.promise;
		}
	
		/*=====
		xhr = function(url, options){
			// summary:
			//		Sends a request using XMLHttpRequest with the given URL and options.
			// url: String
			//		URL to request
			// options: dojo/request/xhr.__Options?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		xhr.__BaseOptions = declare(request.__BaseOptions, {
			// sync: Boolean?
			//		Whether to make a synchronous request or not. Default
			//		is `false` (asynchronous).
			// data: String|Object|FormData?
			//		Data to transfer. This is ignored for GET and DELETE
			//		requests.
			// headers: Object?
			//		Headers to use for the request.
			// user: String?
			//		Username to use during the request.
			// password: String?
			//		Password to use during the request.
			// withCredentials: Boolean?
			//		For cross-site requests, whether to send credentials
			//		or not.
		});
		xhr.__MethodOptions = declare(null, {
			// method: String?
			//		The HTTP method to use to make the request. Must be
			//		uppercase. Default is `"GET"`.
		});
		xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);
	
		xhr.get = function(url, options){
			// summary:
			//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
			// url: String
			//		URL to request
			// options: dojo/request/xhr.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		xhr.post = function(url, options){
			// summary:
			//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
			// url: String
			//		URL to request
			// options: dojo/request/xhr.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		xhr.put = function(url, options){
			// summary:
			//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
			// url: String
			//		URL to request
			// options: dojo/request/xhr.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		xhr.del = function(url, options){
			// summary:
			//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
			// url: String
			//		URL to request
			// options: dojo/request/xhr.__BaseOptions?
			//		Options for the request.
			// returns: dojo/request.__Promise
		};
		=====*/
		xhr._create = function(){
			// summary:
			//		does the work of portably generating a new XMLHTTPRequest object.
			throw new Error('XMLHTTP not available');
		};
		if(has('native-xhr') && !has('dojo-force-activex-xhr')){
			xhr._create = function(){
				return new XMLHttpRequest();
			};
		}else if(has('activex')){
			try{
				new ActiveXObject('Msxml2.XMLHTTP');
				xhr._create = function(){
					return new ActiveXObject('Msxml2.XMLHTTP');
				};
			}catch(e){
				try{
					new ActiveXObject('Microsoft.XMLHTTP');
					xhr._create = function(){
						return new ActiveXObject('Microsoft.XMLHTTP');
					};
				}catch(e){}
			}
		}
	
		util.addCommonMethods(xhr);
	
		return xhr;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = function(create){
		// module:
		//		dojo/errors/RequestError
	
		/*=====
		 return function(){
			 // summary:
			 //		TODOC
		 };
		 =====*/
	
		return create("RequestError", function(message, response){
			this.response = response;
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){
		return function(name, ctor, base, props){
			base = base || Error;
	
			var ErrorCtor = function(message){
				if(base === Error){
					if(Error.captureStackTrace){
						Error.captureStackTrace(this, ErrorCtor);
					}
	
					// Error.call() operates on the returned error
					// object rather than operating on |this|
					var err = Error.call(this, message),
						prop;
	
					// Copy own properties from err to |this|
					for(prop in err){
						if(err.hasOwnProperty(prop)){
							this[prop] = err[prop];
						}
					}
	
					// messsage is non-enumerable in ES5
					this.message = message;
					// stack is non-enumerable in at least Firefox
					this.stack = err.stack;
				}else{
					base.apply(this, arguments);
				}
				if(ctor){
					ctor.apply(this, arguments);
				}
			};
	
			ErrorCtor.prototype = lang.delegate(base.prototype, props);
			ErrorCtor.prototype.name = name;
			ErrorCtor.prototype.constructor = ErrorCtor;
	
			return ErrorCtor;
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(44),
		__webpack_require__(49),
		__webpack_require__(45),
		__webpack_require__(28),
		__webpack_require__(12),
		__webpack_require__(33)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(util, RequestTimeoutError, CancelError, array, win, on){
		// avoid setting a timer per request. It degrades performance on IE
		// something fierece if we don't use unified loops.
		var _inFlightIntvl = null,
			_inFlight = [];
	
		function watchInFlight(){
			// summary:
			//		internal method that checks each inflight XMLHttpRequest to see
			//		if it has completed or if the timeout situation applies.
	
			var now = +(new Date);
	
			// we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
			for(var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++){
				var response = dfd.response,
					options = response.options;
				if((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))){
					_inFlight.splice(i--, 1);
					watch._onAction && watch._onAction();
				}else if(dfd.isReady && dfd.isReady(response)){
					_inFlight.splice(i--, 1);
					dfd.handleResponse(response);
					watch._onAction && watch._onAction();
				}else if(dfd.startTime){
					// did we timeout?
					if(dfd.startTime + (options.timeout || 0) < now){
						_inFlight.splice(i--, 1);
						// Cancel the request so the io module can do appropriate cleanup.
						dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
						watch._onAction && watch._onAction();
					}
				}
			}
	
			watch._onInFlight && watch._onInFlight(dfd);
	
			if(!_inFlight.length){
				clearInterval(_inFlightIntvl);
				_inFlightIntvl = null;
			}
		}
	
		function watch(dfd){
			// summary:
			//		Watches the io request represented by dfd to see if it completes.
			// dfd: Deferred
			//		The Deferred object to watch.
			// response: Object
			//		The object used as the value of the request promise.
			// validCheck: Function
			//		Function used to check if the IO request is still valid. Gets the dfd
			//		object as its only argument.
			// ioCheck: Function
			//		Function used to check if basic IO call worked. Gets the dfd
			//		object as its only argument.
			// resHandle: Function
			//		Function used to process response. Gets the dfd
			//		object as its only argument.
			if(dfd.response.options.timeout){
				dfd.startTime = +(new Date);
			}
	
			if(dfd.isFulfilled()){
				// bail out if the deferred is already fulfilled
				return;
			}
	
			_inFlight.push(dfd);
			if(!_inFlightIntvl){
				_inFlightIntvl = setInterval(watchInFlight, 50);
			}
	
			// handle sync requests separately from async:
			// http://bugs.dojotoolkit.org/ticket/8467
			if(dfd.response.options.sync){
				watchInFlight();
			}
		}
	
		watch.cancelAll = function cancelAll(){
			// summary:
			//		Cancels all pending IO requests, regardless of IO type
			try{
				array.forEach(_inFlight, function(dfd){
					try{
						dfd.cancel(new CancelError('All requests canceled.'));
					}catch(e){}
				});
			}catch(e){}
		};
	
		if(win && on && win.doc.attachEvent){
			// Automatically call cancel all io calls on unload in IE
			// http://bugs.dojotoolkit.org/ticket/2357
			on(win.global, 'unload', function(){
				watch.cancelAll();
			});
		}
	
		return watch;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		exports,
		__webpack_require__(41),
		__webpack_require__(45),
		__webpack_require__(46),
		__webpack_require__(48),
		__webpack_require__(28),
		__webpack_require__(8),
		__webpack_require__(47)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise){
		exports.deepCopy = function deepCopy(target, source){
			for(var name in source){
				var tval = target[name],
					sval = source[name];
				if(tval !== sval){
					if(tval && typeof tval === 'object' && sval && typeof sval === 'object'){
						exports.deepCopy(tval, sval);
					}else{
						target[name] = sval;
					}
				}
			}
			return target;
		};
	
		exports.deepCreate = function deepCreate(source, properties){
			properties = properties || {};
			var target = lang.delegate(source),
				name, value;
	
			for(name in source){
				value = source[name];
	
				if(value && typeof value === 'object'){
					target[name] = exports.deepCreate(value, properties[name]);
				}
			}
			return exports.deepCopy(target, properties);
		};
	
		var freeze = Object.freeze || function(obj){ return obj; };
		function okHandler(response){
			return freeze(response);
		}
		function dataHandler (response) {
			return response.data !== undefined ? response.data : response.text;
		}
	
		exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last){
			var def = new Deferred(function(reason){
				cancel && cancel(def, response);
	
				if(!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)){
					return new CancelError('Request canceled', response);
				}
				return reason;
			});
	
			def.response = response;
			def.isValid = isValid;
			def.isReady = isReady;
			def.handleResponse = handleResponse;
	
			function errHandler(error){
				error.response = response;
				throw error;
			}
			var responsePromise = def.then(okHandler).otherwise(errHandler);
	
			if(exports.notify){
				responsePromise.then(
					lang.hitch(exports.notify, 'emit', 'load'),
					lang.hitch(exports.notify, 'emit', 'error')
				);
			}
	
			var dataPromise = responsePromise.then(dataHandler);
	
			// http://bugs.dojotoolkit.org/ticket/16794
			// The following works around a leak in IE9 through the
			// prototype using lang.delegate on dataPromise and
			// assigning the result a property with a reference to
			// responsePromise.
			var promise = new Promise();
			for (var prop in dataPromise) {
				if (dataPromise.hasOwnProperty(prop)) {
					promise[prop] = dataPromise[prop];
				}
			}
			promise.response = responsePromise;
			freeze(promise);
			// End leak fix
	
	
			if(last){
				def.then(function(response){
					last.call(def, response);
				}, function(error){
					last.call(def, response, error);
				});
			}
	
			def.promise = promise;
			def.then = promise.then;
	
			return def;
		};
	
		exports.addCommonMethods = function addCommonMethods(provider, methods){
			array.forEach(methods||['GET', 'POST', 'PUT', 'DELETE'], function(method){
				provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function(url, options){
					options = lang.delegate(options||{});
					options.method = method;
					return provider(url, options);
				};
			});
		};
	
		exports.parseArgs = function parseArgs(url, options, skipData){
			var data = options.data,
				query = options.query;
			
			if(data && !skipData){
				if(typeof data === 'object'){
					options.data = ioQuery.objectToQuery(data);
				}
			}
	
			if(query){
				if(typeof query === 'object'){
					query = ioQuery.objectToQuery(query);
				}
				if(options.preventCache){
					query += (query ? '&' : '') + 'request.preventCache=' + (+(new Date));
				}
			}else if(options.preventCache){
				query = 'request.preventCache=' + (+(new Date));
			}
	
			if(url && query){
				url += (~url.indexOf('?') ? '&' : '?') + query;
			}
	
			return {
				url: url,
				options: options,
				getHeader: function(headerName){ return null; }
			};
		};
	
		exports.checkStatus = function(stat){
			stat = stat || 0;
			return (stat >= 200 && stat < 300) || // allow any 2XX response code
				stat === 304 ||                 // or, get it out of the cache
				stat === 1223 ||                // or, Internet Explorer mangled the status code
				!stat;                         // or, we're Titanium/browser chrome/chrome extension requesting a local file
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(42)], __WEBPACK_AMD_DEFINE_RESULT__ = function(create){
		// module:
		//		dojo/errors/CancelError
	
		/*=====
		return function(){
			// summary:
			//		Default error if a promise is canceled without a reason.
		};
		=====*/
	
		return create("CancelError", null, null, { dojoType: "cancel" });
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(4),
		__webpack_require__(8),
		__webpack_require__(45),
		__webpack_require__(47),
		__webpack_require__(33)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, lang, CancelError, Promise, instrumentation){
		"use strict";
	
		// module:
		//		dojo/Deferred
	
		var PROGRESS = 0,
				RESOLVED = 1,
				REJECTED = 2;
		var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";
	
		var freezeObject = Object.freeze || function(){};
	
		var signalWaiting = function(waiting, type, result, rejection, deferred){
			if(has("config-deferredInstrumentation")){
				if(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){
					Deferred.instrumentRejected(result, false, rejection, deferred);
				}
			}
	
			for(var i = 0; i < waiting.length; i++){
				signalListener(waiting[i], type, result, rejection);
			}
		};
	
		var signalListener = function(listener, type, result, rejection){
			var func = listener[type];
			var deferred = listener.deferred;
			if(func){
				try{
					var newResult = func(result);
					if(type === PROGRESS){
						if(typeof newResult !== "undefined"){
							signalDeferred(deferred, type, newResult);
						}
					}else{
						if(newResult && typeof newResult.then === "function"){
							listener.cancel = newResult.cancel;
							newResult.then(
									// Only make resolvers if they're actually going to be used
									makeDeferredSignaler(deferred, RESOLVED),
									makeDeferredSignaler(deferred, REJECTED),
									makeDeferredSignaler(deferred, PROGRESS));
							return;
						}
						signalDeferred(deferred, RESOLVED, newResult);
					}
				}catch(error){
					signalDeferred(deferred, REJECTED, error);
				}
			}else{
				signalDeferred(deferred, type, result);
			}
	
			if(has("config-deferredInstrumentation")){
				if(type === REJECTED && Deferred.instrumentRejected){
					Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
				}
			}
		};
	
		var makeDeferredSignaler = function(deferred, type){
			return function(value){
				signalDeferred(deferred, type, value);
			};
		};
	
		var signalDeferred = function(deferred, type, result){
			if(!deferred.isCanceled()){
				switch(type){
					case PROGRESS:
						deferred.progress(result);
						break;
					case RESOLVED:
						deferred.resolve(result);
						break;
					case REJECTED:
						deferred.reject(result);
						break;
				}
			}
		};
	
		var Deferred = function(canceler){
			// summary:
			//		Creates a new deferred. This API is preferred over
			//		`dojo/_base/Deferred`.
			// description:
			//		Creates a new deferred, as an abstraction over (primarily)
			//		asynchronous operations. The deferred is the private interface
			//		that should not be returned to calling code. That's what the
			//		`promise` is for. See `dojo/promise/Promise`.
			// canceler: Function?
			//		Will be invoked if the deferred is canceled. The canceler
			//		receives the reason the deferred was canceled as its argument.
			//		The deferred is rejected with its return value, or a new
			//		`dojo/errors/CancelError` instance.
	
			// promise: dojo/promise/Promise
			//		The public promise object that clients can add callbacks to. 
			var promise = this.promise = new Promise();
	
			var deferred = this;
			var fulfilled, result, rejection;
			var canceled = false;
			var waiting = [];
	
			if(has("config-deferredInstrumentation") && Error.captureStackTrace){
				Error.captureStackTrace(deferred, Deferred);
				Error.captureStackTrace(promise, Deferred);
			}
	
			this.isResolved = promise.isResolved = function(){
				// summary:
				//		Checks whether the deferred has been resolved.
				// returns: Boolean
	
				return fulfilled === RESOLVED;
			};
	
			this.isRejected = promise.isRejected = function(){
				// summary:
				//		Checks whether the deferred has been rejected.
				// returns: Boolean
	
				return fulfilled === REJECTED;
			};
	
			this.isFulfilled = promise.isFulfilled = function(){
				// summary:
				//		Checks whether the deferred has been resolved or rejected.
				// returns: Boolean
	
				return !!fulfilled;
			};
	
			this.isCanceled = promise.isCanceled = function(){
				// summary:
				//		Checks whether the deferred has been canceled.
				// returns: Boolean
	
				return canceled;
			};
	
			this.progress = function(update, strict){
				// summary:
				//		Emit a progress update on the deferred.
				// description:
				//		Emit a progress update on the deferred. Progress updates
				//		can be used to communicate updates about the asynchronous
				//		operation before it has finished.
				// update: any
				//		The progress update. Passed to progbacks.
				// strict: Boolean?
				//		If strict, will throw an error if the deferred has already
				//		been fulfilled and consequently no progress can be emitted.
				// returns: dojo/promise/Promise
				//		Returns the original promise for the deferred.
	
				if(!fulfilled){
					signalWaiting(waiting, PROGRESS, update, null, deferred);
					return promise;
				}else if(strict === true){
					throw new Error(FULFILLED_ERROR_MESSAGE);
				}else{
					return promise;
				}
			};
	
			this.resolve = function(value, strict){
				// summary:
				//		Resolve the deferred.
				// description:
				//		Resolve the deferred, putting it in a success state.
				// value: any
				//		The result of the deferred. Passed to callbacks.
				// strict: Boolean?
				//		If strict, will throw an error if the deferred has already
				//		been fulfilled and consequently cannot be resolved.
				// returns: dojo/promise/Promise
				//		Returns the original promise for the deferred.
	
				if(!fulfilled){
					// Set fulfilled, store value. After signaling waiting listeners unset
					// waiting.
					signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
					waiting = null;
					return promise;
				}else if(strict === true){
					throw new Error(FULFILLED_ERROR_MESSAGE);
				}else{
					return promise;
				}
			};
	
			var reject = this.reject = function(error, strict){
				// summary:
				//		Reject the deferred.
				// description:
				//		Reject the deferred, putting it in an error state.
				// error: any
				//		The error result of the deferred. Passed to errbacks.
				// strict: Boolean?
				//		If strict, will throw an error if the deferred has already
				//		been fulfilled and consequently cannot be rejected.
				// returns: dojo/promise/Promise
				//		Returns the original promise for the deferred.
	
				if(!fulfilled){
					if(has("config-deferredInstrumentation") && Error.captureStackTrace){
						Error.captureStackTrace(rejection = {}, reject);
					}
					signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
					waiting = null;
					return promise;
				}else if(strict === true){
					throw new Error(FULFILLED_ERROR_MESSAGE);
				}else{
					return promise;
				}
			};
	
			this.then = promise.then = function(callback, errback, progback){
				// summary:
				//		Add new callbacks to the deferred.
				// description:
				//		Add new callbacks to the deferred. Callbacks can be added
				//		before or after the deferred is fulfilled.
				// callback: Function?
				//		Callback to be invoked when the promise is resolved.
				//		Receives the resolution value.
				// errback: Function?
				//		Callback to be invoked when the promise is rejected.
				//		Receives the rejection error.
				// progback: Function?
				//		Callback to be invoked when the promise emits a progress
				//		update. Receives the progress update.
				// returns: dojo/promise/Promise
				//		Returns a new promise for the result of the callback(s).
				//		This can be used for chaining many asynchronous operations.
	
				var listener = [progback, callback, errback];
				// Ensure we cancel the promise we're waiting for, or if callback/errback
				// have returned a promise, cancel that one.
				listener.cancel = promise.cancel;
				listener.deferred = new Deferred(function(reason){
					// Check whether cancel is really available, returned promises are not
					// required to expose `cancel`
					return listener.cancel && listener.cancel(reason);
				});
				if(fulfilled && !waiting){
					signalListener(listener, fulfilled, result, rejection);
				}else{
					waiting.push(listener);
				}
				return listener.deferred.promise;
			};
	
			this.cancel = promise.cancel = function(reason, strict){
				// summary:
				//		Inform the deferred it may cancel its asynchronous operation.
				// description:
				//		Inform the deferred it may cancel its asynchronous operation.
				//		The deferred's (optional) canceler is invoked and the
				//		deferred will be left in a rejected state. Can affect other
				//		promises that originate with the same deferred.
				// reason: any
				//		A message that may be sent to the deferred's canceler,
				//		explaining why it's being canceled.
				// strict: Boolean?
				//		If strict, will throw an error if the deferred has already
				//		been fulfilled and consequently cannot be canceled.
				// returns: any
				//		Returns the rejection reason if the deferred was canceled
				//		normally.
	
				if(!fulfilled){
					// Cancel can be called even after the deferred is fulfilled
					if(canceler){
						var returnedReason = canceler(reason);
						reason = typeof returnedReason === "undefined" ? reason : returnedReason;
					}
					canceled = true;
					if(!fulfilled){
						// Allow canceler to provide its own reason, but fall back to a CancelError
						if(typeof reason === "undefined"){
							reason = new CancelError();
						}
						reject(reason);
						return reason;
					}else if(fulfilled === REJECTED && result === reason){
						return reason;
					}
				}else if(strict === true){
					throw new Error(FULFILLED_ERROR_MESSAGE);
				}
			};
	
			freezeObject(promise);
		};
	
		Deferred.prototype.toString = function(){
			// returns: String
			//		Returns `[object Deferred]`.
	
			return "[object Deferred]";
		};
	
		if(instrumentation){
			instrumentation(Deferred);
		}
	
		return Deferred;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(8)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){
		"use strict";
	
		// module:
		//		dojo/promise/Promise
	
		function throwAbstract(){
			throw new TypeError("abstract");
		}
	
		return lang.extend(function Promise(){
			// summary:
			//		The public interface to a deferred.
			// description:
			//		The public interface to a deferred. All promises in Dojo are
			//		instances of this class.
		}, {
			then: function(callback, errback, progback){
				// summary:
				//		Add new callbacks to the promise.
				// description:
				//		Add new callbacks to the deferred. Callbacks can be added
				//		before or after the deferred is fulfilled.
				// callback: Function?
				//		Callback to be invoked when the promise is resolved.
				//		Receives the resolution value.
				// errback: Function?
				//		Callback to be invoked when the promise is rejected.
				//		Receives the rejection error.
				// progback: Function?
				//		Callback to be invoked when the promise emits a progress
				//		update. Receives the progress update.
				// returns: dojo/promise/Promise
				//		Returns a new promise for the result of the callback(s).
				//		This can be used for chaining many asynchronous operations.
	
				throwAbstract();
			},
	
			cancel: function(reason, strict){
				// summary:
				//		Inform the deferred it may cancel its asynchronous operation.
				// description:
				//		Inform the deferred it may cancel its asynchronous operation.
				//		The deferred's (optional) canceler is invoked and the
				//		deferred will be left in a rejected state. Can affect other
				//		promises that originate with the same deferred.
				// reason: any
				//		A message that may be sent to the deferred's canceler,
				//		explaining why it's being canceled.
				// strict: Boolean?
				//		If strict, will throw an error if the deferred has already
				//		been fulfilled and consequently cannot be canceled.
				// returns: any
				//		Returns the rejection reason if the deferred was canceled
				//		normally.
	
				throwAbstract();
			},
	
			isResolved: function(){
				// summary:
				//		Checks whether the promise has been resolved.
				// returns: Boolean
	
				throwAbstract();
			},
	
			isRejected: function(){
				// summary:
				//		Checks whether the promise has been rejected.
				// returns: Boolean
	
				throwAbstract();
			},
	
			isFulfilled: function(){
				// summary:
				//		Checks whether the promise has been resolved or rejected.
				// returns: Boolean
	
				throwAbstract();
			},
	
			isCanceled: function(){
				// summary:
				//		Checks whether the promise has been canceled.
				// returns: Boolean
	
				throwAbstract();
			},
	
			always: function(callbackOrErrback){
				// summary:
				//		Add a callback to be invoked when the promise is resolved
				//		or rejected.
				// callbackOrErrback: Function?
				//		A function that is used both as a callback and errback.
				// returns: dojo/promise/Promise
				//		Returns a new promise for the result of the callback/errback.
	
				return this.then(callbackOrErrback, callbackOrErrback);
			},
	
			otherwise: function(errback){
				// summary:
				//		Add new errbacks to the promise.
				// errback: Function?
				//		Callback to be invoked when the promise is rejected.
				// returns: dojo/promise/Promise
				//		Returns a new promise for the result of the errback.
	
				return this.then(null, errback);
			},
	
			trace: function(){
				return this;
			},
	
			traceRejected: function(){
				return this;
			},
	
			toString: function(){
				// returns: string
				//		Returns `[object Promise]`.
	
				return "[object Promise]";
			}
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang){
	
		// module:
		//		dojo/io-query
	
		var backstop = {};
	
		return {
			// summary:
			//		This module defines query string processing functions.
	
			objectToQuery: function objectToQuery(/*Object*/ map){
				// summary:
				//		takes a name/value mapping object and returns a string representing
				//		a URL-encoded version of that object.
				// example:
				//		this object:
				//
				//	|	{
				//	|		blah: "blah",
				//	|		multi: [
				//	|			"thud",
				//	|			"thonk"
				//	|		]
				//	|	};
				//
				//		yields the following query string:
				//
				//	|	"blah=blah&multi=thud&multi=thonk"
	
				// FIXME: need to implement encodeAscii!!
				var enc = encodeURIComponent, pairs = [];
				for(var name in map){
					var value = map[name];
					if(value != backstop[name]){
						var assign = enc(name) + "=";
						if(lang.isArray(value)){
							for(var i = 0, l = value.length; i < l; ++i){
								pairs.push(assign + enc(value[i]));
							}
						}else{
							pairs.push(assign + enc(value));
						}
					}
				}
				return pairs.join("&"); // String
			},
	
			queryToObject: function queryToObject(/*String*/ str){
				// summary:
				//		Create an object representing a de-serialized query section of a
				//		URL. Query keys with multiple values are returned in an array.
				//
				// example:
				//		This string:
				//
				//	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
				//
				//		results in this object structure:
				//
				//	|		{
				//	|			foo: [ "bar", "baz" ],
				//	|			thinger: " spaces =blah",
				//	|			zonk: "blarg"
				//	|		}
				//
				//		Note that spaces and other urlencoded entities are correctly
				//		handled.
	
	        	var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
				for(var i = 0, l = qp.length, item; i < l; ++i){
					item = qp[i];
					if(item.length){
						var s = item.indexOf("=");
						if(s < 0){
							name = dec(item);
							val = "";
						}else{
							name = dec(item.slice(0, s));
							val = dec(item.slice(s + 1));
						}
						if(typeof ret[name] == "string"){ // inline'd type check
							ret[name] = [ret[name]];
						}
	
						if(lang.isArray(ret[name])){
							ret[name].push(val);
						}else{
							ret[name] = val;
						}
					}
				}
				return ret; // Object
			}
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(42), __webpack_require__(41)], __WEBPACK_AMD_DEFINE_RESULT__ = function(create, RequestError){
		// module:
		//		dojo/errors/RequestTimeoutError
	
		/*=====
		 return function(){
			 // summary:
			 //		TODOC
		 };
		 =====*/
	
		return create("RequestTimeoutError", null, RequestError, {
			dojoType: "timeout"
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(51),
		__webpack_require__(2),
		__webpack_require__(28),
		__webpack_require__(4),
		__webpack_require__(35) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(JSON, kernel, array, has){
		has.add('activex', typeof ActiveXObject !== 'undefined');
		has.add('dom-parser', function(global){
			return 'DOMParser' in global;
		});
	
		var handleXML;
		if(has('activex')){
			// GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
			var dp = [
				'Msxml2.DOMDocument.6.0',
				'Msxml2.DOMDocument.4.0',
				'MSXML2.DOMDocument.3.0',
				'MSXML.DOMDocument' // 2.0
			];
			var lastParser;
	
			handleXML = function(response){
				var result = response.data;
				var text = response.text;
	
				if(result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')){
					// http://bugs.dojotoolkit.org/ticket/15631
					// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
					// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
					// the fuller-featured implementation and avoid bugs caused by the inconsistency
					result = new DOMParser().parseFromString(text, 'application/xml');
				}
	
				function createDocument(p) {
						try{
							var dom = new ActiveXObject(p);
							dom.async = false;
							dom.loadXML(text);
							result = dom;
							lastParser = p;
						}catch(e){ return false; }
						return true;
				}
	
				if(!result || !result.documentElement){
					// The creation of an ActiveX object is expensive, so we cache the
					// parser type to avoid trying all parser types each time we handle a
					// document. There is some concern that some parser types might fail
					// depending on the document being parsed. If parsing using the cached
					// parser type fails, we do the more expensive operation of finding one
					// that works for the given document.
					// https://bugs.dojotoolkit.org/ticket/15246
					if(!lastParser || !createDocument(lastParser)) {
						array.some(dp, createDocument);
					}
				}
	
				return result;
			};
		}
	
		var handleNativeResponse = function(response) {
			if(!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined'){
				return new Blob([ response.xhr.response ], { type: response.xhr.getResponseHeader('Content-Type') });
			}
	
			return response.xhr.response;
		}
	
		var handlers = {
			'javascript': function(response){
				return kernel.eval(response.text || '');
			},
			'json': function(response){
				return JSON.parse(response.text || null);
			},
			'xml': handleXML,
			'blob': handleNativeResponse,
			'arraybuffer': handleNativeResponse,
			'document': handleNativeResponse
		};
	
		function handle(response){
			var handler = handlers[response.options.handleAs];
	
			response.data = handler ? handler(response) : (response.data || response.text);
	
			return response;
		}
	
		handle.register = function(name, handler){
			handlers[name] = handler;
		};
	
		return handle;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has){
		"use strict";
		var hasJSON = typeof JSON != "undefined";
		has.add("json-parse", hasJSON); // all the parsers work fine
			// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
		has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{"a":1}');
	
		/*=====
		return {
			// summary:
			//		Functions to parse and serialize JSON
	
			parse: function(str, strict){
				// summary:
				//		Parses a [JSON](http://json.org) string to return a JavaScript object.
				// description:
				//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
				//		Throws for invalid JSON strings. This delegates to eval() if native JSON
				//		support is not available. By default this will evaluate any valid JS expression.
				//		With the strict parameter set to true, the parser will ensure that only
				//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
				//		parameter, the content passed to this method must come
				//		from a trusted source.
				// str:
				//		a string literal of a JSON item, for instance:
				//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
				// strict:
				//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
				//		Make sure this is set to true for untrusted content. Note that on browsers/engines
				//		without native JSON support, setting this to true will run slower.
			},
			stringify: function(value, replacer, spacer){
				// summary:
				//		Returns a [JSON](http://json.org) serialization of an object.
				// description:
				//		Returns a [JSON](http://json.org) serialization of an object.
				//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
				//		Note that this doesn't check for infinite recursion, so don't do that!
				// value:
				//		A value to be serialized.
				// replacer:
				//		A replacer function that is called for each value and can return a replacement
				// spacer:
				//		A spacer string to be used for pretty printing of JSON
				// example:
				//		simple serialization of a trivial object
				//	|	define(["dojo/json"], function(JSON){
				// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
				//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
			}
		};
		=====*/
	
		if(has("json-stringify")){
			return JSON;
		}else{
			var escapeString = function(/*String*/str){
				// summary:
				//		Adds escape sequences for non-visual characters, double quote and
				//		backslash and surrounds with double quotes to form a valid string
				//		literal.
				return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').
					replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").
					replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r"); // string
			};
			return {
				parse: has("json-parse") ? JSON.parse : function(str, strict){
					if(strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)){
						throw new SyntaxError("Invalid characters in JSON");
					}
					return eval('(' + str + ')');
				},
				stringify: function(value, replacer, spacer){
					var undef;
					if(typeof replacer == "string"){
						spacer = replacer;
						replacer = null;
					}
					function stringify(it, indent, key){
						if(replacer){
							it = replacer(key, it);
						}
						var val, objtype = typeof it;
						if(objtype == "number"){
							return isFinite(it) ? it + "" : "null";
						}
						if(objtype == "boolean"){
							return it + "";
						}
						if(it === null){
							return "null";
						}
						if(typeof it == "string"){
							return escapeString(it);
						}
						if(objtype == "function" || objtype == "undefined"){
							return undef; // undefined
						}
						// short-circuit for objects that support "json" serialization
						// if they return "self" then just pass-through...
						if(typeof it.toJSON == "function"){
							return stringify(it.toJSON(key), indent, key);
						}
						if(it instanceof Date){
							return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function(t, prop, plus){
								var num = it["getUTC" + prop]() + (plus ? 1 : 0);
								return num < 10 ? "0" + num : num;
							});
						}
						if(it.valueOf() !== it){
							// primitive wrapper, try again unwrapped:
							return stringify(it.valueOf(), indent, key);
						}
						var nextIndent= spacer ? (indent + spacer) : "";
						/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ 
					
						var sep = spacer ? " " : "";
						var newLine = spacer ? "\n" : "";
					
						// array
						if(it instanceof Array){
							var itl = it.length, res = [];
							for(key = 0; key < itl; key++){
								var obj = it[key];
								val = stringify(obj, nextIndent, key);
								if(typeof val != "string"){
									val = "null";
								}
								res.push(newLine + nextIndent + val);
							}
							return "[" + res.join(",") + newLine + indent + "]";
						}
						// generic object code path
						var output = [];
						for(key in it){
							var keyStr;
							if(it.hasOwnProperty(key)){
								if(typeof key == "number"){
									keyStr = '"' + key + '"';
								}else if(typeof key == "string"){
									keyStr = escapeString(key);
								}else{
									// skip non-string or number keys
									continue;
								}
								val = stringify(it[key], nextIndent, key);
								if(typeof val != "string"){
									// skip non-serializable values
									continue;
								}
								// At this point, the most non-IE browsers don't get in this branch 
								// (they have native JSON), so push is definitely the way to
								output.push(newLine + nextIndent + keyStr + ":" + sep + val);
							}
						}
						return "{" + output.join(",") + newLine + indent + "}"; // String
					}
					return stringify(value, "", "");
				}
			};
		}
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 52 */,
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(46),
		__webpack_require__(47)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Deferred, Promise){
		"use strict";
	
		// module:
		//		dojo/when
	
		return function when(valueOrPromise, callback, errback, progback){
			// summary:
			//		Transparently applies callbacks to values and/or promises.
			// description:
			//		Accepts promises but also transparently handles non-promises. If no
			//		callbacks are provided returns a promise, regardless of the initial
			//		value. Foreign promises are converted.
			//
			//		If callbacks are provided and the initial value is not a promise,
			//		the callback is executed immediately with no error handling. Returns
			//		a promise if the initial value is a promise, or the result of the
			//		callback otherwise.
			// valueOrPromise:
			//		Either a regular value or an object with a `then()` method that
			//		follows the Promises/A specification.
			// callback: Function?
			//		Callback to be invoked when the promise is resolved, or a non-promise
			//		is received.
			// errback: Function?
			//		Callback to be invoked when the promise is rejected.
			// progback: Function?
			//		Callback to be invoked when the promise emits a progress update.
			// returns: dojo/promise/Promise
			//		Promise, or if a callback is provided, the result of the callback.
	
			var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
			var nativePromise = receivedPromise && valueOrPromise instanceof Promise;
	
			if(!receivedPromise){
				if(arguments.length > 1){
					return callback ? callback(valueOrPromise) : valueOrPromise;
				}else{
					return new Deferred().resolve(valueOrPromise);
				}
			}else if(!nativePromise){
				var deferred = new Deferred(valueOrPromise.cancel);
				valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
				valueOrPromise = deferred.promise;
			}
	
			if(callback || errback || progback){
				return valueOrPromise.then(callback, errback, progback);
			}
			return valueOrPromise;
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(6), 
		__webpack_require__(28), 
		__webpack_require__(19),
		__webpack_require__(7), 
		__webpack_require__(17), 
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(14), 
		__webpack_require__(27), 
		__webpack_require__(11), 
		__webpack_require__(23), 
		__webpack_require__(15), 
		__webpack_require__(4),
		__webpack_require__(2),
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(70),
		__webpack_require__(72), 
		__webpack_require__(20),
		__webpack_require__(12), 
		__webpack_require__(73),
		__webpack_require__(33),
		__webpack_require__(74),__webpack_require__(6)    
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(require, array, aspect, config, connect, declare,
				dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
				lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_WidgetBase", (function(){
	
		// module:
		//		dijit/_WidgetBase
	
		// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
		has.add("dijit-legacy-requires", !kernel.isAsync);
	
		// Flag to enable support for textdir attribute
		has.add("dojo-bidi", false);
	
	
		// For back-compat, remove in 2.0.
		
	
		// Nested hash listing attributes for each tag, all strings in lowercase.
		// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
		var tagAttrs = {};
	
		function getAttrs(obj){
			var ret = {};
			for(var attr in obj){
				ret[attr.toLowerCase()] = true;
			}
			return ret;
		}
	
		function nonEmptyAttrToDom(attr){
			// summary:
			//		Returns a setter function that copies the attribute to this.domNode,
			//		or removes the attribute from this.domNode, depending on whether the
			//		value is defined or not.
			return function(val){
				domAttr[val ? "set" : "remove"](this.domNode, attr, val);
				this._set(attr, val);
			};
		}
	
		function isEqual(a, b){
			//	summary:
			//		Function that determines whether two values are identical,
			//		taking into account that NaN is not normally equal to itself
			//		in JS.
	
			return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
		}
	
		var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
			// summary:
			//		Future base class for all Dijit widgets.
			// description:
			//		Future base class for all Dijit widgets.
			//		_Widget extends this class adding support for various features needed by desktop.
			//
			//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
			//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
			//
			//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
			//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
			//
			//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
			//
			//		- DOM node attribute
			// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
			// |		_setFocusAttr: "focusNode"	(shorthand)
			// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
			//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
			//
			//		- DOM node innerHTML
			//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
			//		Maps this.title to this.titleNode.innerHTML
			//
			//		- DOM node innerText
			//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
			//		Maps this.title to this.titleNode.innerText
			//
			//		- DOM node CSS class
			// |		_setMyClassAttr: { node: "domNode", type: "class" }
			//		Maps this.myClass to this.domNode.className
			//
			//		- Toggle DOM node CSS class
			// |		_setMyClassAttr: { node: "domNode", type: "toggleClass" }
			//		Toggles myClass on this.domNode by this.myClass
			//
			//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
			//		formats of the above list.
			//
			//		If the custom setter is null, no action is performed other than saving the new value
			//		in the widget (in this).
			//
			//		If no custom setter is defined for an attribute, then it will be copied
			//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
			//		That's only done though for attributes that match DOMNode attributes (title,
			//		alt, aria-labelledby, etc.)
	
			// id: [const] String
			//		A unique, opaque ID string that can be assigned by users or by the
			//		system. If the developer passes an ID which is known not to be
			//		unique, the specified ID is ignored and the system-generated ID is
			//		used instead.
			id: "",
			_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's
	
			// lang: [const] String
			//		Rarely used.  Overrides the default Dojo locale used to render this widget,
			//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
			//		Value must be among the list of locales specified during by the Dojo bootstrap,
			//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
			lang: "",
			// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
			_setLangAttr: nonEmptyAttrToDom("lang"),
	
			// dir: [const] String
			//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
			//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
			//		default direction.
			dir: "",
			// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
			_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node
	
			// class: String
			//		HTML class attribute
			"class": "",
			_setClassAttr: { node: "domNode", type: "class" },
	
			// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
			// Instead, type must be specified as ${type} in the template, as part of the original DOM.
			_setTypeAttr: null,
	
			// style: String||Object
			//		HTML style attributes as cssText string or name/value hash
			style: "",
	
			// title: String
			//		HTML title attribute.
			//
			//		For form widgets this specifies a tooltip to display when hovering over
			//		the widget (just like the native HTML title attribute).
			//
			//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
			//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
			//		interpreted as HTML.
			title: "",
	
			// tooltip: String
			//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
			//		this specifies the tooltip to appear when the mouse is hovered over that text.
			tooltip: "",
	
			// baseClass: [protected] String
			//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
			//		widget state.
			baseClass: "",
	
			// srcNodeRef: [readonly] DomNode
			//		pointer to original DOM node
			srcNodeRef: null,
	
			// domNode: [readonly] DomNode
			//		This is our visible representation of the widget! Other DOM
			//		Nodes may by assigned to other properties, usually through the
			//		template system's data-dojo-attach-point syntax, but the domNode
			//		property is the canonical "top level" node in widget UI.
			domNode: null,
	
			// containerNode: [readonly] DomNode
			//		Designates where children of the source DOM node will be placed.
			//		"Children" in this case refers to both DOM nodes and widgets.
			//		For example, for myWidget:
			//
			//		|	<div data-dojo-type=myWidget>
			//		|		<b> here's a plain DOM node
			//		|		<span data-dojo-type=subWidget>and a widget</span>
			//		|		<i> and another plain DOM node </i>
			//		|	</div>
			//
			//		containerNode would point to:
			//
			//		|		<b> here's a plain DOM node
			//		|		<span data-dojo-type=subWidget>and a widget</span>
			//		|		<i> and another plain DOM node </i>
			//
			//		In templated widgets, "containerNode" is set via a
			//		data-dojo-attach-point assignment.
			//
			//		containerNode must be defined for any widget that accepts innerHTML
			//		(like ContentPane or BorderContainer or even Button), and conversely
			//		is null for widgets that don't, like TextBox.
			containerNode: null,
	
			// ownerDocument: [const] Document?
			//		The document this widget belongs to.  If not specified to constructor, will default to
			//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
			ownerDocument: null,
			_setOwnerDocumentAttr: function(val){
				// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
				this._set("ownerDocument", val);
			},
	
			/*=====
			// _started: [readonly] Boolean
			//		startup() has completed.
			_started: false,
			=====*/
	
			// attributeMap: [protected] Object
			//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
			//		for each XXX attribute to be mapped to the DOM.
			//
			//		attributeMap sets up a "binding" between attributes (aka properties)
			//		of the widget and the widget's DOM.
			//		Changes to widget attributes listed in attributeMap will be
			//		reflected into the DOM.
			//
			//		For example, calling set('title', 'hello')
			//		on a TitlePane will automatically cause the TitlePane's DOM to update
			//		with the new title.
			//
			//		attributeMap is a hash where the key is an attribute of the widget,
			//		and the value reflects a binding to a:
			//
			//		- DOM node attribute
			// |		focus: {node: "focusNode", type: "attribute"}
			//		Maps this.focus to this.focusNode.focus
			//
			//		- DOM node innerHTML
			//	|		title: { node: "titleNode", type: "innerHTML" }
			//		Maps this.title to this.titleNode.innerHTML
			//
			//		- DOM node innerText
			//	|		title: { node: "titleNode", type: "innerText" }
			//		Maps this.title to this.titleNode.innerText
			//
			//		- DOM node CSS class
			// |		myClass: { node: "domNode", type: "class" }
			//		Maps this.myClass to this.domNode.className
			//
			//		If the value is an array, then each element in the array matches one of the
			//		formats of the above list.
			//
			//		There are also some shorthands for backwards compatibility:
			//
			//		- string --> { node: string, type: "attribute" }, for example:
			//
			//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
			//
			//		- "" --> { node: "domNode", type: "attribute" }
			attributeMap: {},
	
			// _blankGif: [protected] String
			//		Path to a blank 1x1 image.
			//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
			_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),
	
			// textDir: String
			//		Bi-directional support,	the main variable which is responsible for the direction of the text.
			//		The text direction can be different than the GUI direction by using this parameter in creation
			//		of a widget.
			//
			//		This property is only effective when `has("dojo-bidi")` is defined to be true.
			//
			//		Allowed values:
			//
			//		1. "" - default value; text is same direction as widget
			//		2. "ltr"
			//		3. "rtl"
			//		4. "auto" - contextual the direction of a text defined by first strong letter.
			textDir: "",
	
			//////////// INITIALIZATION METHODS ///////////////////////////////////////
	
			/*=====
			constructor: function(params, srcNodeRef){
				// summary:
				//		Create the widget.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String?
				//		If a srcNodeRef (DOM node) is specified:
				//
				//		- use srcNodeRef.innerHTML as my contents
				//		- if this is a behavioral widget then apply behavior to that srcNodeRef
				//		- otherwise, replace srcNodeRef with my generated DOM tree
			},
			=====*/
	
			_introspect: function(){
				// summary:
				//		Collect metadata about this widget (only once per class, not once per instance):
				//
				//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
				//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown
	
				var ctor = this.constructor;
				if(!ctor._setterAttrs){
					var proto = ctor.prototype,
						attrs = ctor._setterAttrs = [], // attributes with custom setters
						onMap = (ctor._onMap = {});
	
					// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
					for(var name in proto.attributeMap){
						attrs.push(name);
					}
	
					// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
					for(name in proto){
						if(/^on/.test(name)){
							onMap[name.substring(2).toLowerCase()] = name;
						}
	
						if(/^_set[A-Z](.*)Attr$/.test(name)){
							name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
							if(!proto.attributeMap || !(name in proto.attributeMap)){
								attrs.push(name);
							}
						}
					}
	
					// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
					// but that set() maps to attributes on this.domNode or this.focusNode
				}
			},
	
			postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
				// summary:
				//		Kicks off widget instantiation.  See create() for details.
				// tags:
				//		private
	
				// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
				// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.
	
				this.create(params, srcNodeRef);
			},
	
			create: function(params, srcNodeRef){
				// summary:
				//		Kick off the life-cycle of a widget
				// description:
				//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
				//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
				//		for a discussion of the widget creation lifecycle.
				//
				//		Of course, adventurous developers could override create entirely, but this should
				//		only be done as a last resort.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String?
				//		If a srcNodeRef (DOM node) is specified:
				//
				//		- use srcNodeRef.innerHTML as my contents
				//		- if this is a behavioral widget then apply behavior to that srcNodeRef
				//		- otherwise, replace srcNodeRef with my generated DOM tree
				// tags:
				//		private
	
				// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
				this._introspect();
	
				// store pointer to original DOM tree
				this.srcNodeRef = dom.byId(srcNodeRef);
	
				// No longer used, remove for 2.0.
				this._connects = [];
				this._supportingWidgets = [];
	
				// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
				if(this.srcNodeRef && this.srcNodeRef.id  && (typeof this.srcNodeRef.id == "string")){
					this.id = this.srcNodeRef.id;
				}
	
				// mix in our passed parameters
				if(params){
					this.params = params;
					lang.mixin(this, params);
				}
				this.postMixInProperties();
	
				// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
				// Do this before buildRendering() because it might expect the id to be there.
				if(!this.id){
					this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
					if(this.params){
						// if params contains {id: undefined}, prevent _applyAttributes() from processing it
						delete this.params.id;
					}
				}
	
				// The document and <body> node this widget is associated with
				this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
				this.ownerDocumentBody = win.body(this.ownerDocument);
	
				registry.add(this);
	
				this.buildRendering();
	
				var deleteSrcNodeRef;
	
				if(this.domNode){
					// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
					// Also calls custom setters for all attributes with custom setters.
					this._applyAttributes();
	
					// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
					// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
					// widget being attached to the DOM since it isn't when a widget is created programmatically like
					// new MyWidget({}).	See #11635.
					var source = this.srcNodeRef;
					if(source && source.parentNode && this.domNode !== source){
						source.parentNode.replaceChild(this.domNode, source);
						deleteSrcNodeRef = true;
					}
	
					// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
					// assuming that dojo._scopeName even exists in 2.0
					this.domNode.setAttribute("widgetId", this.id);
				}
				this.postCreate();
	
				// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
				// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
				if(deleteSrcNodeRef){
					delete this.srcNodeRef;
				}
	
				this._created = true;
			},
	
			_applyAttributes: function(){
				// summary:
				//		Step during widget creation to copy  widget attributes to the
				//		DOM according to attributeMap and _setXXXAttr objects, and also to call
				//		custom _setXXXAttr() methods.
				//
				//		Skips over blank/false attribute values, unless they were explicitly specified
				//		as parameters to the widget, since those are the default anyway,
				//		and setting tabIndex="" is different than not setting tabIndex at all.
				//
				//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
				//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
				// tags:
				//		private
	
				// Call this.set() for each property that was either specified as parameter to constructor,
				// or is in the list found above.	For correlated properties like value and displayedValue, the one
				// specified as a parameter should take precedence.
				// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
				// NaN and thus is not ignored like a default value of "".
	
				// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
				// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
				var params = {};
				for(var key in this.params || {}){
					params[key] = this._get(key);
				}
	
				// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
				array.forEach(this.constructor._setterAttrs, function(key){
					if(!(key in params)){
						var val = this._get(key);
						if(val){
							this.set(key, val);
						}
					}
				}, this);
	
				// Step 3: Call set() for each property that was specified as parameter to constructor.
				// Use params hash created above to ignore side effects from step #2 above.
				for(key in params){
					this.set(key, params[key]);
				}
			},
	
			postMixInProperties: function(){
				// summary:
				//		Called after the parameters to the widget have been read-in,
				//		but before the widget template is instantiated. Especially
				//		useful to set properties that are referenced in the widget
				//		template.
				// tags:
				//		protected
			},
	
			buildRendering: function(){
				// summary:
				//		Construct the UI for this widget, setting this.domNode.
				//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
				// tags:
				//		protected
	
				if(!this.domNode){
					// Create root node if it wasn't created by _TemplatedMixin
					this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
				}
	
				// baseClass is a single class name or occasionally a space-separated list of names.
				// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
				// TODO: make baseClass custom setter
				if(this.baseClass){
					var classes = this.baseClass.split(" ");
					if(!this.isLeftToRight()){
						classes = classes.concat(array.map(classes, function(name){
							return name + "Rtl";
						}));
					}
					domClass.add(this.domNode, classes);
				}
			},
	
			postCreate: function(){
				// summary:
				//		Processing after the DOM fragment is created
				// description:
				//		Called after the DOM fragment has been created, but not necessarily
				//		added to the document.  Do not include any operations which rely on
				//		node dimensions or placement.
				// tags:
				//		protected
			},
	
			startup: function(){
				// summary:
				//		Processing after the DOM fragment is added to the document
				// description:
				//		Called after a widget and its children have been created and added to the page,
				//		and all related widgets have finished their create() cycle, up through postCreate().
				//
				//		Note that startup() may be called while the widget is still hidden, for example if the widget is
				//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
				//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
				//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
				if(this._started){
					return;
				}
				this._started = true;
				array.forEach(this.getChildren(), function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				});
			},
	
			//////////// DESTROY FUNCTIONS ////////////////////////////////
	
			destroyRecursive: function(/*Boolean?*/ preserveDom){
				// summary:
				//		Destroy this widget and its descendants
				// description:
				//		This is the generic "destructor" function that all widget users
				//		should call to cleanly discard with a widget. Once a widget is
				//		destroyed, it is removed from the manager object.
				// preserveDom:
				//		If true, this method will leave the original DOM structure
				//		alone of descendant Widgets. Note: This will NOT work with
				//		dijit._TemplatedMixin widgets.
	
				this._beingDestroyed = true;
				this.destroyDescendants(preserveDom);
				this.destroy(preserveDom);
			},
	
			destroy: function(/*Boolean*/ preserveDom){
				// summary:
				//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
				//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
				//
				//		This method will also destroy internal widgets such as those created from a template,
				//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
				//
				//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
				//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
				//		they should use destroyRecursive() for widgets with children.
				// preserveDom: Boolean
				//		If true, this method will leave the original DOM structure alone.
				//		Note: This will not yet work with _TemplatedMixin widgets
	
				this._beingDestroyed = true;
				this.uninitialize();
	
				function destroy(w){
					if(w.destroyRecursive){
						w.destroyRecursive(preserveDom);
					}else if(w.destroy){
						w.destroy(preserveDom);
					}
				}
	
				// Back-compat, remove for 2.0
				array.forEach(this._connects, lang.hitch(this, "disconnect"));
				array.forEach(this._supportingWidgets, destroy);
	
				// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
				// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
				if(this.domNode){
					array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
				}
	
				this.destroyRendering(preserveDom);
				registry.remove(this.id);
				this._destroyed = true;
			},
	
			destroyRendering: function(/*Boolean?*/ preserveDom){
				// summary:
				//		Destroys the DOM nodes associated with this widget.
				// preserveDom:
				//		If true, this method will leave the original DOM structure alone
				//		during tear-down. Note: this will not work with _Templated
				//		widgets yet.
				// tags:
				//		protected
	
				if(this.bgIframe){
					this.bgIframe.destroy(preserveDom);
					delete this.bgIframe;
				}
	
				if(this.domNode){
					if(preserveDom){
						domAttr.remove(this.domNode, "widgetId");
					}else{
						domConstruct.destroy(this.domNode);
					}
					delete this.domNode;
				}
	
				if(this.srcNodeRef){
					if(!preserveDom){
						domConstruct.destroy(this.srcNodeRef);
					}
					delete this.srcNodeRef;
				}
			},
	
			destroyDescendants: function(/*Boolean?*/ preserveDom){
				// summary:
				//		Recursively destroy the children of this widget and their
				//		descendants.
				// preserveDom:
				//		If true, the preserveDom attribute is passed to all descendant
				//		widget's .destroy() method. Not for use with _Templated
				//		widgets.
	
				// get all direct descendants and destroy them recursively
				array.forEach(this.getChildren(), function(widget){
					if(widget.destroyRecursive){
						widget.destroyRecursive(preserveDom);
					}
				});
			},
	
			uninitialize: function(){
				// summary:
				//		Deprecated. Override destroy() instead to implement custom widget tear-down
				//		behavior.
				// tags:
				//		protected
				return false;
			},
	
			////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////
	
			_setStyleAttr: function(/*String||Object*/ value){
				// summary:
				//		Sets the style attribute of the widget according to value,
				//		which is either a hash like {height: "5px", width: "3px"}
				//		or a plain string
				// description:
				//		Determines which node to set the style on based on style setting
				//		in attributeMap.
				// tags:
				//		protected
	
				var mapNode = this.domNode;
	
				// Note: technically we should revert any style setting made in a previous call
				// to his method, but that's difficult to keep track of.
	
				if(lang.isObject(value)){
					domStyle.set(mapNode, value);
				}else{
					if(mapNode.style.cssText){
						mapNode.style.cssText += "; " + value;
					}else{
						mapNode.style.cssText = value;
					}
				}
	
				this._set("style", value);
			},
	
			_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
				// summary:
				//		Reflect a widget attribute (title, tabIndex, duration etc.) to
				//		the widget DOM, as specified by commands parameter.
				//		If commands isn't specified then it's looked up from attributeMap.
				//		Note some attributes like "type"
				//		cannot be processed this way as they are not mutable.
				// attr:
				//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
				//		to DOMNode inside the widget, or alternately pointing to a subwidget
				// tags:
				//		private
	
				commands = arguments.length >= 3 ? commands : this.attributeMap[attr];
	
				array.forEach(lang.isArray(commands) ? commands : [commands], function(command){
	
					// Get target node and what we are doing to that node
					var mapNode = this[command.node || command || "domNode"];	// DOM node
					var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute
	
					switch(type){
						case "attribute":
							if(lang.isFunction(value)){ // functions execute in the context of the widget
								value = lang.hitch(this, value);
							}
	
							// Get the name of the DOM node attribute; usually it's the same
							// as the name of the attribute in the widget (attr), but can be overridden.
							// Also maps handler names to lowercase, like onSubmit --> onsubmit
							var attrName = command.attribute ? command.attribute :
								(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);
	
							if(mapNode.tagName){
								// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
								// method, but for consistency we still call domAttr
								domAttr.set(mapNode, attrName, value);
							}else{
								// mapping to a sub-widget
								mapNode.set(attrName, value);
							}
							break;
						case "innerText":
							mapNode.innerHTML = "";
							mapNode.appendChild(this.ownerDocument.createTextNode(value));
							break;
						case "innerHTML":
							mapNode.innerHTML = value;
							break;
						case "class":
							domClass.replace(mapNode, value, this[attr]);
							break;
						case "toggleClass":
							domClass.toggle(mapNode, command.className || attr, value);
							break;
					}
				}, this);
			},
	
			get: function(name){
				// summary:
				//		Get a property from a widget.
				// name:
				//		The property to get.
				// description:
				//		Get a named property from a widget. The property may
				//		potentially be retrieved via a getter method. If no getter is defined, this
				//		just retrieves the object's property.
				//
				//		For example, if the widget has properties `foo` and `bar`
				//		and a method named `_getFooAttr()`, calling:
				//		`myWidget.get("foo")` would be equivalent to calling
				//		`widget._getFooAttr()` and `myWidget.get("bar")`
				//		would be equivalent to the expression
				//		`widget.bar2`
				var names = this._getAttrNames(name);
				return this[names.g] ? this[names.g]() : this._get(name);
			},
	
			set: function(name, value){
				// summary:
				//		Set a property on a widget
				// name:
				//		The property to set.
				// value:
				//		The value to set in the property.
				// description:
				//		Sets named properties on a widget which may potentially be handled by a
				//		setter in the widget.
				//
				//		For example, if the widget has properties `foo` and `bar`
				//		and a method named `_setFooAttr()`, calling
				//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
				//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
				//		would be equivalent to the statement `widget.bar = 3;`
				//
				//		set() may also be called with a hash of name/value pairs, ex:
				//
				//	|	myWidget.set({
				//	|		foo: "Howdy",
				//	|		bar: 3
				//	|	});
				//
				//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`
	
				if(typeof name === "object"){
					for(var x in name){
						this.set(x, name[x]);
					}
					return this;
				}
				var names = this._getAttrNames(name),
					setter = this[names.s];
				if(lang.isFunction(setter)){
					// use the explicit setter
					var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
				}else{
					// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
					// Map according to:
					//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
					//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
					//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
					// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
					// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
					// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
					var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
						tag = this[defaultNode] && this[defaultNode].tagName,
						attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
						map = name in this.attributeMap ? this.attributeMap[name] :
							names.s in this ? this[names.s] :
								((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
									/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
					if(map != null){
						this._attrToDom(name, value, map);
					}
					this._set(name, value);
				}
				return result || this;
			},
	
			_attrPairNames: {}, // shared between all widgets
			_getAttrNames: function(name){
				// summary:
				//		Helper function for get() and set().
				//		Caches attribute name values so we don't do the string ops every time.
				// tags:
				//		private
	
				var apn = this._attrPairNames;
				if(apn[name]){
					return apn[name];
				}
				var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
					return c.charAt(c.length - 1).toUpperCase();
				});
				return (apn[name] = {
					n: name + "Node",
					s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
					g: "_get" + uc + "Attr",
					l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
				});
			},
	
			_set: function(/*String*/ name, /*anything*/ value){
				// summary:
				//		Helper function to set new value for specified property, and call handlers
				//		registered with watch() if the value has changed.
				var oldValue = this[name];
				this[name] = value;
				if(this._created && !isEqual(oldValue, value)){
					if(this._watchCallbacks){
						this._watchCallbacks(name, oldValue, value);
					}
					this.emit("attrmodified-" + name, {
						detail: {
							prevValue: oldValue,
							newValue: value
						}
					});
				}
			},
	
			_get: function(/*String*/ name){
				// summary:
				//		Helper function to get value for specified property stored by this._set(),
				//		i.e. for properties with custom setters.  Used mainly by custom getters.
				//
				//		For example, CheckBox._getValueAttr() calls this._get("value").
	
				// future: return name in this.props ? this.props[name] : this[name];
				return this[name];
			},
	
			emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
				// summary:
				//		Used by widgets to signal that a synthetic event occurred, ex:
				//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
				//
				//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
				//		Also calls onType() method, if present, and returns value from that method.
				//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
				//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
				// tags:
				//		protected
	
				// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
				// Also set pointer to widget, although since we can't add a pointer to the widget for native events
				// (see #14729), maybe we shouldn't do it here?
				eventObj = eventObj || {};
				if(eventObj.bubbles === undefined){
					eventObj.bubbles = true;
				}
				if(eventObj.cancelable === undefined){
					eventObj.cancelable = true;
				}
				if(!eventObj.detail){
					eventObj.detail = {};
				}
				eventObj.detail.widget = this;
	
				var ret, callback = this["on" + type];
				if(callback){
					ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
				}
	
				// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
				if(this._started && !this._beingDestroyed){
					on.emit(this.domNode, type.toLowerCase(), eventObj);
				}
	
				return ret;
			},
	
			on: function(/*String|Function*/ type, /*Function*/ func){
				// summary:
				//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
				// type:
				//		Name of event (ex: "click") or extension event like touch.press.
				// description:
				//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
				//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
				//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.
	
				// For backwards compatibility, if there's an onType() method in the widget then connect to that.
				// Remove in 2.0.
				var widgetMethod = this._onMap(type);
				if(widgetMethod){
					return aspect.after(this, widgetMethod, func, true);
				}
	
				// Otherwise, just listen for the event on this.domNode.
				return this.own(on(this.domNode, type, func))[0];
			},
	
			_onMap: function(/*String|Function*/ type){
				// summary:
				//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
				//		If type is a synthetic event like touch.press then returns undefined.
				var ctor = this.constructor, map = ctor._onMap;
				if(!map){
					map = (ctor._onMap = {});
					for(var attr in ctor.prototype){
						if(/^on/.test(attr)){
							map[attr.replace(/^on/, "").toLowerCase()] = attr;
						}
					}
				}
				return map[typeof type == "string" && type.toLowerCase()];	// String
			},
	
			toString: function(){
				// summary:
				//		Returns a string that represents the widget.
				// description:
				//		When a widget is cast to a string, this method will be used to generate the
				//		output. Currently, it does not implement any sort of reversible
				//		serialization.
				return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
			},
	
			getChildren: function(){
				// summary:
				//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
				//		is this widget.   Note that it does not return all descendants, but rather just direct children.
				//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
				//		except containing widgets rather than DOMNodes.
				//
				//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
				//		outside of this.containerNode.
				//
				//		Note that the array returned is a simple array.  Application code should not assume
				//		existence of methods like forEach().
	
				return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
			},
	
			getParent: function(){
				// summary:
				//		Returns the parent widget of this widget.
	
				return registry.getEnclosingWidget(this.domNode.parentNode);
			},
	
			connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
				// summary:
				//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
				//
				//		Connects specified obj/event to specified method of this object
				//		and registers for disconnect() on widget destroy.
				//
				//		Provide widget-specific analog to dojo.connect, except with the
				//		implicit use of this widget as the target object.
				//		Events connected with `this.connect` are disconnected upon
				//		destruction.
				// returns:
				//		A handle that can be passed to `disconnect` in order to disconnect before
				//		the widget is destroyed.
				// example:
				//	|	var btn = new Button();
				//	|	// when foo.bar() is called, call the listener we're going to
				//	|	// provide in the scope of btn
				//	|	btn.connect(foo, "bar", function(){
				//	|		console.debug(this.toString());
				//	|	});
				// tags:
				//		protected
	
				return this.own(connect.connect(obj, event, this, method))[0];	// handle
			},
	
			disconnect: function(handle){
				// summary:
				//		Deprecated, will be removed in 2.0, use handle.remove() instead.
				//
				//		Disconnects handle created by `connect`.
				// tags:
				//		protected
	
				handle.remove();
			},
	
			subscribe: function(t, method){
				// summary:
				//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
				//
				//		Subscribes to the specified topic and calls the specified method
				//		of this object and registers for unsubscribe() on widget destroy.
				//
				//		Provide widget-specific analog to dojo.subscribe, except with the
				//		implicit use of this widget as the target object.
				// t: String
				//		The topic
				// method: Function
				//		The callback
				// example:
				//	|	var btn = new Button();
				//	|	// when /my/topic is published, this button changes its label to
				//	|	// be the parameter of the topic.
				//	|	btn.subscribe("/my/topic", function(v){
				//	|		this.set("label", v);
				//	|	});
				// tags:
				//		protected
				return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
			},
	
			unsubscribe: function(/*Object*/ handle){
				// summary:
				//		Deprecated, will be removed in 2.0, use handle.remove() instead.
				//
				//		Unsubscribes handle created by this.subscribe.
				//		Also removes handle from this widget's list of subscriptions
				// tags:
				//		protected
	
				handle.remove();
			},
	
			isLeftToRight: function(){
				// summary:
				//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
				// tags:
				//		protected
				return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
			},
	
			isFocusable: function(){
				// summary:
				//		Return true if this widget can currently be focused
				//		and false if not
				return this.focus && (domStyle.get(this.domNode, "display") != "none");
			},
	
			placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
				// summary:
				//		Place this widget somewhere in the DOM based
				//		on standard domConstruct.place() conventions.
				// description:
				//		A convenience function provided in all _Widgets, providing a simple
				//		shorthand mechanism to put an existing (or newly created) Widget
				//		somewhere in the dom, and allow chaining.
				// reference:
				//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
				// position:
				//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
				//		it will be called passing this widget instance into that method, supplying the optional
				//		position index passed.  In this case position (if specified) should be an integer.
				//
				//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
				//		the position argument can be a numeric index or a string
				//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
				// returns: dijit/_WidgetBase
				//		Provides a useful return of the newly created dijit._Widget instance so you
				//		can "chain" this function by instantiating, placing, then saving the return value
				//		to a variable.
				// example:
				//	|	// create a Button with no srcNodeRef, and place it in the body:
				//	|	var button = new Button({ label:"click" }).placeAt(win.body());
				//	|	// now, 'button' is still the widget reference to the newly created button
				//	|	button.on("click", function(e){ console.log('click'); }));
				// example:
				//	|	// create a button out of a node with id="src" and append it to id="wrapper":
				//	|	var button = new Button({},"src").placeAt("wrapper");
				// example:
				//	|	// place a new button as the first element of some div
				//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
				// example:
				//	|	// create a contentpane and add it to a TabContainer
				//	|	var tc = dijit.byId("myTabs");
				//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)
	
				var refWidget = !reference.tagName && registry.byId(reference);
				if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
					// Adding this to refWidget and can use refWidget.addChild() to handle everything.
					refWidget.addChild(this, position);
				}else{
					// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
					// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
					// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
					var ref = refWidget && ("domNode" in refWidget) ?
						(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
							refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
					domConstruct.place(this.domNode, ref, position);
	
					// Start this iff it has a parent widget that's already started.
					// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
					if(!this._started && (this.getParent() || {})._started){
						this.startup();
					}
				}
				return this;
			},
	
			defer: function(fcn, delay){
				// summary:
				//		Wrapper to setTimeout to avoid deferred functions executing
				//		after the originating widget has been destroyed.
				//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
				// fcn: Function
				//		Function reference.
				// delay: Number?
				//		Delay, defaults to 0.
				// tags:
				//		protected
	
				var timer = setTimeout(lang.hitch(this,
					function(){
						if(!timer){
							return;
						}
						timer = null;
						if(!this._destroyed){
							lang.hitch(this, fcn)();
						}
					}),
					delay || 0
				);
				return {
					remove: function(){
						if(timer){
							clearTimeout(timer);
							timer = null;
						}
						return null; // so this works well: handle = handle.remove();
					}
				};
			}
		});
	
		if(has("dojo-bidi")){
			_WidgetBase.extend(_BidiMixin);
		}
	
		return _WidgetBase;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(6), __webpack_require__(71), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has, require, domReady, lang){
		// module:
		//		dojo/ready
		// note:
		//		This module should be unnecessary in dojo 2.0
	
		var
			// truthy if DOMContentLoaded or better (e.g., window.onload fired) has been achieved
			isDomReady = 0,
	
			// The queue of functions waiting to execute as soon as dojo.ready conditions satisfied
			loadQ = [],
	
			// prevent recursion in onLoad
			onLoadRecursiveGuard = 0,
	
			handleDomReady = function(){
				isDomReady = 1;
				dojo._postLoad = dojo.config.afterOnLoad = true;
				onEvent();
			},
	
			onEvent = function(){
				// Called when some state changes:
				//		- dom ready
				//		- dojo/domReady has finished processing everything in its queue
				//		- task added to loadQ
				//		- require() has finished loading all currently requested modules
				//
				// Run the functions queued with dojo.ready if appropriate.
	
	
				//guard against recursions into this function
				if(onLoadRecursiveGuard){
					return;
				}
				onLoadRecursiveGuard = 1;
	
				// Run tasks in queue if require() is finished loading modules, the dom is ready, and there are no
				// pending tasks registered via domReady().
				// The last step is necessary so that a user defined dojo.ready() callback is delayed until after the
				// domReady() calls inside of dojo.	  Failure can be seen on dijit/tests/robot/Dialog_ally.html on IE8
				// because the dijit/focus.js domReady() callback doesn't execute until after the test starts running.
				while(isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length){
					var f = loadQ.shift();
					try{
						f();
					}catch(e){
						// force the dojo.js on("error") handler do display the message
						e.info = e.message;
						if(require.signal){
							require.signal("error", e);
						}else{
							throw e;
						}
					}
				}
	
				onLoadRecursiveGuard = 0;
			};
	
		// Check if we should run the next queue operation whenever require() finishes loading modules or domReady
		// finishes processing it's queue.
		require.on && require.on("idle", onEvent);
		if(domReady){
			domReady._onQEmpty = onEvent;
		}
	
		var ready = dojo.ready = dojo.addOnLoad = function(priority, context, callback){
			// summary:
			//		Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.
			//		In most cases, the `domReady` plug-in should suffice and this method should not be needed.
			//
			//		When called in a non-browser environment, just checks that all requested modules have arrived and been
			//		evaluated.
			// priority: Integer?
			//		The order in which to exec this callback relative to other callbacks, defaults to 1000
			// context: Object?|Function
			//		The context in which to run execute callback, or a callback if not using context
			// callback: Function?
			//		The function to execute.
			//
			// example:
			//	Simple DOM and Modules ready syntax
			//	|	require(["dojo/ready"], function(ready){
			//	|		ready(function(){ alert("Dom ready!"); });
			//	|	});
			//
			// example:
			//	Using a priority
			//	|	require(["dojo/ready"], function(ready){
			//	|		ready(2, function(){ alert("low priority ready!"); })
			//	|	});
			//
			// example:
			//	Using context
			//	|	require(["dojo/ready"], function(ready){
			//	|		ready(foo, function(){
			//	|			// in here, this == foo
			//	|		});
			//	|	});
			//
			// example:
			//	Using dojo/hitch style args:
			//	|	require(["dojo/ready"], function(ready){
			//	|		var foo = { dojoReady: function(){ console.warn(this, "dojo dom and modules ready."); } };
			//	|		ready(foo, "dojoReady");
			//	|	});
	
			var hitchArgs = lang._toArray(arguments);
			if(typeof priority != "number"){
				callback = context;
				context = priority;
				priority = 1000;
			}else{
				hitchArgs.shift();
			}
			callback = callback ?
				lang.hitch.apply(dojo, hitchArgs) :
				function(){
					context();
				};
			callback.priority = priority;
			for(var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++){}
			loadQ.splice(i, 0, callback);
			onEvent();
		};
	
		has.add("dojo-config-addOnLoad", 1);
		if(has("dojo-config-addOnLoad")){
			var dca = dojo.config.addOnLoad;
			if(dca){
				ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
			}
		}
	
		if(has("dojo-sync-loader") && dojo.config.parseOnLoad && !dojo.isAsync){
			ready(99, function(){
				if(!dojo.parser){
					dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
					require(["dojo/parser"]);
				}
			});
		}
	
		if(domReady){
			domReady(handleDomReady);
		}else{
			handleDomReady();
		}
	
		return ready;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has){
		var global = (function () { return this; })(),
			doc = document,
			readyStates = { 'loaded': 1, 'complete': 1 },
			fixReadyState = typeof doc.readyState != "string",
			ready = !!readyStates[doc.readyState],
			readyQ = [],
			recursiveGuard;
	
		function domReady(callback){
			// summary:
			//		Plugin to delay require()/define() callback from firing until the DOM has finished loading.
			readyQ.push(callback);
			if(ready){ processQ(); }
		}
		domReady.load = function(id, req, load){
			domReady(load);
		};
	
		// Export queue so that ready() can check if it's empty or not.
		domReady._Q = readyQ;
		domReady._onQEmpty = function(){
			// summary:
			//		Private method overridden by dojo/ready, to notify when everything in the
			//		domReady queue has been processed.  Do not use directly.
			//		Will be removed in 2.0, along with domReady._Q.
		};
	
		// For FF <= 3.5
		if(fixReadyState){ doc.readyState = "loading"; }
	
		function processQ(){
			// Calls all functions in the queue in order, unless processQ() is already running, in which case just return
	
			if(recursiveGuard){ return; }
			recursiveGuard = true;
	
			while(readyQ.length){
				try{
					(readyQ.shift())(doc);
				}catch(err){
					console.error(err, "in domReady callback", err.stack);
				}
			}
	
			recursiveGuard = false;
	
			// Notification for dojo/ready.  Remove for 2.0.
			// Note that this could add more tasks to the ready queue.
			domReady._onQEmpty();
		}
	
		if(!ready){
			var tests = [],
				detectReady = function(evt){
					evt = evt || global.event;
					if(ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])){ return; }
	
					// For FF <= 3.5
					if(fixReadyState){ doc.readyState = "complete"; }
	
					ready = 1;
					processQ();
				},
				on = function(node, event){
					node.addEventListener(event, detectReady, false);
					readyQ.push(function(){ node.removeEventListener(event, detectReady, false); });
				};
	
			if(!has("dom-addeventlistener")){
				on = function(node, event){
					event = "on" + event;
					node.attachEvent(event, detectReady);
					readyQ.push(function(){ node.detachEvent(event, detectReady); });
				};
	
				var div = doc.createElement("div");
				try{
					if(div.doScroll && global.frameElement === null){
						// the doScroll test is only useful if we're in the top-most frame
						tests.push(function(){
							// Derived with permission from Diego Perini's IEContentLoaded
							// http://javascript.nwbox.com/IEContentLoaded/
							try{
								div.doScroll("left");
								return 1;
							}catch(e){}
						});
					}
				}catch(e){}
			}
	
			on(doc, "DOMContentLoaded");
			on(global, "load");
	
			if("onreadystatechange" in doc){
				on(doc, "readystatechange");
			}else if(!fixReadyState){
				// if the ready state property exists and there's
				// no readystatechange event, poll for the state
				// to change
				tests.push(function(){
					return readyStates[doc.readyState];
				});
			}
	
			if(tests.length){
				var poller = function(){
					if(ready){ return; }
					var i = tests.length;
					while(i--){
						if(tests[i]()){
							detectReady("poller");
							return;
						}
					}
					setTimeout(poller, 30);
				};
				poller();
			}
		}
	
		return domReady;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(8), __webpack_require__(28), __webpack_require__(53)], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, lang, array, when){
		// module:
		//		dojo/Stateful
	
	return declare("dojo.Stateful", null, {
		// summary:
		//		Base class for objects that provide named properties with optional getter/setter
		//		control and the ability to watch for property changes
		//
		//		The class also provides the functionality to auto-magically manage getters
		//		and setters for object attributes/properties.
		//		
		//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
		//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
		//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
		//
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var obj = new Stateful();
		//	|		obj.watch("foo", function(){
		//	|			console.log("foo changed to " + this.get("foo"));
		//	|		});
		//	|		obj.set("foo","bar");
		//	|	});
	
		// _attrPairNames: Hash
		//		Used across all instances a hash to cache attribute names and their getter 
		//		and setter names.
		_attrPairNames: {},
	
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private
	
			var apn = this._attrPairNames;
			if(apn[name]){ return apn[name]; }
			return (apn[name] = {
				s: "_" + name + "Setter",
				g: "_" + name + "Getter"
			});
		},
	
		postscript: function(/*Object?*/ params){
			// Automatic setting of params during construction
			if (params){ this.set(params); }
		},
	
		_get: function(name, names){
			// summary:
			//		Private function that does a get based off a hash of names
			// names:
			//		Hash of names of custom attributes
			return typeof this[names.g] === "function" ? this[names.g]() : this[name];
		},
		get: function(/*String*/name){
			// summary:
			//		Get a property on a Stateful instance.
			// name:
			//		The property to get.
			// returns:
			//		The property value on this Stateful instance.
			// description:
			//		Get a named property on a Stateful object. The property may
			//		potentially be retrieved via a getter method in subclasses. In the base class
			//		this just retrieves the object's property.
			// example:
			//	|	require(["dojo/Stateful", function(Stateful) {
			//	|		var stateful = new Stateful({foo: 3});
			//	|		stateful.get("foo") // returns 3
			//	|		stateful.foo // returns 3
			//	|	});
	
			return this._get(name, this._getAttrNames(name)); //Any
		},
		set: function(/*String*/name, /*Object*/value){
			// summary:
			//		Set a property on a Stateful instance
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// returns:
			//		The function returns this dojo.Stateful instance.
			// description:
			//		Sets named properties on a stateful object and notifies any watchers of
			//		the property. A programmatic setter may be defined in subclasses.
			// example:
			//	|	require(["dojo/Stateful", function(Stateful) {
			//	|		var stateful = new Stateful();
			//	|		stateful.watch(function(name, oldValue, value){
			//	|			// this will be called on the set below
			//	|		}
			//	|		stateful.set(foo, 5);
			//	set() may also be called with a hash of name/value pairs, ex:
			//	|		stateful.set({
			//	|			foo: "Howdy",
			//	|			bar: 3
			//	|		});
			//	|	});
			//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
	
			// If an object is used, iterate through object
			if(typeof name === "object"){
				for(var x in name){
					if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
						this.set(x, name[x]);
					}
				}
				return this;
			}
	
			var names = this._getAttrNames(name),
				oldValue = this._get(name, names),
				setter = this[names.s],
				result;
			if(typeof setter === "function"){
				// use the explicit setter
				result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// no setter so set attribute directly
				this[name] = value;
			}
			if(this._watchCallbacks){
				var self = this;
				// If setter returned a promise, wait for it to complete, otherwise call watches immediately
				when(result, function(){
					self._watchCallbacks(name, oldValue, value);
				});
			}
			return this; // dojo/Stateful
		},
		_changeAttrValue: function(name, value){
			// summary:
			//		Internal helper for directly changing an attribute value.
			//
			// name: String
			//		The property to set.
			// value: Mixed
			//		The value to set in the property.
			//
			// description:
			//		Directly change the value of an attribute on an object, bypassing any 
			//		accessor setter.  Also handles the calling of watch and emitting events. 
			//		It is designed to be used by descendant class when there are two values 
			//		of attributes that are linked, but calling .set() is not appropriate.
	
			var oldValue = this.get(name);
			this[name] = value;
			if(this._watchCallbacks){
				this._watchCallbacks(name, oldValue, value);
			}
			return this; // dojo/Stateful
		},
		watch: function(/*String?*/name, /*Function*/callback){
			// summary:
			//		Watches a property for changes
			// name:
			//		Indicates the property to watch. This is optional (the callback may be the
			//		only parameter), and if omitted, all the properties will be watched
			// returns:
			//		An object handle for the watch. The unwatch method of this object
			//		can be used to discontinue watching this property:
			//		|	var watchHandle = obj.watch("foo", callback);
			//		|	watchHandle.unwatch(); // callback won't be called now
			// callback:
			//		The function to execute when the property changes. This will be called after
			//		the property has been changed. The callback will be called with the |this|
			//		set to the instance, the first argument as the name of the property, the
			//		second argument as the old value and the third argument as the new value.
	
			var callbacks = this._watchCallbacks;
			if(!callbacks){
				var self = this;
				callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
					var notify = function(propertyCallbacks){
						if(propertyCallbacks){
							propertyCallbacks = propertyCallbacks.slice();
							for(var i = 0, l = propertyCallbacks.length; i < l; i++){
								propertyCallbacks[i].call(self, name, oldValue, value);
							}
						}
					};
					notify(callbacks['_' + name]);
					if(!ignoreCatchall){
						notify(callbacks["*"]); // the catch-all
					}
				}; // we use a function instead of an object so it will be ignored by JSON conversion
			}
			if(!callback && typeof name === "function"){
				callback = name;
				name = "*";
			}else{
				// prepend with dash to prevent name conflicts with function (like "name" property)
				name = '_' + name;
			}
			var propertyCallbacks = callbacks[name];
			if(typeof propertyCallbacks !== "object"){
				propertyCallbacks = callbacks[name] = [];
			}
			propertyCallbacks.push(callback);
	
			// TODO: Remove unwatch in 2.0
			var handle = {};
			handle.unwatch = handle.remove = function(){
				var index = array.indexOf(propertyCallbacks, callback);
				if(index > -1){
					propertyCallbacks.splice(index, 1);
				}
			};
			return handle; //Object
		}
	
	});
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(19),
		__webpack_require__(1),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, aspect, declare,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/Destroyable", (function(){
	
		// module:
		//		dijit/Destroyable
	
		return declare("dijit.Destroyable", null, {
			// summary:
			//		Mixin to track handles and release them when instance is destroyed.
			// description:
			//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
			//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
			//		Then call destroy() later to destroy this instance and release the resources.
	
			destroy: function(/*Boolean*/ preserveDom){
				// summary:
				//		Destroy this class, releasing any resources registered via own().
				this._destroyed = true;
			},
	
			own: function(){
				// summary:
				//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
				//		already removed/destroyed manually.
				// tags:
				//		protected
				// returns:
				//		The array of specified handles, so you can do for example:
				//	|		var handle = this.own(on(...))[0];
	
				var cleanupMethods = [
					"destroyRecursive",
					"destroy",
					"remove"
				];
	
				array.forEach(arguments, function(handle){
					// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
					// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
					// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
					// onDestroy() method and connect to that instead.
					var destroyMethodName;
					var odh = aspect.before(this, "destroy", function (preserveDom){
						handle[destroyMethodName](preserveDom);
					});
	
					// Callback for when handle is manually destroyed.
					var hdhs = [];
					function onManualDestroy(){
						odh.remove();
						array.forEach(hdhs, function(hdh){
							hdh.remove();
						});
					}
	
					// Setup listeners for manual destroy of handle.
					// Also computes destroyMethodName, used in listener above.
					if(handle.then){
						// Special path for Promises.  Detect when Promise is resolved, rejected, or
						// canceled (nb: cancelling a Promise causes it to be rejected).
						destroyMethodName = "cancel";
						handle.then(onManualDestroy, onManualDestroy);
					}else{
						// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
						array.forEach(cleanupMethods, function(cleanupMethod){
							if(typeof handle[cleanupMethod] === "function"){
								if(!destroyMethodName){
									// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
									destroyMethodName = cleanupMethod;
								}
								hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
							}
						});
					}
				}, this);
	
				return arguments;		// handle
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(12), 
		__webpack_require__(75),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, win, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/registry", (function(){
	
		// module:
		//		dijit/registry
	
		var _widgetTypeCtr = {}, hash = {};
	
		var registry =  {
			// summary:
			//		Registry of existing widget on page, plus some utility methods.
	
			// length: Number
			//		Number of registered widgets
			length: 0,
	
			add: function(widget){
				// summary:
				//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
				// widget: dijit/_WidgetBase
				//		Any dijit/_WidgetBase subclass.
				if(hash[widget.id]){
					throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
				}
				hash[widget.id] = widget;
				this.length++;
			},
	
			remove: function(/*String*/ id){
				// summary:
				//		Remove a widget from the registry. Does not destroy the widget; simply
				//		removes the reference.
				if(hash[id]){
					delete hash[id];
					this.length--;
				}
			},
	
			byId: function(/*String|Widget*/ id){
				// summary:
				//		Find a widget by it's id.
				//		If passed a widget then just returns the widget.
				return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
			},
	
			byNode: function(/*DOMNode*/ node){
				// summary:
				//		Returns the widget corresponding to the given DOMNode
				return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
			},
	
			toArray: function(){
				// summary:
				//		Convert registry into a true Array
				//
				// example:
				//		Work with the widget .domNodes in a real Array
				//		|	array.map(registry.toArray(), function(w){ return w.domNode; });
	
				var ar = [];
				for(var id in hash){
					ar.push(hash[id]);
				}
				return ar;	// dijit/_WidgetBase[]
			},
	
			getUniqueId: function(/*String*/widgetType){
				// summary:
				//		Generates a unique id for a given widgetType
	
				var id;
				do{
					id = widgetType + "_" +
						(widgetType in _widgetTypeCtr ?
							++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
				}while(hash[id]);
				return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
			},
	
			findWidgets: function(root, skipNode){
				// summary:
				//		Search subtree under root returning widgets found.
				//		Doesn't search for nested widgets (ie, widgets inside other widgets).
				// root: DOMNode
				//		Node to search under.
				// skipNode: DOMNode
				//		If specified, don't search beneath this node (usually containerNode).
	
				var outAry = [];
	
				function getChildrenHelper(root){
					for(var node = root.firstChild; node; node = node.nextSibling){
						if(node.nodeType == 1){
							var widgetId = node.getAttribute("widgetId");
							if(widgetId){
								var widget = hash[widgetId];
								if(widget){	// may be null on page w/multiple dojo's loaded
									outAry.push(widget);
								}
							}else if(node !== skipNode){
								getChildrenHelper(node);
							}
						}
					}
				}
	
				getChildrenHelper(root);
				return outAry;
			},
	
			_destroyAll: function(){
				// summary:
				//		Code to destroy all widgets and do other cleanup on page unload
	
				// Clean up focus manager lingering references to widgets and nodes
				dijit._curFocus = null;
				dijit._prevFocus = null;
				dijit._activeStack = [];
	
				// Destroy all the widgets, top down
				array.forEach(registry.findWidgets(win.body()), function(widget){
					// Avoid double destroy of widgets like Menu that are attached to <body>
					// even though they are logically children of other widgets.
					if(!widget._destroyed){
						if(widget.destroyRecursive){
							widget.destroyRecursive();
						}else if(widget.destroy){
							widget.destroy();
						}
					}
				});
			},
	
			getEnclosingWidget: function(/*DOMNode*/ node){
				// summary:
				//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
				//		the node is not contained within the DOM tree of any widget
				while(node){
					var id = node.nodeType == 1 && node.getAttribute("widgetId");
					if(id){
						return hash[id];
					}
					node = node.parentNode;
				}
				return null;
			},
	
			// In case someone needs to access hash.
			// Actually, this is accessed from WidgetSet back-compatibility code
			_hash: hash
		};
	
		dijit.registry = registry;
	
		return registry;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(2),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/main", (function(){
		// module:
		//		dijit/main
	
	/*=====
	return {
		// summary:
		//		The dijit package main module.
		//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
	};
	=====*/
	
		return dojo.dijit;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(77),	
		__webpack_require__(1), 
		__webpack_require__(11), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(9), 
		__webpack_require__(79), 
		__webpack_require__(80),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_TemplatedMixin", (function(){
	
		// module:
		//		dijit/_TemplatedMixin
	
		var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
			// summary:
			//		Mixin for widgets that are instantiated from a template
	
			// templateString: [protected] String
			//		A string that represents the widget template.
			//		Use in conjunction with dojo.cache() to load from a file.
			templateString: null,
	
			// templatePath: [protected deprecated] String
			//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
			//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
			templatePath: null,
	
			// skipNodeCache: [protected] Boolean
			//		If using a cached widget template nodes poses issues for a
			//		particular widget class, it can set this property to ensure
			//		that its template is always re-built from a string
			_skipNodeCache: false,
	
	/*=====
			// _rendered: Boolean
			//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
			//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
			//		just function like _AttachMixin.
			_rendered: false,
	=====*/
	
			// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
			// and events inside this.containerNode.   Remove for 2.0.
			searchContainerNode: true,
	
			_stringRepl: function(tmpl){
				// summary:
				//		Does substitution of ${foo} type properties in template string
				// tags:
				//		private
				var className = this.declaredClass, _this = this;
				// Cache contains a string because we need to do property replacement
				// do the property replacement
				return string.substitute(tmpl, this, function(value, key){
					if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
					if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
					if(value == null){ return ""; }
	
					// Substitution keys beginning with ! will skip the transform step,
					// in case a user wishes to insert unescaped markup, e.g. ${!foo}
					return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
				}, this);
			},
	
			_escapeValue: function(/*String*/ val){
				// summary:
				//		Escape a value to be inserted into the template, either into an attribute value
				//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)
	
				// Safer substitution, see heading "Attribute values" in
				// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
				// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
				return val.replace(/["'<>&]/g, function(val){
					return {
						"&": "&amp;",
						"<": "&lt;",
						">": "&gt;",
						"\"": "&quot;",
						"'": "&#x27;"
					}[val];
				});
			},
	
			buildRendering: function(){
				// summary:
				//		Construct the UI for this widget from a template, setting this.domNode.
				// tags:
				//		protected
	
				if(!this._rendered){
					if(!this.templateString){
						this.templateString = cache(this.templatePath, {sanitize: true});
					}
	
					// Lookup cached version of template, and download to cache if it
					// isn't there already.  Returns either a DomNode or a string, depending on
					// whether or not the template contains ${foo} replacement parameters.
					var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);
	
					var node;
					if(lang.isString(cached)){
						node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
						if(node.nodeType != 1){
							// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
							throw new Error("Invalid template: " + cached);
						}
					}else{
						// if it's a node, all we have to do is clone it
						node = cached.cloneNode(true);
					}
	
					this.domNode = node;
				}
	
				// Call down to _WidgetBase.buildRendering() to get base classes assigned
				// TODO: change the baseClass assignment to _setBaseClassAttr
				this.inherited(arguments);
	
				if(!this._rendered){
					this._fillContent(this.srcNodeRef);
				}
	
				this._rendered = true;
			},
	
			_fillContent: function(/*DomNode*/ source){
				// summary:
				//		Relocate source contents to templated container node.
				//		this.containerNode must be able to receive children, or exceptions will be thrown.
				// tags:
				//		protected
				var dest = this.containerNode;
				if(source && dest){
					while(source.hasChildNodes()){
						dest.appendChild(source.firstChild);
					}
				}
			}
	
		});
	
		// key is templateString; object is either string or DOM tree
		_TemplatedMixin._templateCache = {};
	
		_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
			// summary:
			//		Static method to get a template based on the templatePath or
			//		templateString key
			// templateString: String
			//		The template
			// alwaysUseString: Boolean
			//		Don't cache the DOM tree for this template, even if it doesn't have any variables
			// doc: Document?
			//		The target document.   Defaults to document global if unspecified.
			// returns: Mixed
			//		Either string (if there are ${} variables that need to be replaced) or just
			//		a DOM tree (if the node can be cloned directly)
	
			// is it already cached?
			var tmplts = _TemplatedMixin._templateCache;
			var key = templateString;
			var cached = tmplts[key];
			if(cached){
				try{
					// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
					// current document, then use the current cached value
					if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
						// string or node of the same document
						return cached;
					}
				}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
				domConstruct.destroy(cached);
			}
	
			templateString = string.trim(templateString);
	
			if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
				// there are variables in the template so all we can do is cache the string
				return (tmplts[key] = templateString); //String
			}else{
				// there are no variables in the template so we can cache the DOM tree
				var node = domConstruct.toDom(templateString, doc);
				if(node.nodeType != 1){
					throw new Error("Invalid template: " + templateString);
				}
				return (tmplts[key] = node); //Node
			}
		};
	
		if(has("ie")){
			on(window, "unload", function(){
				var cache = _TemplatedMixin._templateCache;
				for(var key in cache){
					var value = cache[key];
					if(typeof value == "object"){ // value is either a string or a DOM node template
						domConstruct.destroy(value);
					}
					delete cache[key];
				}
			});
		}
	
		return _TemplatedMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(78)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo){
		// module:
		//		dojo/cache
	
		// dojo.cache is defined in dojo/text
		return dojo.cache;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(6), __webpack_require__(4), __webpack_require__(39)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, require, has, request){
		// module:
		//		dojo/text
	
		var getText;
		if(has("host-browser")){
			getText= function(url, sync, load){
				request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
			};
		}else{
			// Path for node.js and rhino, to load from local file system.
			// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
			if(require.getText){
				getText= require.getText;
			}else{
				console.error("dojo/text plugin failed to load because loader does not support getText");
			}
		}
	
		var
			theCache = {},
	
			strip= function(text){
				//Strips <?xml ...?> declarations so that external SVG and XML
				//documents can be added to a document without worry. Also, if the string
				//is an HTML document, only the part inside the body tag is returned.
				if(text){
					text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
					var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
					if(matches){
						text= matches[1];
					}
				}else{
					text = "";
				}
				return text;
			},
	
			notFound = {},
	
			pending = {};
	
		dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
			// summary:
			//		A getter and setter for storing the string content associated with the
			//		module and url arguments.
			// description:
			//		If module is a string that contains slashes, then it is interpretted as a fully
			//		resolved path (typically a result returned by require.toUrl), and url should not be
			//		provided. This is the preferred signature. If module is a string that does not
			//		contain slashes, then url must also be provided and module and url are used to
			//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
			//		If value is specified, the cache value for the moduleUrl will be set to
			//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
			//		in its internal cache and return that cached value for the URL. To clear
			//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
			//		the URL contents, only modules on the same domain of the page can use this capability.
			//		The build system can inline the cache values though, to allow for xdomain hosting.
			// module: String||Object
			//		If a String with slashes, a fully resolved path; if a String without slashes, the
			//		module name to use for the base part of the URL, similar to module argument
			//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
			//		generates a valid path for the cache item. For example, a dojo._Url object.
			// url: String
			//		The rest of the path to append to the path derived from the module argument. If
			//		module is an object, then this second argument should be the "value" argument instead.
			// value: String||Object?
			//		If a String, the value to use in the cache for the module/url combination.
			//		If an Object, it can have two properties: value and sanitize. The value property
			//		should be the value to use in the cache, and sanitize can be set to true or false,
			//		to indicate if XML declarations should be removed from the value and if the HTML
			//		inside a body tag in the value should be extracted as the real value. The value argument
			//		or the value property on the value argument are usually only used by the build system
			//		as it inlines cache content.
			// example:
			//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
			//		of call is used to avoid an issue with the build system erroneously trying to intern
			//		this example. To get the build system to intern your dojo.cache calls, use the
			//		"dojo.cache" style of call):
			//		| //If template.html contains "<h1>Hello</h1>" that will be
			//		| //the value for the text variable.
			//		| //Note: This is pre-AMD, deprecated syntax
			//		| var text = dojo["cache"]("my.module", "template.html");
			// example:
			//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
			//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
			//		erroneously trying to intern this example. To get the build system to intern your
			//		dojo.cache calls, use the "dojo.cache" style of call):
			//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
			//		| //text variable will contain just "<h1>Hello</h1>".
			//		| //Note: This is pre-AMD, deprecated syntax
			//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
			// example:
			//		Same example as previous, but demonstrates how an object can be passed in as
			//		the first argument, then the value argument can then be the second argument.
			//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
			//		| //text variable will contain just "<h1>Hello</h1>".
			//		| //Note: This is pre-AMD, deprecated syntax
			//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});
	
			//	 * (string string [value]) => (module, url, value)
			//	 * (object [value])        => (module, value), url defaults to ""
			//
			//	 * if module is an object, then it must be convertable to a string
			//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
			//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
			var key;
			if(typeof module=="string"){
				if(/\//.test(module)){
					// module is a version 1.7+ resolved path
					key = module;
					value = url;
				}else{
					// module is a version 1.6- argument to dojo.moduleUrl
					key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
				}
			}else{
				key = module + "";
				value = url;
			}
			var
				val = (value != undefined && typeof value != "string") ? value.value : value,
				sanitize = value && value.sanitize;
	
			if(typeof val == "string"){
				//We have a string, set cache value
				theCache[key] = val;
				return sanitize ? strip(val) : val;
			}else if(val === null){
				//Remove cached value
				delete theCache[key];
				return null;
			}else{
				//Allow cache values to be empty strings. If key property does
				//not exist, fetch it.
				if(!(key in theCache)){
					getText(key, true, function(text){
						theCache[key]= text;
					});
				}
				return sanitize ? strip(theCache[key]) : theCache[key];
			}
		};
	
		return {
			// summary:
			//		This module implements the dojo/text! plugin and the dojo.cache API.
			// description:
			//		We choose to include our own plugin to leverage functionality already contained in dojo
			//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
			//		Also, this allows foreign AMD loaders to be used without their plugins.
			//
			//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
			//		loader. This feature is outside the scope of the CommonJS plugins specification.
	
			// the dojo/text caches it's own resources because of dojo.cache
			dynamic: true,
	
			normalize: function(id, toAbsMid){
				// id is something like (path may be relative):
				//
				//	 "path/to/text.html"
				//	 "path/to/text.html!strip"
				var parts= id.split("!"),
					url= parts[0];
				return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
			},
	
			load: function(id, require, load){
				// id: String
				//		Path to the resource.
				// require: Function
				//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
				// load: Function
				//		Callback function which will be called, when the loading finished.
	
				// id is something like (path is always absolute):
				//
				//	 "path/to/text.html"
				//	 "path/to/text.html!strip"
				var
					parts= id.split("!"),
					stripFlag= parts.length>1,
					absMid= parts[0],
					url = require.toUrl(parts[0]),
					requireCacheUrl = "url:" + url,
					text = notFound,
					finish = function(text){
						load(stripFlag ? strip(text) : text);
					};
				if(absMid in theCache){
					text = theCache[absMid];
				}else if(require.cache && requireCacheUrl in require.cache){
					text = require.cache[requireCacheUrl];
				}else if(url in theCache){
					text = theCache[url];
				}
				if(text===notFound){
					if(pending[url]){
						pending[url].push(finish);
					}else{
						var pendingList = pending[url] = [finish];
						getText(url, !require.async, function(text){
							theCache[absMid]= theCache[url]= text;
							for(var i = 0; i<pendingList.length;){
								pendingList[i++](text);
							}
							delete pending[url];
						});
					}
				}else{
					finish(text);
				}
			}
		};
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(2),	
		__webpack_require__(8)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(kernel, lang){
	
	// module:
	//		dojo/string
	var ESCAPE_REGEXP = /[&<>'"\/]/g;
	var ESCAPE_MAP = {
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;',
		'"': '&quot;',
		"'": '&#x27;',
		'/': '&#x2F;'
	};
	var string = {
		// summary:
		//		String utilities for Dojo
	};
	lang.setObject("dojo.string", string);
	
	string.escape = function(/*String*/str){
		// summary:
		//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
		// str:
		//		the string to escape
		if(!str){ return ""; }
		return str.replace(ESCAPE_REGEXP, function(c) {
			return ESCAPE_MAP[c];
		});
	};
	
	string.rep = function(/*String*/str, /*Integer*/num){
		// summary:
		//		Efficiently replicate a string `n` times.
		// str:
		//		the string to replicate
		// num:
		//		number of times to replicate the string
	
		if(num <= 0 || !str){ return ""; }
	
		var buf = [];
		for(;;){
			if(num & 1){
				buf.push(str);
			}
			if(!(num >>= 1)){ break; }
			str += str;
		}
		return buf.join("");	// String
	};
	
	string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
		// summary:
		//		Pad a string to guarantee that it is at least `size` length by
		//		filling with the character `ch` at either the start or end of the
		//		string. Pads at the start, by default.
		// text:
		//		the string to pad
		// size:
		//		length to provide padding
		// ch:
		//		character to pad, defaults to '0'
		// end:
		//		adds padding at the end if true, otherwise pads at start
		// example:
		//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
		//	|	string.pad("Dojo", 10, "+", true);
	
		if(!ch){
			ch = '0';
		}
		var out = String(text),
			pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
		return end ? out + pad : pad + out;	// String
	};
	
	string.substitute = function(	/*String*/		template,
										/*Object|Array*/map,
										/*Function?*/	transform,
										/*Object?*/		thisObject){
		// summary:
		//		Performs parameterized substitutions on a string. Throws an
		//		exception if any parameter is unmatched.
		// template:
		//		a string with expressions in the form `${key}` to be replaced or
		//		`${key:format}` which specifies a format function. keys are case-sensitive.
		//		The special sequence `${}` can be used escape `$`.
		// map:
		//		hash to search for substitutions
		// transform:
		//		a function to process all parameters before substitution takes
		//		place, e.g. mylib.encodeXML
		// thisObject:
		//		where to look for optional format function; default to the global
		//		namespace
		// example:
		//		Substitutes two expressions in a string from an Array or Object
		//	|	// returns "File 'foo.html' is not found in directory '/temp'."
		//	|	// by providing substitution data in an Array
		//	|	string.substitute(
		//	|		"File '${0}' is not found in directory '${1}'.",
		//	|		["foo.html","/temp"]
		//	|	);
		//	|
		//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
		//	|	// but provides substitution data in an Object structure.  Dotted
		//	|	// notation may be used to traverse the structure.
		//	|	string.substitute(
		//	|		"File '${name}' is not found in directory '${info.dir}'.",
		//	|		{ name: "foo.html", info: { dir: "/temp" } }
		//	|	);
		// example:
		//		Use a transform function to modify the values:
		//	|	// returns "file 'foo.html' is not found in directory '/temp'."
		//	|	string.substitute(
		//	|		"${0} is not found in ${1}.",
		//	|		["foo.html","/temp"],
		//	|		function(str){
		//	|			// try to figure out the type
		//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
		//	|			return prefix + " '" + str + "'";
		//	|		}
		//	|	);
		// example:
		//		Use a formatter
		//	|	// returns "thinger -- howdy"
		//	|	string.substitute(
		//	|		"${0:postfix}", ["thinger"], null, {
		//	|			postfix: function(value, key){
		//	|				return value + " -- howdy";
		//	|			}
		//	|		}
		//	|	);
	
		thisObject = thisObject || kernel.global;
		transform = transform ?
			lang.hitch(thisObject, transform) : function(v){ return v; };
	
		return template.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g,
			function(match, key, format){
				if (key == ''){
					return '$';
				}
				var value = lang.getObject(key, false, map);
				if(format){
					value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
				}
				return transform(value, key).toString();
			}); // String
	};
	
	string.trim = String.prototype.trim ?
		lang.trim : // aliasing to the native function
		function(str){
			str = str.replace(/^\s+/, '');
			for(var i = str.length - 1; i >= 0; i--){
				if(/\S/.test(str.charAt(i))){
					str = str.substring(0, i + 1);
					break;
				}
			}
			return str;
		};
	
	/*=====
	 string.trim = function(str){
		 // summary:
		 //		Trims whitespace from both sides of the string
		 // str: String
		 //		String to be trimmed
		 // returns: String
		 //		Returns the trimmed string
		 // description:
		 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
		 //		The short yet performant version of this function is dojo/_base/lang.trim(),
		 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
		 return "";	// String
	 };
	 =====*/
	
		return string;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(6),
		__webpack_require__(28), 
		__webpack_require__(17),	
		__webpack_require__(1), 
		__webpack_require__(8), 
		__webpack_require__(24),
		__webpack_require__(18),
		__webpack_require__(81),
		__webpack_require__(69),__webpack_require__(82),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase,a11yclick,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_AttachMixin", (function(){
	
		// module:
		//		dijit/_AttachMixin
	
		// Map from string name like "mouseenter" to synthetic event like mouse.enter
		var synthEvents = lang.delegate(touch, {
			"mouseenter": mouse.enter,
			"mouseleave": mouse.leave,
			"keypress": connect._keypress	// remove for 2.0
		});
	
		// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
		// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
		// In that case, the a11yclick variable below will get set to point to that synthetic event.
		
	
		var _AttachMixin = declare("dijit._AttachMixin", null, {
			// summary:
			//		Mixin for widgets to attach to dom nodes and setup events via
			//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
			//
			//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
			//		server.
			//
			//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
			//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
			//		doesn't.
	
	/*=====
			// _attachPoints: [private] String[]
			//		List of widget attribute names associated with data-dojo-attach-point=... in the
			//		template, ex: ["containerNode", "labelNode"]
			_attachPoints: [],
	
			// _attachEvents: [private] Handle[]
			//		List of connections associated with data-dojo-attach-event=... in the
			//		template
			_attachEvents: [],
	
			// attachScope: [public] Object
			//		Object to which attach points and events will be scoped.  Defaults
			//		to 'this'.
			attachScope: undefined,
	
			// searchContainerNode: [protected] Boolean
			//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
			//		Should generally be left false (the default value) both for performance and to avoid failures when
			//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
	 		searchContainerNode: false,
	 =====*/
	
			constructor: function(/*===== params, srcNodeRef =====*/){
				// summary:
				//		Create the widget.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String?
				//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.
	
				this._attachPoints = [];
				this._attachEvents = [];
			},
	
	
			buildRendering: function(){
				// summary:
				//		Attach to DOM nodes marked with special attributes.
				// tags:
				//		protected
	
				this.inherited(arguments);
	
				// recurse through the node, looking for, and attaching to, our
				// attachment points and events, which should be defined on the template node.
				this._attachTemplateNodes(this.domNode);
	
				this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
			},
	
			_beforeFillContent: function(){
			},
	
			_attachTemplateNodes: function(rootNode){
				// summary:
				//		Iterate through the dom nodes and attach functions and nodes accordingly.
				// description:
				//		Map widget properties and functions to the handlers specified in
				//		the dom node and it's descendants. This function iterates over all
				//		nodes and looks for these properties:
				//
				//		- dojoAttachPoint/data-dojo-attach-point
				//		- dojoAttachEvent/data-dojo-attach-event
				// rootNode: DomNode
				//		The node to search for properties. All descendants will be searched.
				// tags:
				//		private
	
				// DFS to process all nodes except those inside of this.containerNode
				var node = rootNode;
				while(true){
					if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
							this._attach) || this.searchContainerNode) && node.firstChild){
						node = node.firstChild;
					}else{
						if(node == rootNode){ return; }
						while(!node.nextSibling){
							node = node.parentNode;
							if(node == rootNode){ return; }
						}
						node = node.nextSibling;
					}
				}
			},
	
			_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
				// summary:
				//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
				//		Returns true if caller should process baseNode's children too.
	
				var ret = true;
	
				// Process data-dojo-attach-point
				var _attachScope = this.attachScope || this,
					attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(lang.isArray(_attachScope[point])){
							_attachScope[point].push(baseNode);
						}else{
							_attachScope[point] = baseNode;
						}
						ret = (point != "containerNode");
						this._attachPoints.push(point);
					}
				}
	
				// Process data-dojo-attach-event
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent, ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = lang.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
	
							this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
						}
					}
				}
	
				return ret;
			},
	
			_attach: function(node, type, func){
				// summary:
				//		Roughly corresponding to dojo/on, this is the default function for processing a
				//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
				// node: DOMNode
				//		The node to setup a listener on.
				// type: String
				//		Event name like "click".
				// getAttrFunc: Function
				//		Function to get the specified property for a given DomNode/Widget.
				// attachFunc: Function?
				//		Attaches an event handler from the specified node/widget to specified function.
	
				// Map special type names like "mouseenter" to synthetic events.
				// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
				type = type.replace(/^on/, "").toLowerCase();
				if(type == "dijitclick"){
					type = a11yclick || (a11yclick = require("./a11yclick"));
				}else{
					type = synthEvents[type] || type;
				}
	
				return on(node, type, func);
			},
	
			_detachTemplateNodes: function() {
				// summary:
				//		Detach and clean up the attachments made in _attachtempalteNodes.
	
				// Delete all attach points to prevent IE6 memory leaks.
				var _attachScope = this.attachScope || this;
				array.forEach(this._attachPoints, function(point){
					delete _attachScope[point];
				});
				this._attachPoints = [];
	
				// And same for event handlers
				array.forEach(this._attachEvents, function(handle){ handle.remove(); });
				this._attachEvents = [];
			},
	
			destroyRendering: function(){
				this._detachTemplateNodes();
				this.inherited(arguments);
			}
		});
	
		// These arguments can be specified for widgets which are used in templates.
		// Since any widget can be specified as sub widgets in template, mix it
		// into the base widget class.  (This is a hack, but it's effective.).
		// Remove for 2.0.   Also, hide from API doc parser.
		lang.extend(_WidgetBase, /*===== {} || =====*/ {
			dojoAttachEvent: "",
			dojoAttachPoint: ""
		});
		
		return _AttachMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(19), __webpack_require__(13), __webpack_require__(27), __webpack_require__(8), __webpack_require__(18), __webpack_require__(4), __webpack_require__(24), __webpack_require__(71), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){
	
		// module:
		//		dojo/touch
	
		var ios4 = has("ios") < 5;
	
		// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
		var hasPointer = has("pointer-events") || has("MSPointer"),
			pointer = (function () {
				var pointer = {};
				for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
					pointer[type] = has("MSPointer") ?
						"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
						"pointer" + type;
				}
				return pointer;
			})();
	
		// Detect if platform supports the webkit touchstart/touchend/... events
		var hasTouch = has("touch-events");
	
		// Click generation variables
		var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;
	
		// Time of most recent touchstart, touchmove, or touchend event
		var lastTouch;
	
		function dualEvent(mouseType, touchType, pointerType){
			// Returns synthetic event that listens for both the specified mouse event and specified touch event.
			// But ignore fake mouse events that were generated due to the user touching the screen.
			if(hasPointer && pointerType){
				// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
				// so just use that regardless of hasTouch.
				return function(node, listener){
					return on(node, pointerType, listener);
				};
			}else if(hasTouch){
				return function(node, listener){
					var handle1 = on(node, touchType, function(evt){
							listener.call(this, evt);
	
							// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
							// a handler for a touch event may take >1s to run.  That time shouldn't
							// be included in the calculation for lastTouch.
							lastTouch = (new Date()).getTime();
						}),
						handle2 = on(node, mouseType, function(evt){
							if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
								listener.call(this, evt);
							}
						});
					return {
						remove: function(){
							handle1.remove();
							handle2.remove();
						}
					};
				};
			}else{
				// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
				return function(node, listener){
					return on(node, mouseType, listener);
				};
			}
		}
	
		function marked(/*DOMNode*/ node){
			// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
			// Returns marked ancestor.
			do{
				if(node.dojoClick !== undefined){ return node; }
			}while(node = node.parentNode);
		}
	
		function doClicks(e, moveType, endType){
			// summary:
			//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
			//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
			//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
			//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
			//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
			//      to falsy.
	
			if(mouse.isRight(e)){
				return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
			}
	
			var markedNode = marked(e.target);
			clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
			if(clickTracker){
				useTarget = (clickTracker == "useTarget");
				clickTarget = (useTarget?markedNode:e.target);
				if(useTarget){
					// We expect a click, so prevent any other
					// default action on "touchpress"
					e.preventDefault();
				}
				clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
				clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
				clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
				clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
	
				// add move/end handlers only the first time a node with dojoClick is seen,
				// so we don't add too much overhead when dojoClick is never set.
				if(!clicksInited){
					clicksInited = true;
	
					function updateClickTracker(e){
						if(useTarget){
							clickTracker = dom.isDescendant(
								win.doc.elementFromPoint(
									(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
									(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
								clickTarget);
						}else{
							clickTracker = clickTracker &&
								(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
								Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
								Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
						}
					}
	
					win.doc.addEventListener(moveType, function(e){
						if(mouse.isRight(e)){
							return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
						}
						updateClickTracker(e);
						if(useTarget){
							// prevent native scroll event and ensure touchend is
							// fire after touch moves between press and release.
							e.preventDefault();
						}
					}, true);
	
					win.doc.addEventListener(endType, function(e){
						if(mouse.isRight(e)){
							return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
						}
						updateClickTracker(e);
						if(clickTracker){
							clickTime = (new Date()).getTime();
							var target = (useTarget?clickTarget:e.target);
							if(target.tagName === "LABEL"){
								// when clicking on a label, forward click to its associated input if any
								target = dom.byId(target.getAttribute("for")) || target;
							}
							//some attributes can be on the Touch object, not on the Event:
							//http://www.w3.org/TR/touch-events/#touch-interface
							var src = (e.changedTouches) ? e.changedTouches[0] : e;
							function createMouseEvent(type){
								//create the synthetic event.
								//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
								var evt = document.createEvent("MouseEvents");
								evt._dojo_click = true;
								evt.initMouseEvent(type,
									true, //bubbles
									true, //cancelable
									e.view,
									e.detail,
									src.screenX,
									src.screenY,
									src.clientX,
									src.clientY,
									e.ctrlKey,
									e.altKey,
									e.shiftKey,
									e.metaKey,
									0, //button
									null //related target
								);
								return evt;
							}
							var mouseDownEvt = createMouseEvent("mousedown");
							var mouseUpEvt = createMouseEvent("mouseup");
							var clickEvt = createMouseEvent("click");
	
							setTimeout(function(){
								on.emit(target, "mousedown", mouseDownEvt);
								on.emit(target, "mouseup", mouseUpEvt);
								on.emit(target, "click", clickEvt);
	
								// refresh clickTime in case app-defined click handler took a long time to run
								clickTime = (new Date()).getTime();
							}, 0);
						}
					}, true);
	
					function stopNativeEvents(type){
						win.doc.addEventListener(type, function(e){
							// Stop native events when we emitted our own click event.  Note that the native click may occur
							// on a different node than the synthetic click event was generated on.  For example,
							// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
							// sends a click event to the node that was *underneath* the menu.  So stop all native events
							// sent shortly after ours, similar to what is done in dualEvent.
							// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
							// we call click() explicitly, we don't want to stop this event.
							var target = e.target;
							if(clickTracker && !e._dojo_click &&
									(new Date()).getTime() <= clickTime + 1000 &&
									!(target.tagName == "INPUT" && domClass.contains(target, "dijitOffScreen"))){
								e.stopPropagation();
								e.stopImmediatePropagation && e.stopImmediatePropagation();
								if(type == "click" &&
									(target.tagName != "INPUT" ||
									(target.type == "radio" &&
										// #18352 Do not preventDefault for radios that are not dijit or
										// dojox/mobile widgets.
										// (The CSS class dijitCheckBoxInput holds for both checkboxes and radio buttons.)
										(domClass.contains(target, "dijitCheckBoxInput") ||
											domClass.contains(target, "mblRadioButton"))) ||
									(target.type == "checkbox" &&
										// #18352 Do not preventDefault for checkboxes that are not dijit or
										// dojox/mobile widgets.
										(domClass.contains(target, "dijitCheckBoxInput") ||
											domClass.contains(target, "mblCheckBox")))) &&
									target.tagName != "TEXTAREA" && target.tagName != "AUDIO" && target.tagName != "VIDEO"){
									// preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
									// but it is still needed for checkboxes and radio buttons, otherwise in some cases
									// the checked state becomes inconsistent with the widget's state
									e.preventDefault();
								}
							}
						}, true);
					}
	
					stopNativeEvents("click");
	
					// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
					// which can confuse some dijit widgets.
					stopNativeEvents("mousedown");
					stopNativeEvents("mouseup");
				}
			}
		}
	
		var hoveredNode;
	
		if(has("touch")){
			if(hasPointer){
				// MSPointer (IE10+) already has support for over and out, so we just need to init click support
				domReady(function(){
					win.doc.addEventListener(pointer.down, function(evt){
						doClicks(evt, pointer.move, pointer.up);
					}, true);
				});
			}else{
				domReady(function(){
					// Keep track of currently hovered node
					hoveredNode = win.body();	// currently hovered node
	
					win.doc.addEventListener("touchstart", function(evt){
							lastTouch = (new Date()).getTime();
	
						// Precede touchstart event with touch.over event.  DnD depends on this.
						// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
						// and to ensure this code runs even if the listener on the node does event.stop().
						var oldNode = hoveredNode;
						hoveredNode = evt.target;
						on.emit(oldNode, "dojotouchout", {
							relatedTarget: hoveredNode,
							bubbles: true
						});
						on.emit(hoveredNode, "dojotouchover", {
							relatedTarget: oldNode,
							bubbles: true
						});
	
						doClicks(evt, "touchmove", "touchend"); // init click generation
					}, true);
	
					function copyEventProps(evt){
						// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
						var props = lang.delegate(evt, {
							bubbles: true
						});
	
						if(has("ios") >= 6){
							// On iOS6 "touches" became a non-enumerable property, which
							// is not hit by for...in.  Ditto for the other properties below.
							props.touches = evt.touches;
							props.altKey = evt.altKey;
							props.changedTouches = evt.changedTouches;
							props.ctrlKey = evt.ctrlKey;
							props.metaKey = evt.metaKey;
							props.shiftKey = evt.shiftKey;
							props.targetTouches = evt.targetTouches;
						}
	
						return props;
					}
	
					on(win.doc, "touchmove", function(evt){
						lastTouch = (new Date()).getTime();
	
						var newNode = win.doc.elementFromPoint(
							evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
							evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
						);
	
						if(newNode){
							// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
							if(hoveredNode !== newNode){
								// touch out on the old node
								on.emit(hoveredNode, "dojotouchout", {
									relatedTarget: newNode,
									bubbles: true
								});
	
								// touchover on the new node
								on.emit(newNode, "dojotouchover", {
									relatedTarget: hoveredNode,
									bubbles: true
								});
	
								hoveredNode = newNode;
							}
	
							// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
							// drags over the specified node, regardless of which node the touch started on.
							if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
								// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
								// default behavior of the underlying native event "touchmove".
								evt.preventDefault();
							}
						}
					});
	
					// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
					// This is different than the native touchend, which fires on the node where the drag started.
					on(win.doc, "touchend", function(evt){
							lastTouch = (new Date()).getTime();
						var node = win.doc.elementFromPoint(
							evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
							evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
						) || win.body(); // if out of the screen
	
						on.emit(node, "dojotouchend", copyEventProps(evt));
					});
				});
			}
		}
	
		//device neutral events - touch.press|move|release|cancel/over/out
		var touch = {
			press: dualEvent("mousedown", "touchstart", pointer.down),
			move: dualEvent("mousemove", "dojotouchmove", pointer.move),
			release: dualEvent("mouseup", "dojotouchend", pointer.up),
			cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
			over: dualEvent("mouseover", "dojotouchover", pointer.over),
			out: dualEvent("mouseout", "dojotouchout", pointer.out),
			enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
			leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
		};
	
		/*=====
		touch = {
			// summary:
			//		This module provides unified touch event handlers by exporting
			//		press, move, release and cancel which can also run well on desktop.
			//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
			//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
			//      click events immediately for this node and its descendants (except for descendants that
			//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
			//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
			//
			// example:
			//		Used with dojo/on
			//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
			//		|		on(node, touch.press, function(e){});
			//		|		on(node, touch.move, function(e){});
			//		|		on(node, touch.release, function(e){});
			//		|		on(node, touch.cancel, function(e){});
			// example:
			//		Used with touch.* directly
			//		|	touch.press(node, function(e){});
			//		|	touch.move(node, function(e){});
			//		|	touch.release(node, function(e){});
			//		|	touch.cancel(node, function(e){});
			// example:
			//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
			//		|	node.dojoClick = true;
			// example:
			//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
			//		|	node.dojoClick = 10;
			// example:
			//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
			//		|	node.dojoClick = {x:50, y:5};
			// example:
			//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
			//		|  node.dojoClick = false;
	
			press: function(node, listener){
				// summary:
				//		Register a listener to 'touchstart'|'mousedown' for the given node
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			move: function(node, listener){
				// summary:
				//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			release: function(node, listener){
				// summary:
				//		Register a listener to releasing the mouse button while the cursor is over the given node
				//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			cancel: function(node, listener){
				// summary:
				//		Register a listener to 'touchcancel'|'mouseleave' for the given node
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			over: function(node, listener){
				// summary:
				//		Register a listener to 'mouseover' or touch equivalent for the given node
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			out: function(node, listener){
				// summary:
				//		Register a listener to 'mouseout' or touch equivalent for the given node
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			enter: function(node, listener){
				// summary:
				//		Register a listener to mouse.enter or touch equivalent for the given node
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			},
			leave: function(node, listener){
				// summary:
				//		Register a listener to mouse.leave or touch equivalent for the given node
				// node: Dom
				//		Target node to listen to
				// listener: Function
				//		Callback function
				// returns:
				//		A handle which will be used to remove the listener by handle.remove()
			}
		};
		=====*/
	
		has("extend-dojo") && (dojo.touch = touch);
	
		return touch;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(26), 
		__webpack_require__(24),
		__webpack_require__(18),
		__webpack_require__(81),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(keys, mouse, on, touch,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/a11yclick", (function(){
	
		// module:
		//		dijit/a11yclick
	
		/*=====
		return {
			// summary:
			//		Custom press, release, and click synthetic events
			//		which trigger on a left mouse click, touch, or space/enter keyup.
	
			click: function(node, listener){
				// summary:
				//		Logical click operation for mouse, touch, or keyboard (space/enter key)
			},
			press: function(node, listener){
				// summary:
				//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
			},
			release: function(node, listener){
				// summary:
				//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
			},
			move: function(node, listener){
				// summary:
				//		Mouse cursor or a finger is dragged over the given node.
			}
		};
		=====*/
	
		function clickKey(/*Event*/ e){
			// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
			// Only track for nodes marked to be tracked, and not for buttons or inputs,
			// since buttons handle keyboard click natively, and text inputs should not
			// prevent typing spaces or newlines.
			if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){
	
				// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
				for(var node = e.target; node; node = node.parentNode){
					if(node.dojoClick){ return true; }
				}
			}
		}
	
		var lastKeyDownNode;
	
		on(document, "keydown", function(e){
			//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
			if(clickKey(e)){
				// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
				lastKeyDownNode = e.target;
	
				// Prevent viewport scrolling on space key in IE<9.
				// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
				e.preventDefault();
			}else{
				lastKeyDownNode = null;
			}
		});
	
		on(document, "keyup", function(e){
			//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
			if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
				//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
				lastKeyDownNode = null;
	
				on.emit(e.target, "click", {
					cancelable: true,
					bubbles: true,
					ctrlKey: e.ctrlKey,
					shiftKey: e.shiftKey,
					metaKey: e.metaKey,
					altKey: e.altKey,
					_origType: e.type
				});
			}
		});
	
		// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
		// needs to be the click event.   Change for 2.0.
	
		var click = function(node, listener){
			// Set flag on node so that keydown/keyup above emits click event.
			// Also enables fast click processing from dojo/touch.
			node.dojoClick = true;
	
			return on(node, "click", listener);
		};
		click.click = click;	// forward compatibility with 2.0
	
		click.press =  function(node, listener){
			var touchListener = on(node, touch.press, function(evt){
				if(evt.type == "mousedown" && !mouse.isLeft(evt)){
					// Ignore right click
					return;
				}
				listener(evt);
			}), keyListener = on(node, "keydown", function(evt){
				if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
					listener(evt);
				}
			});
			return {
				remove: function(){
					touchListener.remove();
					keyListener.remove();
				}
			};
		};
	
		click.release =  function(node, listener){
			var touchListener = on(node, touch.release, function(evt){
				if(evt.type == "mouseup" && !mouse.isLeft(evt)){
					// Ignore right click
					return;
				}
				listener(evt);
			}), keyListener = on(node, "keyup", function(evt){
				if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
					listener(evt);
				}
			});
			return {
				remove: function(){
					touchListener.remove();
					keyListener.remove();
				}
			};
		};
	
		click.move = touch.move;	// just for convenience
	
		return click;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 83 */,
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(6), __webpack_require__(2), __webpack_require__(8), __webpack_require__(28), __webpack_require__(7), __webpack_require__(13), __webpack_require__(12),
			__webpack_require__(85), __webpack_require__(19), __webpack_require__(86), __webpack_require__(87), __webpack_require__(46), __webpack_require__(4), __webpack_require__(34), __webpack_require__(18), __webpack_require__(70)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){
	
		// module:
		//		dojo/parser
	
		new Date("X"); // workaround for #11279, new Date("") == NaN
	
		// data-dojo-props etc. is not restricted to JSON, it can be any javascript
		function myEval(text){
			return eval("(" + text + ")");
		}
	
		// Widgets like BorderContainer add properties to _Widget via dojo.extend().
		// If BorderContainer is loaded after _Widget's parameter list has been cached,
		// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
		var extendCnt = 0;
		aspect.after(dlang, "extend", function(){
			extendCnt++;
		}, true);
	
		function getNameMap(ctor){
			// summary:
			//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
			var map = ctor._nameCaseMap, proto = ctor.prototype;
	
			// Create the map if it's undefined.
			// Refresh the map if a superclass was possibly extended with new methods since the map was created.
			if(!map || map._extendCnt < extendCnt){
				map = ctor._nameCaseMap = {};
				for(var name in proto){
					if(name.charAt(0) === "_"){
						continue;
					}	// skip internal properties
					map[name.toLowerCase()] = name;
				}
				map._extendCnt = extendCnt;
			}
			return map;
		}
	
		function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
			// summary:
			//		Retrieves a constructor.  If the types array contains more than one class/MID then the
			//		subsequent classes will be mixed into the first class and a unique constructor will be
			//		returned for that array.
	
			if(!contextRequire){
				contextRequire = require;
			}
	
			// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
			// Keep separate map for each requireContext to avoid false matches (ex: "./Foo" can mean different things
			// depending on context.)
			var ctorMap = contextRequire._dojoParserCtorMap || (contextRequire._dojoParserCtorMap = {});
	
			var ts = types.join();
			if(!ctorMap[ts]){
				var mixins = [];
				for(var i = 0, l = types.length; i < l; i++){
					var t = types[i];
					// TODO: Consider swapping getObject and require in the future
					mixins[mixins.length] = (ctorMap[t] = ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
						contextRequire(t))));
				}
				var ctor = mixins.shift();
				ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
			}
	
			return ctorMap[ts];
		}
	
		var parser = {
			// summary:
			//		The Dom/Widget parsing package
	
			_clearCache: function(){
				// summary:
				//		Clear cached data.   Used mainly for benchmarking.
				extendCnt++;
				_ctorMap = {};
			},
	
			_functionFromScript: function(script, attrData){
				// summary:
				//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
				//		into a function
				// script: DOMNode
				//		The `<script>` DOMNode
				// attrData: String
				//		For HTML5 compliance, searches for attrData + "args" (typically
				//		"data-dojo-args") instead of "args"
				var preamble = "",
					suffix = "",
					argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
					withStr = script.getAttribute("with");
	
				// Convert any arguments supplied in script tag into an array to be passed to the
				var fnArgs = (argsStr || "").split(/\s*,\s*/);
	
				if(withStr && withStr.length){
					darray.forEach(withStr.split(/\s*,\s*/), function(part){
						preamble += "with(" + part + "){";
						suffix += "}";
					});
				}
	
				return new Function(fnArgs, preamble + script.innerHTML + suffix);
			},
	
			instantiate: function(nodes, mixin, options){
				// summary:
				//		Takes array of nodes, and turns them into class instances and
				//		potentially calls a startup method to allow them to connect with
				//		any children.
				// nodes: Array
				//		Array of DOM nodes
				// mixin: Object?
				//		An object that will be mixed in with each node in the array.
				//		Values in the mixin will override values in the node, if they
				//		exist.
				// options: Object?
				//		An object used to hold kwArgs for instantiation.
				//		See parse.options argument for details.
				// returns:
				//		Array of instances.
	
				mixin = mixin || {};
				options = options || {};
	
				var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
					attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
					dataDojoType = attrData + "type", // typically "data-dojo-type"
					dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"
	
				var list = [];
				darray.forEach(nodes, function(node){
					var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
					if(type){
						var mixinsValue = node.getAttribute(dataDojoMixins),
							types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];
	
						list.push({
							node: node,
							types: types
						});
					}
				});
	
				// Instantiate the nodes and return the list of instances.
				return this._instantiate(list, mixin, options);
			},
	
			_instantiate: function(nodes, mixin, options, returnPromise){
				// summary:
				//		Takes array of objects representing nodes, and turns them into class instances and
				//		potentially calls a startup method to allow them to connect with
				//		any children.
				// nodes: Array
				//		Array of objects like
				//	|		{
				//	|			ctor: Function (may be null)
				//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
				//	|			node: DOMNode,
				//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
				//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
				//	|		}
				// mixin: Object
				//		An object that will be mixed in with each node in the array.
				//		Values in the mixin will override values in the node, if they
				//		exist.
				// options: Object
				//		An options object used to hold kwArgs for instantiation.
				//		See parse.options argument for details.
				// returnPromise: Boolean
				//		Return a Promise rather than the instance; supports asynchronous widget creation.
				// returns:
				//		Array of instances, or if returnPromise is true, a promise for array of instances
				//		that resolves when instances have finished initializing.
	
				// Call widget constructors.   Some may be asynchronous and return promises.
				var thelist = darray.map(nodes, function(obj){
					var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
					// If we still haven't resolved a ctor, it is fatal now
					if(!ctor){
						throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
					}
					return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
				}, this);
	
				// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
				// widgets).  Parent widgets will recursively call startup on their (non-top level) children
				function onConstruct(thelist){
					if(!mixin._started && !options.noStart){
						darray.forEach(thelist, function(instance){
							if(typeof instance.startup === "function" && !instance._started){
								instance.startup();
							}
						});
					}
	
					return thelist;
				}
	
				if(returnPromise){
					return all(thelist).then(onConstruct);
				}else{
					// Back-compat path, remove for 2.0
					return onConstruct(thelist);
				}
			},
	
			construct: function(ctor, node, mixin, options, scripts, inherited){
				// summary:
				//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
				//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
				// ctor: Function
				//		Widget constructor.
				// node: DOMNode
				//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
				// mixin: Object?
				//		Attributes in this object will be passed as parameters to ctor,
				//		overriding attributes specified on the node.
				// options: Object?
				//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
				// scripts: DomNode[]?
				//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
				// inherited: Object?
				//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
				// returns:
				//		Instance or Promise for the instance, if markupFactory() itself returned a promise
	
				var proto = ctor && ctor.prototype;
				options = options || {};
	
				// Setup hash to hold parameter settings for this widget.	Start with the parameter
				// settings inherited from ancestors ("dir" and "lang").
				// Inherited setting may later be overridden by explicit settings on node itself.
				var params = {};
	
				if(options.defaults){
					// settings for the document itself (or whatever subtree is being parsed)
					dlang.mixin(params, options.defaults);
				}
				if(inherited){
					// settings from dir=rtl or lang=... on a node above this node
					dlang.mixin(params, inherited);
				}
	
				// Get list of attributes explicitly listed in the markup
				var attributes;
				if(has("dom-attributes-explicit")){
					// Standard path to get list of user specified attributes
					attributes = node.attributes;
				}else if(has("dom-attributes-specified-flag")){
					// Special processing needed for IE8, to skip a few faux values in attributes[]
					attributes = darray.filter(node.attributes, function(a){
						return a.specified;
					});
				}else{
					// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
					var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
						attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");
	
					attributes = darray.map(attrs.split(/\s+/), function(name){
						var lcName = name.toLowerCase();
						return {
							name: name,
							// getAttribute() doesn't work for button.value, returns innerHTML of button.
							// but getAttributeNode().value doesn't work for the form.encType or li.value
							value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
								node.getAttribute(lcName) : node.getAttributeNode(lcName).value
						};
					});
				}
	
				// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
				// TODO: remove scope for 2.0
				var scope = options.scope || dojo._scopeName,
					attrData = "data-" + scope + "-", // typically "data-dojo-"
					hash = {};
				if(scope !== "dojo"){
					hash[attrData + "props"] = "data-dojo-props";
					hash[attrData + "type"] = "data-dojo-type";
					hash[attrData + "mixins"] = "data-dojo-mixins";
					hash[scope + "type"] = "dojotype";
					hash[attrData + "id"] = "data-dojo-id";
				}
	
				// Read in attributes and process them, including data-dojo-props, data-dojo-type,
				// dojoAttachPoint, etc., as well as normal foo=bar attributes.
				var i = 0, item, funcAttrs = [], jsname, extra;
				while(item = attributes[i++]){
					var name = item.name,
						lcName = name.toLowerCase(),
						value = item.value;
	
					switch(hash[lcName] || lcName){
					// Already processed, just ignore
					case "data-dojo-type":
					case "dojotype":
					case "data-dojo-mixins":
						break;
	
					// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
					case "data-dojo-props":
						extra = value;
						break;
	
					// data-dojo-id or jsId. TODO: drop jsId in 2.0
					case "data-dojo-id":
					case "jsid":
						jsname = value;
						break;
	
					// For the benefit of _Templated
					case "data-dojo-attach-point":
					case "dojoattachpoint":
						params.dojoAttachPoint = value;
						break;
					case "data-dojo-attach-event":
					case "dojoattachevent":
						params.dojoAttachEvent = value;
						break;
	
					// Special parameter handling needed for IE
					case "class":
						params["class"] = node.className;
						break;
					case "style":
						params["style"] = node.style && node.style.cssText;
						break;
					default:
						// Normal attribute, ex: value="123"
	
						// Find attribute in widget corresponding to specified name.
						// May involve case conversion, ex: onclick --> onClick
						if(!(name in proto)){
							var map = getNameMap(ctor);
							name = map[lcName] || name;
						}
	
						// Set params[name] to value, doing type conversion
						if(name in proto){
							switch(typeof proto[name]){
							case "string":
								params[name] = value;
								break;
							case "number":
								params[name] = value.length ? Number(value) : NaN;
								break;
							case "boolean":
								// for checked/disabled value might be "" or "checked".	 interpret as true.
								params[name] = value.toLowerCase() != "false";
								break;
							case "function":
								if(value === "" || value.search(/[^\w\.]+/i) != -1){
									// The user has specified some text for a function like "return x+5"
									params[name] = new Function(value);
								}else{
									// The user has specified the name of a global function like "myOnClick"
									// or a single word function "return"
									params[name] = dlang.getObject(value, false) || new Function(value);
								}
								funcAttrs.push(name);	// prevent "double connect", see #15026
								break;
							default:
								var pVal = proto[name];
								params[name] =
									(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
										(pVal instanceof Date) ?
											(value == "" ? new Date("") :	// the NaN of dates
											value == "now" ? new Date() :	// current date
											dates.fromISOString(value)) :
									(pVal instanceof _Url) ? (dojo.baseUrl + value) :
									myEval(value);
							}
						}else{
							params[name] = value;
						}
					}
				}
	
				// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
				// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
				for(var j = 0; j < funcAttrs.length; j++){
					var lcfname = funcAttrs[j].toLowerCase();
					node.removeAttribute(lcfname);
					node[lcfname] = null;
				}
	
				// Mix things found in data-dojo-props into the params, overriding any direct settings
				if(extra){
					try{
						extra = myEval.call(options.propsThis, "{" + extra + "}");
						dlang.mixin(params, extra);
					}catch(e){
						// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
						throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
					}
				}
	
				// Any parameters specified in "mixin" override everything else.
				dlang.mixin(params, mixin);
	
				// Get <script> nodes associated with this widget, if they weren't specified explicitly
				if(!scripts){
					scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
				}
	
				// Process <script type="dojo/*"> script tags
				// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
				// the widget on instantiation.
				// <script type="dojo/method"> tags (with no event) are executed after instantiation
				// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
				// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
				// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
				// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
				// note: dojo/* script tags cannot exist in self closing widgets, like <input />
				var aspects = [],	// aspects to connect after instantiation
					calls = [],		// functions to call after instantiation
					watches = [],  // functions to watch after instantiation
					ons = []; // functions to on after instantiation
	
				if(scripts){
					for(i = 0; i < scripts.length; i++){
						var script = scripts[i];
						node.removeChild(script);
						// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
						var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
							prop = script.getAttribute(attrData + "prop"),
							method = script.getAttribute(attrData + "method"),
							advice = script.getAttribute(attrData + "advice"),
							scriptType = script.getAttribute("type"),
							nf = this._functionFromScript(script, attrData);
						if(event){
							if(scriptType == "dojo/connect"){
								aspects.push({ method: event, func: nf });
							}else if(scriptType == "dojo/on"){
								ons.push({ event: event, func: nf });
							}else{
								// <script type="dojo/method" data-dojo-event="foo">
								// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
								params[event] = nf;
							}
						}else if(scriptType == "dojo/aspect"){
							aspects.push({ method: method, advice: advice, func: nf });
						}else if(scriptType == "dojo/watch"){
							watches.push({ prop: prop, func: nf });
						}else{
							calls.push(nf);
						}
					}
				}
	
				// create the instance
				var markupFactory = ctor.markupFactory || proto.markupFactory;
				var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);
	
				function onInstantiate(instance){
					// map it to the JS namespace if that makes sense
					if(jsname){
						dlang.setObject(jsname, instance);
					}
	
					// process connections and startup functions
					for(i = 0; i < aspects.length; i++){
						aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
					}
					for(i = 0; i < calls.length; i++){
						calls[i].call(instance);
					}
					for(i = 0; i < watches.length; i++){
						instance.watch(watches[i].prop, watches[i].func);
					}
					for(i = 0; i < ons.length; i++){
						don(instance, ons[i].event, ons[i].func);
					}
	
					return instance;
				}
	
				if(instance.then){
					return instance.then(onInstantiate);
				}else{
					return onInstantiate(instance);
				}
			},
	
			scan: function(root, options){
				// summary:
				//		Scan a DOM tree and return an array of objects representing the DOMNodes
				//		that need to be turned into widgets.
				// description:
				//		Search specified node (or document root node) recursively for class instances
				//		and return an array of objects that represent potential widgets to be
				//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
				//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
				//		like "dijit/form/Button".  If the MID is not currently available, scan will
				//		attempt to require() in the module.
				//
				//		See parser.parse() for details of markup.
				// root: DomNode?
				//		A default starting root node from which to start the parsing. Can be
				//		omitted, defaulting to the entire document. If omitted, the `options`
				//		object can be passed in this place. If the `options` object has a
				//		`rootNode` member, that is used.
				// options: Object
				//		a kwArgs options object, see parse() for details
				//
				// returns: Promise
				//		A promise that is resolved with the nodes that have been parsed.
	
				var list = [], // Output List
					mids = [], // An array of modules that are not yet loaded
					midsHash = {}; // Used to keep the mids array unique
	
				var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
					attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
					dataDojoType = attrData + "type", // typically "data-dojo-type"
					dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
					dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"
	
				// Info on DOMNode currently being processed
				var node = root.firstChild;
	
				// Info on parent of DOMNode currently being processed
				//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
				//	- parent: pointer to identical structure for my parent (or null if no parent)
				//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
				var inherited = options.inherited;
				if(!inherited){
					function findAncestorAttr(node, attr){
						return (node.getAttribute && node.getAttribute(attr)) ||
							(node.parentNode && findAncestorAttr(node.parentNode, attr));
					}
	
					inherited = {
						dir: findAncestorAttr(root, "dir"),
						lang: findAncestorAttr(root, "lang"),
						textDir: findAncestorAttr(root, dataDojoTextDir)
					};
					for(var key in inherited){
						if(!inherited[key]){
							delete inherited[key];
						}
					}
				}
	
				// Metadata about parent node
				var parent = {
					inherited: inherited
				};
	
				// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
				var scripts;
	
				// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
				var scriptsOnly;
	
				function getEffective(parent){
					// summary:
					//		Get effective dir, lang, textDir settings for specified obj
					//		(matching "parent" object structure above), and do caching.
					//		Take care not to return null entries.
					if(!parent.inherited){
						parent.inherited = {};
						var node = parent.node,
							grandparent = getEffective(parent.parent);
						var inherited = {
							dir: node.getAttribute("dir") || grandparent.dir,
							lang: node.getAttribute("lang") || grandparent.lang,
							textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
						};
						for(var key in inherited){
							if(inherited[key]){
								parent.inherited[key] = inherited[key];
							}
						}
					}
					return parent.inherited;
				}
	
				// DFS on DOM tree, collecting nodes with data-dojo-type specified.
				while(true){
					if(!node){
						// Finished this level, continue to parent's next sibling
						if(!parent || !parent.node){
							break;
						}
						node = parent.node.nextSibling;
						scriptsOnly = false;
						parent = parent.parent;
						scripts = parent.scripts;
						continue;
					}
	
					if(node.nodeType != 1){
						// Text or comment node, skip to next sibling
						node = node.nextSibling;
						continue;
					}
	
					if(scripts && node.nodeName.toLowerCase() == "script"){
						// Save <script type="dojo/..."> for parent, then continue to next sibling
						type = node.getAttribute("type");
						if(type && /^dojo\/\w/i.test(type)){
							scripts.push(node);
						}
						node = node.nextSibling;
						continue;
					}
					if(scriptsOnly){
						// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
						// continue further analysis of the node and will continue to the next sibling
						node = node.nextSibling;
						continue;
					}
	
					// Check for data-dojo-type attribute, fallback to backward compatible dojoType
					// TODO: Remove dojoType in 2.0
					var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
	
					// Short circuit for leaf nodes containing nothing [but text]
					var firstChild = node.firstChild;
					if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
						node = node.nextSibling;
						continue;
					}
	
					// Meta data about current node
					var current;
	
					var ctor = null;
					if(type){
						// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
						var mixinsValue = node.getAttribute(dataDojoMixins),
							types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];
	
						// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
						// loaded yet so use try/catch to avoid throw from require()
						try{
							ctor = getCtor(types, options.contextRequire);
						}catch(e){}
	
						// If the constructor was not found, check to see if it has modules that can be loaded
						if(!ctor){
							darray.forEach(types, function(t){
								if(~t.indexOf('/') && !midsHash[t]){
									// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
									midsHash[t] = true;
									mids[mids.length] = t;
								}
							});
						}
	
						var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children
	
						// Setup meta data about this widget node, and save it to list of nodes to instantiate
						current = {
							types: types,
							ctor: ctor,
							parent: parent,
							node: node,
							scripts: childScripts
						};
						current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
						list.push(current);
					}else{
						// Meta data about this non-widget node
						current = {
							node: node,
							scripts: scripts,
							parent: parent
						};
					}
	
					// Recurse, collecting <script type="dojo/..."> children, and also looking for
					// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
					// When finished with children, go to my next sibling.
					scripts = childScripts;
					scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
					parent = current;
					node = firstChild;
				}
	
				var d = new Deferred();
	
				// If there are modules to load then require them in
				if(mids.length){
					// Warn that there are modules being auto-required
					if(has("dojo-debug-messages")){
						console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
					}
					var r = options.contextRequire || require;
					r(mids, function(){
						// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
						// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
						// auto-require of a module like ContentPane.   Assumes list is in DFS order.
						d.resolve(darray.filter(list, function(widget){
							if(!widget.ctor){
								// Attempt to find the constructor again.   Still won't find classes defined via
								// dijit/Declaration so need to try/catch.
								try{
									widget.ctor = getCtor(widget.types, options.contextRequire);
								}catch(e){}
							}
	
							// Get the parent widget
							var parent = widget.parent;
							while(parent && !parent.types){
								parent = parent.parent;
							}
	
							// Return false if this node should be skipped due to stopParser on an ancestor.
							// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
							// trying to compute widget.instantiate.
							var proto = widget.ctor && widget.ctor.prototype;
							widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
							widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
							return widget.instantiate;
						}));
					});
				}else{
					// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
					// efficiency, to avoid running the require() and the callback code above.
					d.resolve(list);
				}
	
				// Return the promise
				return d.promise;
			},
	
			_require: function(/*DOMNode*/ script, /*Object?*/ options){
				// summary:
				//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
				//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
				//		variables, and returns a Promise for when that operation completes.
				//
				//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).
	
				var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
					vars = [],
					mids = [],
					d = new Deferred();
	
				var contextRequire = (options && options.contextRequire) || require;
	
				for(var name in hash){
					vars.push(name);
					mids.push(hash[name]);
				}
	
				contextRequire(mids, function(){
					for(var i = 0; i < vars.length; i++){
						dlang.setObject(vars[i], arguments[i]);
					}
					d.resolve(arguments);
				});
	
				return d.promise;
			},
	
			_scanAmd: function(root, options){
				// summary:
				//		Scans the DOM for any declarative requires and returns their values.
				// description:
				//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
				//		specified modules and (asynchronously) assign them to the specified global variables,
				//		and returns a Promise for when those operations complete.
				// root: DomNode
				//		The node to base the scan from.
				// options: Object?
				//		a kwArgs options object, see parse() for details
	
				// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
				var deferred = new Deferred(),
					promise = deferred.promise;
				deferred.resolve(true);
	
				var self = this;
				query("script[type='dojo/require']", root).forEach(function(node){
					// Fire off require() call for specified modules.  Chain this require to fire after
					// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
					promise = promise.then(function(){
						return self._require(node, options);
					});
	
					// Remove from DOM so it isn't seen again
					node.parentNode.removeChild(node);
				});
	
				return promise;
			},
	
			parse: function(rootNode, options){
				// summary:
				//		Scan the DOM for class instances, and instantiate them.
				// description:
				//		Search specified node (or root node) recursively for class instances,
				//		and instantiate them. Searches for either data-dojo-type="Class" or
				//		dojoType="Class" where "Class" is a a fully qualified class name,
				//		like `dijit/form/Button`
				//
				//		Using `data-dojo-type`:
				//		Attributes using can be mixed into the parameters used to instantiate the
				//		Class by using a `data-dojo-props` attribute on the node being converted.
				//		`data-dojo-props` should be a string attribute to be converted from JSON.
				//
				//		Using `dojoType`:
				//		Attributes are read from the original domNode and converted to appropriate
				//		types by looking up the Class prototype values. This is the default behavior
				//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
				//		go away in Dojo 2.0.
				// rootNode: DomNode?
				//		A default starting root node from which to start the parsing. Can be
				//		omitted, defaulting to the entire document. If omitted, the `options`
				//		object can be passed in this place. If the `options` object has a
				//		`rootNode` member, that is used.
				// options: Object?
				//		A hash of options.
				//
				//		- noStart: Boolean?:
				//			when set will prevent the parser from calling .startup()
				//			when locating the nodes.
				//		- rootNode: DomNode?:
				//			identical to the function's `rootNode` argument, though
				//			allowed to be passed in via this `options object.
				//		- template: Boolean:
				//			If true, ignores ContentPane's stopParser flag and parses contents inside of
				//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
				//			nested inside the ContentPane to work.
				//		- inherited: Object:
				//			Hash possibly containing dir and lang settings to be applied to
				//			parsed widgets, unless there's another setting on a sub-node that overrides
				//		- scope: String:
				//			Root for attribute names to search for.   If scopeName is dojo,
				//			will search for data-dojo-type (or dojoType).   For backwards compatibility
				//			reasons defaults to dojo._scopeName (which is "dojo" except when
				//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
				//		- propsThis: Object:
				//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
				//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
				//		- contextRequire: Function:
				//			If specified, this require is utilised for looking resolving modules instead of the
				//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
				//			`dijit._WidgetsInTemplateMixin`.
				// returns: Mixed
				//		Returns a blended object that is an array of the instantiated objects, but also can include
				//		a promise that is resolved with the instantiated objects.  This is done for backwards
				//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
				//		fashion and `parser.parse().then(function(instances){...})` should be used.
				// example:
				//		Parse all widgets on a page:
				//	|		parser.parse();
				// example:
				//		Parse all classes within the node with id="foo"
				//	|		parser.parse(dojo.byId('foo'));
				// example:
				//		Parse all classes in a page, but do not call .startup() on any
				//		child
				//	|		parser.parse({ noStart: true })
				// example:
				//		Parse all classes in a node, but do not call .startup()
				//	|		parser.parse(someNode, { noStart:true });
				//	|		// or
				//	|		parser.parse({ noStart:true, rootNode: someNode });
	
				// determine the root node and options based on the passed arguments.
				var root;
				if(!options && rootNode && rootNode.rootNode){
					options = rootNode;
					root = options.rootNode;
				}else if(rootNode && dlang.isObject(rootNode) && !("nodeType" in rootNode)){
					options = rootNode;
				}else{
					root = rootNode;
				}
				root = root ? dom.byId(root) : dwindow.body();
	
				options = options || {};
	
				var mixin = options.template ? { template: true } : {},
					instances = [],
					self = this;
	
				// First scan for any <script type=dojo/require> nodes, and execute.
				// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
				// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
				// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
				// that occur during the parse().
				var p =
					this._scanAmd(root, options).then(function(){
						return self.scan(root, options);
					}).then(function(parsedNodes){
						return self._instantiate(parsedNodes, mixin, options, true);
					}).then(function(_instances){
						// Copy the instances into the instances[] array we declared above, and are accessing as
						// our return value.
						return instances = instances.concat(_instances);
					}).otherwise(function(e){
						// TODO Modify to follow better pattern for promise error management when available
						console.error("dojo/parser::parse() error", e);
						throw e;
					});
	
				// Blend the array with the promise
				dlang.mixin(instances, p);
				return instances;
			}
		};
	
		if(has("extend-dojo")){
			dojo.parser = parser;
		}
	
		// Register the parser callback. It should be the first callback
		// after the a11y test.
		if(config.parseOnLoad){
			ready(100, parser, "parse");
		}
	
		return parser;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo){
		// module:
		//		dojo/url
	
		var
			ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
			ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
			_Url = function(){
				var n = null,
					_a = arguments,
					uri = [_a[0]];
				// resolve uri components relative to each other
				for(var i = 1; i<_a.length; i++){
					if(!_a[i]){ continue; }
	
					// Safari doesn't support this.constructor so we have to be explicit
					// FIXME: Tracked (and fixed) in Webkit bug 3537.
					//		http://bugs.webkit.org/show_bug.cgi?id=3537
					var relobj = new _Url(_a[i]+""),
						uriobj = new _Url(uri[0]+"");
	
					if(
						relobj.path == "" &&
						!relobj.scheme &&
						!relobj.authority &&
						!relobj.query
					){
						if(relobj.fragment != n){
							uriobj.fragment = relobj.fragment;
						}
						relobj = uriobj;
					}else if(!relobj.scheme){
						relobj.scheme = uriobj.scheme;
	
						if(!relobj.authority){
							relobj.authority = uriobj.authority;
	
							if(relobj.path.charAt(0) != "/"){
								var path = uriobj.path.substring(0,
									uriobj.path.lastIndexOf("/") + 1) + relobj.path;
	
								var segs = path.split("/");
								for(var j = 0; j < segs.length; j++){
									if(segs[j] == "."){
										// flatten "./" references
										if(j == segs.length - 1){
											segs[j] = "";
										}else{
											segs.splice(j, 1);
											j--;
										}
									}else if(j > 0 && !(j == 1 && segs[0] == "") &&
										segs[j] == ".." && segs[j-1] != ".."){
										// flatten "../" references
										if(j == (segs.length - 1)){
											segs.splice(j, 1);
											segs[j - 1] = "";
										}else{
											segs.splice(j - 1, 2);
											j -= 2;
										}
									}
								}
								relobj.path = segs.join("/");
							}
						}
					}
	
					uri = [];
					if(relobj.scheme){
						uri.push(relobj.scheme, ":");
					}
					if(relobj.authority){
						uri.push("//", relobj.authority);
					}
					uri.push(relobj.path);
					if(relobj.query){
						uri.push("?", relobj.query);
					}
					if(relobj.fragment){
						uri.push("#", relobj.fragment);
					}
				}
	
				this.uri = uri.join("");
	
				// break the uri into its main components
				var r = this.uri.match(ore);
	
				this.scheme = r[2] || (r[1] ? "" : n);
				this.authority = r[4] || (r[3] ? "" : n);
				this.path = r[5]; // can never be undefined
				this.query = r[7] || (r[6] ? "" : n);
				this.fragment	 = r[9] || (r[8] ? "" : n);
	
				if(this.authority != n){
					// server based naming authority
					r = this.authority.match(ire);
	
					this.user = r[3] || n;
					this.password = r[4] || n;
					this.host = r[6] || r[7]; // ipv6 || ipv4
					this.port = r[9] || n;
				}
			};
		_Url.prototype.toString = function(){ return this.uri; };
	
		return dojo._Url = _Url;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28),
		__webpack_require__(46),
		__webpack_require__(53)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, Deferred, when){
		"use strict";
	
		// module:
		//		dojo/promise/all
	
		var some = array.some;
	
		return function all(objectOrArray){
			// summary:
			//		Takes multiple promises and returns a new promise that is fulfilled
			//		when all promises have been resolved or one has been rejected.
			// description:
			//		Takes multiple promises and returns a new promise that is fulfilled
			//		when all promises have been resolved or one has been rejected. If one of
			//		the promises is rejected, the returned promise is also rejected. Canceling
			//		the returned promise will *not* cancel any passed promises.
			// objectOrArray: Object|Array?
			//		The promise will be fulfilled with a list of results if invoked with an
			//		array, or an object of results when passed an object (using the same
			//		keys). If passed neither an object or array it is resolved with an
			//		undefined value.
			// returns: dojo/promise/Promise
	
			var object, array;
			if(objectOrArray instanceof Array){
				array = objectOrArray;
			}else if(objectOrArray && typeof objectOrArray === "object"){
				object = objectOrArray;
			}
	
			var results;
			var keyLookup = [];
			if(object){
				array = [];
				for(var key in object){
					if(Object.hasOwnProperty.call(object, key)){
						keyLookup.push(key);
						array.push(object[key]);
					}
				}
				results = {};
			}else if(array){
				results = [];
			}
	
			if(!array || !array.length){
				return new Deferred().resolve(results);
			}
	
			var deferred = new Deferred();
			deferred.promise.always(function(){
				results = keyLookup = null;
			});
			var waiting = array.length;
			some(array, function(valueOrPromise, index){
				if(!object){
					keyLookup.push(index);
				}
				when(valueOrPromise, function(value){
					if(!deferred.isFulfilled()){
						results[keyLookup[index]] = value;
						if(--waiting === 0){
							deferred.resolve(results);
						}
					}
				}, deferred.reject);
				return deferred.isFulfilled();
			});
			return deferred.promise;	// dojo/promise/Promise
		};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, array){
	
	// module:
	//		dojo/date/stamp
	
	var stamp = {
		// summary:
		//		TODOC
	};
	lang.setObject("dojo.date.stamp", stamp);
	
	// Methods to convert dates to or from a wire (string) format using well-known conventions
	
	stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
		// summary:
		//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
		//
		// description:
		//		Accepts a string formatted according to a profile of ISO8601 as defined by
		//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
		//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
		//		The following combinations are valid:
		//
		//		- dates only
		//			- yyyy
		//			- yyyy-MM
		//			- yyyy-MM-dd
		//		- times only, with an optional time zone appended
		//			- THH:mm
		//			- THH:mm:ss
		//			- THH:mm:ss.SSS
		//		- and "datetimes" which could be any combination of the above
		//
		//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
		//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
		//		input may return null.  Arguments which are out of bounds will be handled
		//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
		//		Only years between 100 and 9999 are supported.
	  	// formattedString:
		//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
		// defaultTime:
		//		Used for defaults for fields omitted in the formattedString.
		//		Uses 1970-01-01T00:00:00.0Z by default.
	
		if(!stamp._isoRegExp){
			stamp._isoRegExp =
	//TODO: could be more restrictive and check for 00-59, etc.
				/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
		}
	
		var match = stamp._isoRegExp.exec(formattedString),
			result = null;
	
		if(match){
			match.shift();
			if(match[1]){match[1]--;} // Javascript Date months are 0-based
			if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds
	
			if(defaultTime){
				// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
				defaultTime = new Date(defaultTime);
				array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
					return defaultTime["get" + prop]();
				}), function(value, index){
					match[index] = match[index] || value;
				});
			}
			result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
			if(match[0] < 100){
				result.setFullYear(match[0] || 1970);
			}
	
			var offset = 0,
				zoneSign = match[7] && match[7].charAt(0);
			if(zoneSign != 'Z'){
				offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
				if(zoneSign != '-'){ offset *= -1; }
			}
			if(zoneSign){
				offset -= result.getTimezoneOffset();
			}
			if(offset){
				result.setTime(result.getTime() + offset * 60000);
			}
		}
	
		return result; // Date or null
	};
	
	/*=====
	var __Options = {
		// selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		// zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		// milliseconds: Boolean
		//		if true, output milliseconds
	};
	=====*/
	
	stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
		// summary:
		//		Format a Date object as a string according a subset of the ISO-8601 standard
		//
		// description:
		//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
		//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
		//		Does not check bounds.  Only years between 100 and 9999 are supported.
		//
		// dateObject:
		//		A Date object
	
		var _ = function(n){ return (n < 10) ? "0" + n : n; };
		options = options || {};
		var formattedDate = [],
			getter = options.zulu ? "getUTC" : "get",
			date = "";
		if(options.selector != "time"){
			var year = dateObject[getter+"FullYear"]();
			date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
		}
		formattedDate.push(date);
		if(options.selector != "date"){
			var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
			var millis = dateObject[getter+"Milliseconds"]();
			if(options.milliseconds){
				time += "."+ (millis < 100 ? "0" : "") + _(millis);
			}
			if(options.zulu){
				time += "Z";
			}else if(options.selector != "time"){
				var timezoneOffset = dateObject.getTimezoneOffset();
				var absOffset = Math.abs(timezoneOffset);
				time += (timezoneOffset > 0 ? "-" : "+") +
					_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
			}
			formattedDate.push(time);
		}
		return formattedDate.join('T'); // String
	};
	
	return stamp;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 88 */,
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(90),
		__webpack_require__(69),
		__webpack_require__(1), 
		__webpack_require__(8),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(focus, _WidgetBase, declare, lang,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_FocusMixin", (function(){
	
		// module:
		//		dijit/_FocusMixin
	
		// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
		// to be last in the inheritance chain, so mixin to _WidgetBase.
		lang.extend(_WidgetBase, {
			// focused: [readonly] Boolean
			//		This widget or a widget it contains has focus, or is "active" because
			//		it was recently clicked.
			focused: false,
	
			onFocus: function(){
				// summary:
				//		Called when the widget becomes "active" because
				//		it or a widget inside of it either has focus, or has recently
				//		been clicked.
				// tags:
				//		callback
			},
	
			onBlur: function(){
				// summary:
				//		Called when the widget stops being "active" because
				//		focus moved to something outside of it, or the user
				//		clicked somewhere outside of it, or the widget was
				//		hidden.
				// tags:
				//		callback
			},
	
			_onFocus: function(){
				// summary:
				//		This is where widgets do processing for when they are active,
				//		such as changing CSS classes.  See onFocus() for more details.
				// tags:
				//		protected
				this.onFocus();
			},
	
			_onBlur: function(){
				// summary:
				//		This is where widgets do processing for when they stop being active,
				//		such as changing CSS classes.  See onBlur() for more details.
				// tags:
				//		protected
				this.onBlur();
			}
		});
	
		return declare("dijit._FocusMixin", null, {
			// summary:
			//		Mixin to widget to provide _onFocus() and _onBlur() methods that
			//		fire when a widget or its descendants get/lose focus
	
			// flag that I want _onFocus()/_onBlur() notifications from focus manager
			_focusManager: focus
		});
	
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(19),
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(14), 
		__webpack_require__(27),
		__webpack_require__(11), 
		__webpack_require__(21),
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(71),
		__webpack_require__(9), 
		__webpack_require__(72),
		__webpack_require__(12), 
		__webpack_require__(91), 
		__webpack_require__(92),	
		__webpack_require__(74),	
		__webpack_require__(75),__webpack_require__(6)		
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
				a11y, registry, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/focus", (function(){
	
		// module:
		//		dijit/focus
	
		// Time of the last focusin event
		var lastFocusin;
	
		// Time of the last touch/mousedown or focusin event
		var lastTouchOrFocusin;
	
		var FocusManager = declare([Stateful, Evented], {
			// summary:
			//		Tracks the currently focused node, and which widgets are currently "active".
			//		Access via require(["dijit/focus"], function(focus){ ... }).
			//
			//		A widget is considered active if it or a descendant widget has focus,
			//		or if a non-focusable node of this widget or a descendant was recently clicked.
			//
			//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
			//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
			//
			//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
			//		when widgets become active/inactive
			//
			//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.
	
			// curNode: DomNode
			//		Currently focused item on screen
			curNode: null,
	
			// activeStack: dijit/_WidgetBase[]
			//		List of currently active widgets (focused widget and it's ancestors)
			activeStack: [],
	
			constructor: function(){
				// Don't leave curNode/prevNode pointing to bogus elements
				var check = lang.hitch(this, function(node){
					if(dom.isDescendant(this.curNode, node)){
						this.set("curNode", null);
					}
					if(dom.isDescendant(this.prevNode, node)){
						this.set("prevNode", null);
					}
				});
				aspect.before(domConstruct, "empty", check);
				aspect.before(domConstruct, "destroy", check);
			},
	
			registerIframe: function(/*DomNode*/ iframe){
				// summary:
				//		Registers listeners on the specified iframe so that any click
				//		or focus event on that iframe (or anything in it) is reported
				//		as a focus/click event on the `<iframe>` itself.
				// description:
				//		Currently only used by editor.
				// returns:
				//		Handle with remove() method to deregister.
				return this.registerWin(iframe.contentWindow, iframe);
			},
	
			registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
				// summary:
				//		Registers listeners on the specified window (either the main
				//		window or an iframe's window) to detect when the user has clicked somewhere
				//		or focused somewhere.
				// description:
				//		Users should call registerIframe() instead of this method.
				// targetWindow:
				//		If specified this is the window associated with the iframe,
				//		i.e. iframe.contentWindow.
				// effectiveNode:
				//		If specified, report any focus events inside targetWindow as
				//		an event on effectiveNode, rather than on evt.target.
				// returns:
				//		Handle with remove() method to deregister.
	
				// TODO: make this function private in 2.0; Editor/users should call registerIframe(),
	
				// Listen for blur and focus events on targetWindow's document.
				var _this = this,
					body = targetWindow.document && targetWindow.document.body;
	
				if(body){
					// Listen for touches or mousedowns... could also use dojo/touch.press here.
					var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
						has("touch-events") ? "mousedown, touchstart" : "mousedown";
					var mdh = on(targetWindow.document, event, function(evt){
						// workaround weird IE bug where the click is on an orphaned node
						// (first time clicking a Select/DropDownButton inside a TooltipDialog).
						// actually, strangely this is happening on latest chrome too.
						if(evt && evt.target && evt.target.parentNode == null){
							return;
						}
	
						_this._onTouchNode(effectiveNode || evt.target, "mouse");
					});
	
					var fih = on(body, 'focusin', function(evt){
						// When you refocus the browser window, IE gives an event with an empty srcElement
						if(!evt.target.tagName) { return; }
	
						// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
						// ignore those events
						var tag = evt.target.tagName.toLowerCase();
						if(tag == "#document" || tag == "body"){ return; }
	
						if(a11y.isFocusable(evt.target)){
							_this._onFocusNode(effectiveNode || evt.target);
						}else{
							// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
							// probably just ignore such an event as it will be handled by onmousedown handler above, but
							// leaving the code for now.
							_this._onTouchNode(effectiveNode || evt.target);
						}
					});
	
					var foh = on(body, 'focusout', function(evt){
						_this._onBlurNode(effectiveNode || evt.target);
					});
	
					return {
						remove: function(){
							mdh.remove();
							fih.remove();
							foh.remove();
							mdh = fih = foh = null;
							body = null;	// prevent memory leak (apparent circular reference via closure)
						}
					};
				}
			},
	
			_onBlurNode: function(/*DomNode*/ node){
				// summary:
				//		Called when focus leaves a node.
				//		Usually ignored, _unless_ it *isn't* followed by touching another node,
				//		which indicates that we tabbed off the last field on the page,
				//		in which case every widget is marked inactive
	
				var now = (new Date()).getTime();
	
				// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
				// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
				// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
				if(now < lastFocusin + 100){
					return;
				}
	
				// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
				// so clear focus.
				if(this._clearFocusTimer){
					clearTimeout(this._clearFocusTimer);
				}
				this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
					this.set("prevNode", this.curNode);
					this.set("curNode", null);
				}), 0);
	
				// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
				if(this._clearActiveWidgetsTimer){
					clearTimeout(this._clearActiveWidgetsTimer);
				}
	
				if(now < lastTouchOrFocusin + 100){
					// This blur event is coming late (after the call to _onTouchNode() rather than before.
					// So let _onTouchNode() handle setting the widget stack.
					// See https://bugs.dojotoolkit.org/ticket/17668
					return;
				}
	
				// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
				this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
					delete this._clearActiveWidgetsTimer;
					this._setStack([]);
				}), 0);
			},
	
			_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
				// summary:
				//		Callback when node is focused or touched.
				//		Note that _onFocusNode() calls _onTouchNode().
				// node:
				//		The node that was touched.
				// by:
				//		"mouse" if the focus/touch was caused by a mouse down event
	
				// Keep track of time of last focusin or touch event.
				lastTouchOrFocusin = (new Date()).getTime();
	
				if(this._clearActiveWidgetsTimer){
					// forget the recent blur event
					clearTimeout(this._clearActiveWidgetsTimer);
					delete this._clearActiveWidgetsTimer;
				}
	
				// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
				// even though the scrollbar is technically on the popup wrapper (see #10631)
				if(domClass.contains(node, "dijitPopup")){
					node = node.firstChild;
				}
	
				// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
				var newStack=[];
				try{
					while(node){
						var popupParent = domAttr.get(node, "dijitPopupParent");
						if(popupParent){
							node=registry.byId(popupParent).domNode;
						}else if(node.tagName && node.tagName.toLowerCase() == "body"){
							// is this the root of the document or just the root of an iframe?
							if(node === win.body()){
								// node is the root of the main document
								break;
							}
							// otherwise, find the iframe this node refers to (can't access it via parentNode,
							// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
							node=winUtils.get(node.ownerDocument).frameElement;
						}else{
							// if this node is the root node of a widget, then add widget id to stack,
							// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
							// to support MenuItem)
							var id = node.getAttribute && node.getAttribute("widgetId"),
								widget = id && registry.byId(id);
							if(widget && !(by == "mouse" && widget.get("disabled"))){
								newStack.unshift(id);
							}
							node=node.parentNode;
						}
					}
				}catch(e){ /* squelch */ }
	
				this._setStack(newStack, by);
			},
	
			_onFocusNode: function(/*DomNode*/ node){
				// summary:
				//		Callback when node is focused
	
				if(!node){
					return;
				}
	
				if(node.nodeType == 9){
					// Ignore focus events on the document itself.  This is here so that
					// (for example) clicking the up/down arrows of a spinner
					// (which don't get focus) won't cause that widget to blur. (FF issue)
					return;
				}
	
				// Keep track of time of last focusin event.
				lastFocusin = (new Date()).getTime();
	
				// There was probably a blur event right before this event, but since we have a new focus,
				// forget about the blur
				if(this._clearFocusTimer){
					clearTimeout(this._clearFocusTimer);
					delete this._clearFocusTimer;
				}
	
				this._onTouchNode(node);
	
				if(node == this.curNode){ return; }
				this.set("prevNode", this.curNode);
				this.set("curNode", node);
			},
	
			_setStack: function(/*String[]*/ newStack, /*String*/ by){
				// summary:
				//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
				// newStack:
				//		array of widget id's, starting from the top (outermost) widget
				// by:
				//		"mouse" if the focus/touch was caused by a mouse down event
	
				var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;
	
				if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
					// no changes, return now to avoid spurious notifications about changes to activeStack
					return;
				}
	
				this.set("activeStack", newStack);
	
				var widget, i;
	
				// for all elements that have gone out of focus, set focused=false
				for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
					widget = registry.byId(oldStack[i]);
					if(widget){
						widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
						widget.set("focused", false);
						if(widget._focusManager == this){
							widget._onBlur(by);
						}
						this.emit("widget-blur", widget, by);
					}
				}
	
				// for all element that have come into focus, set focused=true
				for(i++; i <= lastNewIdx; i++){
					widget = registry.byId(newStack[i]);
					if(widget){
						widget.set("focused", true);
						if(widget._focusManager == this){
							widget._onFocus(by);
						}
						this.emit("widget-focus", widget, by);
					}
				}
			},
	
			focus: function(node){
				// summary:
				//		Focus the specified node, suppressing errors if they occur
				if(node){
					try{ node.focus(); }catch(e){/*quiet*/}
				}
			}
		});
	
		var singleton = new FocusManager();
	
		// register top window and all the iframes it contains
		domReady(function(){
			var handle = singleton.registerWin(winUtils.get(document));
			if(has("ie")){
				on(window, "unload", function(){
					if(handle){	// because this gets called twice when doh.robot is running
						handle.remove();
						handle = null;
					}
				});
			}
		});
	
		// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
		// as a function to set focus.   Remove for 2.0.
		dijit.focus = function(node){
			singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
		};
		for(var attr in singleton){
			if(!/^_/.test(attr)){
				dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
			}
		}
		singleton.watch(function(attr, oldVal, newVal){
			dijit.focus[attr] = newVal;
		});
	
		return singleton;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(9), __webpack_require__(12), __webpack_require__(13), __webpack_require__(23), __webpack_require__(15), __webpack_require__(11)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, has, baseWindow, dom, geom, style, domConstruct){
	
		// feature detection
		/* not needed but included here for future reference
		has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
			var	body = baseWindow.body(doc),
				scrollable = domConstruct.create('div', {
					style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
				}, body, "last"),
				center = domConstruct.create('center', {
					style: {overflow:'hidden', direction:'ltr'}
				}, scrollable, "last"),
				inner = domConstruct.create('div', {
					style: {overflow:'visible', display:'inline' }
				}, center, "last");
			inner.innerHTML="&nbsp;";
			var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
			var ret = midPoint >= 32;
			center.removeChild(inner);
			scrollable.removeChild(center);
			body.removeChild(scrollable);
			return ret;
		});
		*/
		has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
			var	body = baseWindow.body(doc),
				scrollable = domConstruct.create('div', {
					style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
				}, body, "last"),
				div = domConstruct.create('div', {
					style: {overflow:'hidden', direction:'ltr'}
				}, scrollable, "last"),
				ret = geom.position(div).x != 0;
			scrollable.removeChild(div);
			body.removeChild(scrollable);
			return ret;
		});
	
		has.add("position-fixed-support", function(win, doc){
			// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
			var	body = baseWindow.body(doc),
				outer = domConstruct.create('span', {
					style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
				}, body, "last"),
				inner = domConstruct.create('span', {
					style: {position:'fixed', left:'0', top:'0'}
				}, outer, "last"),
				ret = geom.position(inner).x != geom.position(outer).x;
			outer.removeChild(inner);
			body.removeChild(outer);
			return ret;
		});
	
		// module:
		//		dojo/window
	
		var window = {
			// summary:
			//		TODOC
	
			getBox: function(/*Document?*/ doc){
				// summary:
				//		Returns the dimensions and scroll position of the viewable area of a browser window
	
				doc = doc || baseWindow.doc;
	
				var
					scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
					// get scroll position
					scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
					w, h;
	
				if(has("touch")){ // if(scrollbars not supported)
					var uiWindow = window.get(doc);   // use UI window, not dojo.global window
					// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
					w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
					h = uiWindow.innerHeight || scrollRoot.clientHeight;
				}else{
					// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
					// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
					w = scrollRoot.clientWidth;
					h = scrollRoot.clientHeight;
				}
				return {
					l: scroll.x,
					t: scroll.y,
					w: w,
					h: h
				};
			},
	
			get: function(/*Document*/ doc){
				// summary:
				//		Get window object associated with document doc.
				// doc:
				//		The document to get the associated window for.
	
				// In some IE versions (at least 6.0), document.parentWindow does not return a
				// reference to the real window object (maybe a copy), so we must fix it as well
				// We use IE specific execScript to attach the real window reference to
				// document._parentWindow for later use
				if(has("ie") && window !== document.parentWindow){
					/*
					In IE 6, only the variable "window" can be used to connect events (others
					may be only copies).
					*/
					doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
					//to prevent memory leak, unset it after use
					//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
					var win = doc._parentWindow;
					doc._parentWindow = null;
					return win;	//	Window
				}
	
				return doc.parentWindow || doc.defaultView;	//	Window
			},
	
			scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
				// summary:
				//		Scroll the passed node into view using minimal movement, if it is not already.
	
				// Don't rely on node.scrollIntoView working just because the function is there since
				// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
				// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
				// and when there's a fixed position scrollable element
	
				try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
					node = dom.byId(node);
					var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
						body = baseWindow.body(doc),
						html = doc.documentElement || body.parentNode,
						isIE = has("ie") || has("trident"),
						isWK = has("webkit");
					// if an untested browser, then use the native method
					if(node == body || node == html){ return; }
					if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident") || has("edge"))
							&& ("scrollIntoView" in node)){
						node.scrollIntoView(false); // short-circuit to native if possible
						return;
					}
					var	backCompat = doc.compatMode == 'BackCompat',
						rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
						rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
						scrollRoot = (isWK || backCompat) ? body : html,
						nodePos = pos || geom.position(node),
						el = node.parentNode,
						isFixed = function(el){
							return (isIE <= 6 || (isIE == 7 && backCompat))
								? false
								: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
						},
						self = this,
						scrollElementBy = function(el, x, y){
							if(el.tagName == "BODY" || el.tagName == "HTML"){
								self.get(el.ownerDocument).scrollBy(x, y);
							}else{
								x && (el.scrollLeft += x);
								y && (el.scrollTop += y);
							}
						};
					if(isFixed(node)){ return; } // nothing to do
					while(el){
						if(el == body){ el = scrollRoot; }
						var	elPos = geom.position(el),
							fixedPos = isFixed(el),
							rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";
	
						if(el == scrollRoot){
							elPos.w = rootWidth; elPos.h = rootHeight;
							if(scrollRoot == html && (isIE || has("trident")) && rtl){
								elPos.x += scrollRoot.offsetWidth-elPos.w;// IE workaround where scrollbar causes negative x
							}
							elPos.x = 0;
							elPos.y = 0;
						}else{
							var pb = geom.getPadBorderExtents(el);
							elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
							var clientSize = el.clientWidth,
								scrollBarSize = elPos.w - clientSize;
							if(clientSize > 0 && scrollBarSize > 0){
								if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
									elPos.x += scrollBarSize;
								}
								elPos.w = clientSize;
							}
							clientSize = el.clientHeight;
							scrollBarSize = elPos.h - clientSize;
							if(clientSize > 0 && scrollBarSize > 0){
								elPos.h = clientSize;
							}
						}
						if(fixedPos){ // bounded by viewport, not parents
							if(elPos.y < 0){
								elPos.h += elPos.y; elPos.y = 0;
							}
							if(elPos.x < 0){
								elPos.w += elPos.x; elPos.x = 0;
							}
							if(elPos.y + elPos.h > rootHeight){
								elPos.h = rootHeight - elPos.y;
							}
							if(elPos.x + elPos.w > rootWidth){
								elPos.w = rootWidth - elPos.x;
							}
						}
						// calculate overflow in all 4 directions
						var	l = nodePos.x - elPos.x, // beyond left: < 0
	//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
							t = nodePos.y - elPos.y, // beyond top: < 0
							r = l + nodePos.w - elPos.w, // beyond right: > 0
							bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
						var s, old;
						if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
							s = Math[l < 0? "max" : "min"](l, r);
							if(rtl && ((isIE == 8 && !backCompat) || has("trident") >= 5)){ s = -s; }
							old = el.scrollLeft;
							scrollElementBy(el, s, 0);
							s = el.scrollLeft - old;
							nodePos.x -= s;
						}
						if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
							s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
							old = el.scrollTop;
							scrollElementBy(el, 0, s);
							s = el.scrollTop - old;
							nodePos.y -= s;
						}
						el = (el != scrollRoot) && !fixedPos && el.parentNode;
					}
				}catch(error){
					console.error('scrollIntoView: ' + error);
					node.scrollIntoView(false);
				}
			}
		};
	
		has("extend-dojo") && lang.setObject("dojo.window", window);
	
		return window;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(13),			
		__webpack_require__(14), 
		__webpack_require__(15), 
		__webpack_require__(8), 
		__webpack_require__(9), 
		__webpack_require__(75),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, dom, domAttr, domStyle, lang, has, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/a11y", (function(){
	
		// module:
		//		dijit/a11y
	
		var undefined;
	
		var a11y = {
			// summary:
			//		Accessibility utility functions (keyboard, tab stops, etc.)
	
			_isElementShown: function(/*Element*/ elem){
				var s = domStyle.get(elem);
				return (s.visibility != "hidden")
					&& (s.visibility != "collapsed")
					&& (s.display != "none")
					&& (domAttr.get(elem, "type") != "hidden");
			},
	
			hasDefaultTabStop: function(/*Element*/ elem){
				// summary:
				//		Tests if element is tab-navigable even without an explicit tabIndex setting
	
				// No explicit tabIndex setting, need to investigate node type
				switch(elem.nodeName.toLowerCase()){
					case "a":
						// An <a> w/out a tabindex is only navigable if it has an href
						return domAttr.has(elem, "href");
					case "area":
					case "button":
					case "input":
					case "object":
					case "select":
					case "textarea":
						// These are navigable by default
						return true;
					case "iframe":
						// If it's an editor <iframe> then it's tab navigable.
						var body;
						try{
							// non-IE
							var contentDocument = elem.contentDocument;
							if("designMode" in contentDocument && contentDocument.designMode == "on"){
								return true;
							}
							body = contentDocument.body;
						}catch(e1){
							// contentWindow.document isn't accessible within IE7/8
							// if the iframe.src points to a foreign url and this
							// page contains an element, that could get focus
							try{
								body = elem.contentWindow.document.body;
							}catch(e2){
								return false;
							}
						}
						return body && (body.contentEditable == 'true' ||
							(body.firstChild && body.firstChild.contentEditable == 'true'));
					default:
						return elem.contentEditable == 'true';
				}
			},
	
			effectiveTabIndex: function(/*Element*/ elem){
				// summary:
				//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.
	
				if(domAttr.get(elem, "disabled")){
					return undefined;
				}else if(domAttr.has(elem, "tabIndex")){
					// Explicit tab index setting
					return +domAttr.get(elem, "tabIndex");// + to convert string --> number
				}else{
					// No explicit tabIndex setting, so depends on node type
					return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
				}
			},
	
			isTabNavigable: function(/*Element*/ elem){
				// summary:
				//		Tests if an element is tab-navigable
	
				return a11y.effectiveTabIndex(elem) >= 0;
			},
	
			isFocusable: function(/*Element*/ elem){
				// summary:
				//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.
	
				return a11y.effectiveTabIndex(elem) >= -1;
			},
	
			_getTabNavigable: function(/*DOMNode*/ root){
				// summary:
				//		Finds descendants of the specified root node.
				// description:
				//		Finds the following descendants of the specified root node:
				//
				//		- the first tab-navigable element in document order
				//		  without a tabIndex or with tabIndex="0"
				//		- the last tab-navigable element in document order
				//		  without a tabIndex or with tabIndex="0"
				//		- the first element in document order with the lowest
				//		  positive tabIndex value
				//		- the last element in document order with the highest
				//		  positive tabIndex value
				var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};
	
				function radioName(node){
					// If this element is part of a radio button group, return the name for that group.
					return node && node.tagName.toLowerCase() == "input" &&
						node.type && node.type.toLowerCase() == "radio" &&
						node.name && node.name.toLowerCase();
				}
	
				var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
				var walkTree = function(/*DOMNode*/ parent){
					for(var child = parent.firstChild; child; child = child.nextSibling){
						// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
						// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
						if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
							continue;
						}
	
						var tabindex = effectiveTabIndex(child);
						if(tabindex >= 0){
							if(tabindex == 0){
								if(!first){
									first = child;
								}
								last = child;
							}else if(tabindex > 0){
								if(!lowest || tabindex < lowestTabindex){
									lowestTabindex = tabindex;
									lowest = child;
								}
								if(!highest || tabindex >= highestTabindex){
									highestTabindex = tabindex;
									highest = child;
								}
							}
							var rn = radioName(child);
							if(domAttr.get(child, "checked") && rn){
								radioSelected[rn] = child;
							}
						}
						if(child.nodeName.toUpperCase() != 'SELECT'){
							walkTree(child);
						}
					}
				};
				if(shown(root)){
					walkTree(root);
				}
				function rs(node){
					// substitute checked radio button for unchecked one, if there is a checked one with the same name.
					return radioSelected[radioName(node)] || node;
				}
	
				return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
			},
	
			getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
				// summary:
				//		Finds the descendant of the specified root node
				//		that is first in the tabbing order
				var elems = a11y._getTabNavigable(dom.byId(root, doc));
				return elems.lowest ? elems.lowest : elems.first; // DomNode
			},
	
			getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
				// summary:
				//		Finds the descendant of the specified root node
				//		that is last in the tabbing order
				var elems = a11y._getTabNavigable(dom.byId(root, doc));
				return elems.last ? elems.last : elems.highest; // DomNode
			}
		};
	
		has("extend-dojo") && lang.mixin(dijit, a11y);
	
		return a11y;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 93 */,
/* 94 */,
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, lang){
	
	// module:
	//		dojo/regexp
	
	var regexp = {
		// summary:
		//		Regular expressions and Builder resources
	};
	lang.setObject("dojo.regexp", regexp);
	
	regexp.escapeString = function(/*String*/str, /*String?*/except){
		// summary:
		//		Adds escape sequences for special characters in regular expressions
		// except:
		//		a String with special characters to be left unescaped
	
		return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function(ch){
			if(except && except.indexOf(ch) != -1){
				return ch;
			}
			return "\\" + ch;
		}); // String
	};
	
	regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
		// summary:
		//		Builds a regular expression that groups subexpressions
		// description:
		//		A utility function used by some of the RE generators. The
		//		subexpressions are constructed by the function, re, in the second
		//		parameter.  re builds one subexpression for each elem in the array
		//		a, in the first parameter. Returns a string for a regular
		//		expression that groups all the subexpressions.
		// arr:
		//		A single value or an array of values.
		// re:
		//		A function. Takes one parameter and converts it to a regular
		//		expression.
		// nonCapture:
		//		If true, uses non-capturing match, otherwise matches are retained
		//		by regular expression. Defaults to false
	
		// case 1: a is a single value.
		if(!(arr instanceof Array)){
			return re(arr); // String
		}
	
		// case 2: a is an array
		var b = [];
		for(var i = 0; i < arr.length; i++){
			// convert each elem to a RE
			b.push(re(arr[i]));
		}
	
		 // join the REs as alternatives in a RE group.
		return regexp.group(b.join("|"), nonCapture); // String
	};
	
	regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
		// summary:
		//		adds group match to expression
		// nonCapture:
		//		If true, uses non-capturing match, otherwise matches are retained
		//		by regular expression.
		return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
	};
	
	return regexp;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(19),	
		__webpack_require__(7),	
		__webpack_require__(17),	
		__webpack_require__(1), 
		__webpack_require__(4),
		__webpack_require__(2), 
		__webpack_require__(8), 
		__webpack_require__(34),
		__webpack_require__(70),
		__webpack_require__(74),	
		__webpack_require__(69),
		__webpack_require__(97),
		__webpack_require__(89),__webpack_require__(6),
		__webpack_require__(98),		
		__webpack_require__(99)		
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(aspect, config, connect, declare, has, kernel, lang, query, ready,
				registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_Widget", (function(){
	
	
	// module:
	//		dijit/_Widget
	
	
	function connectToDomNode(){
		// summary:
		//		If user connects to a widget method === this function, then they will
		//		instead actually be connecting the equivalent event on this.domNode
	}
	
	// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
	function aroundAdvice(originalConnect){
		return function(obj, event, scope, method){
			if(obj && typeof event == "string" && obj[event] == connectToDomNode){
				return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
			}
			return originalConnect.apply(connect, arguments);
		};
	}
	aspect.around(connect, "connect", aroundAdvice);
	if(kernel.connect){
		aspect.around(kernel, "connect", aroundAdvice);
	}
	
	var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
		// summary:
		//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
		// description:
		//		Old Base class for Dijit widgets.
		//
		//		Extends _WidgetBase, adding support for:
		//
		//		- declaratively/programatically specifying widget initialization parameters like
		//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
		//		- ondijitclick:
		//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
		//		- focus related functions:
		//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
		//			dijit/_base/focus.js.
		//		- deprecated methods
		//		- onShow(), onHide(), onClose()
		//
		//		Also, by loading code in dijit/_base, turns on:
		//
		//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
		//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)
	
	
		////////////////// DEFERRED CONNECTS ///////////////////
	
		onClick: connectToDomNode,
		/*=====
		onClick: function(event){
			// summary:
			//		Connect to this function to receive notifications of mouse click events.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onDblClick: connectToDomNode,
		/*=====
		onDblClick: function(event){
			// summary:
			//		Connect to this function to receive notifications of mouse double click events.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onKeyDown: connectToDomNode,
		/*=====
		onKeyDown: function(event){
			// summary:
			//		Connect to this function to receive notifications of keys being pressed down.
			// event:
			//		key Event
			// tags:
			//		callback
		},
		=====*/
		onKeyPress: connectToDomNode,
		/*=====
		onKeyPress: function(event){
			// summary:
			//		Connect to this function to receive notifications of printable keys being typed.
			// event:
			//		key Event
			// tags:
			//		callback
		},
		=====*/
		onKeyUp: connectToDomNode,
		/*=====
		onKeyUp: function(event){
			// summary:
			//		Connect to this function to receive notifications of keys being released.
			// event:
			//		key Event
			// tags:
			//		callback
		},
		=====*/
		onMouseDown: connectToDomNode,
		/*=====
		onMouseDown: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse button is pressed down.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onMouseMove: connectToDomNode,
		/*=====
		onMouseMove: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onMouseOut: connectToDomNode,
		/*=====
		onMouseOut: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onMouseOver: connectToDomNode,
		/*=====
		onMouseOver: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onMouseLeave: connectToDomNode,
		/*=====
		onMouseLeave: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse moves off of this widget.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onMouseEnter: connectToDomNode,
		/*=====
		onMouseEnter: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse moves onto this widget.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
		onMouseUp: connectToDomNode,
		/*=====
		onMouseUp: function(event){
			// summary:
			//		Connect to this function to receive notifications of when the mouse button is released.
			// event:
			//		mouse Event
			// tags:
			//		callback
		},
		=====*/
	
		constructor: function(params /*===== ,srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
	
			// extract parameters like onMouseMove that should connect directly to this.domNode
			this._toConnect = {};
			for(var name in params){
				if(this[name] === connectToDomNode){
					this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
					delete params[name];
				}
			}
		},
	
		postCreate: function(){
			this.inherited(arguments);
	
			// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
			for(var name in this._toConnect){
				this.on(name, this._toConnect[name]);
			}
			delete this._toConnect;
		},
	
		on: function(/*String|Function*/ type, /*Function*/ func){
			if(this[this._onMap(type)] === connectToDomNode){
				// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
				// normalization of onkeypress/onkeydown to behave like firefox, etc.
				// Also, need to specify context as "this" rather than the default context of the DOMNode
				// Remove in 2.0.
				return connect.connect(this.domNode, type.toLowerCase(), this, func);
			}
			return this.inherited(arguments);
		},
	
		_setFocusedAttr: function(val){
			// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
			// (but since it's a private variable we aren't required to keep supporting it).
			this._focused = val;
			this._set("focused", val);
		},
	
		////////////////// DEPRECATED METHODS ///////////////////
	
		setAttribute: function(/*String*/ attr, /*anything*/ value){
			// summary:
			//		Deprecated.  Use set() instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
			this.set(attr, value);
		},
	
		attr: function(/*String|Object*/name, /*Object?*/value){
			// summary:
			//		This method is deprecated, use get() or set() directly.
			// name:
			//		The property to get or set. If an object is passed here and not
			//		a string, its keys are used as names of attributes to be set
			//		and the value of the object as values to set in the widget.
			// value:
			//		Optional. If provided, attr() operates as a setter. If omitted,
			//		the current value of the named property is returned.
			// tags:
			//		deprecated
	
			var args = arguments.length;
			if(args >= 2 || typeof name === "object"){ // setter
				return this.set.apply(this, arguments);
			}else{ // getter
				return this.get(name);
			}
		},
	
		getDescendants: function(){
			// summary:
			//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
			//		This method should generally be avoided as it returns widgets declared in templates, which are
			//		supposed to be internal/hidden, but it's left here for back-compat reasons.
	
			kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
			return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
		},
	
		////////////////// MISCELLANEOUS METHODS ///////////////////
	
		_onShow: function(){
			// summary:
			//		Internal method called when this widget is made visible.
			//		See `onShow` for details.
			this.onShow();
		},
	
		onShow: function(){
			// summary:
			//		Called when this widget becomes the selected pane in a
			//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
			//		`dijit/layout/AccordionContainer`, etc.
			//
			//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
		},
	
		onHide: function(){
			// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
			//		`dijit/layout/AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
		},
	
		onClose: function(){
			// summary:
			//		Called when this widget is being displayed as a popup (ex: a Calendar popped
			//		up from a DateTextBox), and it is hidden.
			//		This is called from the dijit.popup code, and should not be called directly.
			//
			//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
			//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
			// tags:
			//		extension
	
			return true;		// Boolean
		}
	});
	
	// For back-compat, remove in 2.0.
	
	return _Widget;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(18),
		__webpack_require__(28), 
		__webpack_require__(26), 
		__webpack_require__(1), 
		__webpack_require__(4), 
		__webpack_require__(82),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(on, array, keys, declare, has, a11yclick,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_OnDijitClickMixin", (function(){
	
		// module:
		//		dijit/_OnDijitClickMixin
	
		var ret = declare("dijit._OnDijitClickMixin", null, {
			// summary:
			//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
			//		|	this.own(on(node, a11yclick, function(){ ... }));
			//
			//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
			//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
			//		dijit/a11yclick.
	
			connect: function(obj, event, method){
				// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
				return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
			}
		});
	
		ret.a11yclick = a11yclick;	// back compat
	
		return ret;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(23), __webpack_require__(8), __webpack_require__(71), __webpack_require__(9), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_RESULT__ = function(geometry, lang, domReady, has, baseWindow){
	
		// module:
		//		dojo/uacss
	
		/*=====
		return {
			// summary:
			//		Applies pre-set CSS classes to the top-level HTML node, based on:
			//
			//		- browser (ex: dj_ie)
			//		- browser version (ex: dj_ie6)
			//		- box model (ex: dj_contentBox)
			//		- text direction (ex: dijitRtl)
			//
			//		In addition, browser, browser version, and box model are
			//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
			//
			//		Returns the has() method.
		};
		=====*/
	
		var
			html = baseWindow.doc.documentElement,
			ie = has("ie"),
			trident = has("trident"),
			opera = has("opera"),
			maj = Math.floor,
			ff = has("ff"),
			boxModel = geometry.boxModel.replace(/-/,''),
	
			classes = {
				"dj_quirks": has("quirks"),
	
				// NOTE: Opera not supported by dijit
				"dj_opera": opera,
	
				"dj_khtml": has("khtml"),
	
				"dj_webkit": has("webkit"),
				"dj_safari": has("safari"),
				"dj_chrome": has("chrome"),
				"dj_edge": has("edge"),
	
				"dj_gecko": has("mozilla"),
	
				"dj_ios": has("ios"),
				"dj_android": has("android")
			}; // no dojo unsupported browsers
	
		if(ie){
			classes["dj_ie"] = true;
			classes["dj_ie" + maj(ie)] = true;
			classes["dj_iequirks"] = has("quirks");
		}
		if(trident){
			classes["dj_trident"] = true;
			classes["dj_trident" + maj(trident)] = true;
		}
		if(ff){
			classes["dj_ff" + maj(ff)] = true;
		}
	
		classes["dj_" + boxModel] = true;
	
		// apply browser, browser version, and box model class names
		var classStr = "";
		for(var clz in classes){
			if(classes[clz]){
				classStr += clz + " ";
			}
		}
		html.className = lang.trim(html.className + " " + classStr);
	
		// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
		// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
		domReady(function(){
			if(!geometry.isBodyLtr()){
				var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
				html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
			}
		});
		return has;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(27), __webpack_require__(100), __webpack_require__(71), __webpack_require__(12),__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(domClass, has, domReady, win,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/hccss", (function(){
	
		// module:
		//		dijit/hccss
	
		/*=====
		return function(){
			// summary:
			//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
			//		Deprecated, use ``dojo/hccss`` instead.
		};
		=====*/
	
		domReady(function(){
			if(has("highcontrast")){
				domClass.add(win.body(), "dijit_a11y");
			}
		});
	
		return has;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(6),			
		__webpack_require__(7), 
		__webpack_require__(27), 
		__webpack_require__(15), 
		__webpack_require__(4),
		__webpack_require__(71),
		__webpack_require__(12) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(require, config, domClass, domStyle, has, domReady, win){
	
		// module:
		//		dojo/hccss
	
		/*=====
		return function(){
			// summary:
			//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
			//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
			//		Returns `has()` method;
		};
		=====*/
	
		// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
		has.add("highcontrast", function(){
			// note: if multiple documents, doesn't matter which one we use
			var div = win.doc.createElement("div");
			try{
				div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
					"background-image: url(\"" + (config.blankGif || require.toUrl("./resources/blank.gif")) + "\");";
				win.body().appendChild(div);
	
				var cs = domStyle.getComputedStyle(div),
					bkImg = cs.backgroundImage;
				return cs.borderTopColor == cs.borderRightColor ||
					(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
			}catch(e){
				console.warn("hccss: exception detecting high-contrast mode, document is likely hidden: " + e.toString());
				return false;
			}finally{
				if(has("ie") <= 8){
					div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
				}else{
					win.body().removeChild(div);
				}
			}
		});
	
		domReady(function(){
			if(has("highcontrast")){
				domClass.add(win.body(), "dj_a11y");
			}
		});
	
		return has;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 101 */,
/* 102 */,
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(11), 
		__webpack_require__(2),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, domConstruct, kernel,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_Container", (function(){
	
		// module:
		//		dijit/_Container
	
		return declare("dijit._Container", null, {
			// summary:
			//		Mixin for widgets that contain HTML and/or a set of widget children.
	
			buildRendering: function(){
				this.inherited(arguments);
				if(!this.containerNode){
					// All widgets with descendants must set containerNode.
					// NB: this code doesn't quite work right because for TabContainer it runs before
					// _TemplatedMixin::buildRendering(), and thus
					// sets this.containerNode to this.domNode, later to be overridden by the assignment in the template.
					this.containerNode = this.domNode;
				}
			},
	
			addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
				// summary:
				//		Makes the given widget a child of this widget.
				// description:
				//		Inserts specified child widget's dom node as a child of this widget's
				//		container node, and possibly does other processing (such as layout).
	
				// I want to just call domConstruct.place(widget.domNode, this.containerNode, insertIndex), but the counting
				// is thrown off by text nodes and comment nodes that show up when constructed by markup.
				// In the future consider stripping those nodes on construction, either in the parser or this widget code.
				var refNode = this.containerNode;
				if(insertIndex > 0){
					// Old-school way to get nth child; dojo.query would be easier but _Container was weened from dojo.query
					// in #10087 to minimize download size.   Not sure if that's still and issue with new smaller dojo/query.
					refNode = refNode.firstChild;
					while(insertIndex > 0){
						if(refNode.nodeType == 1){ insertIndex--; }
						refNode = refNode.nextSibling;
					}
					if(refNode){
						insertIndex = "before";
					}else{
						// to support addChild(child, n-1) where there are n children (should add child at end)
						refNode = this.containerNode;
						insertIndex = "last";
					}
				}
	
				domConstruct.place(widget.domNode, refNode, insertIndex);
	
				// If I've been started but the child widget hasn't been started,
				// start it now.  Make sure to do this after widget has been
				// inserted into the DOM tree, so it can see that it's being controlled by me,
				// so it doesn't try to size itself.
				if(this._started && !widget._started){
					widget.startup();
				}
			},
	
			removeChild: function(/*Widget|int*/ widget){
				// summary:
				//		Removes the passed widget instance from this widget but does
				//		not destroy it.  You can also pass in an integer indicating
				//		the index within the container to remove (ie, removeChild(5) removes the sixth widget).
	
				if(typeof widget == "number"){
					widget = this.getChildren()[widget];
				}
	
				if(widget){
					var node = widget.domNode;
					if(node && node.parentNode){
						node.parentNode.removeChild(node); // detach but don't destroy
					}
				}
			},
	
			hasChildren: function(){
				// summary:
				//		Returns true if widget has child widgets, i.e. if this.containerNode contains widgets.
				return this.getChildren().length > 0;	// Boolean
			},
	
			_getSiblingOfChild: function(/*dijit/_WidgetBase*/ child, /*int*/ dir){
				// summary:
				//		Get the next or previous widget sibling of child
				// dir:
				//		if 1, get the next sibling
				//		if -1, get the previous sibling
				// tags:
				//		private
				var children = this.getChildren(),
					idx = array.indexOf(children, child);	// int
				return children[idx + dir];
			},
	
			getIndexOfChild: function(/*dijit/_WidgetBase*/ child){
				// summary:
				//		Gets the index of the child in this container or -1 if not found
				return array.indexOf(this.getChildren(), child);	// int
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 104 */,
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(21),
		__webpack_require__(18),
		__webpack_require__(71),
		__webpack_require__(9),	
		__webpack_require__(91),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(Evented, on, domReady, has, winUtils,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/Viewport", (function(){
	
		// module:
		//		dijit/Viewport
	
		/*=====
		return {
			// summary:
			//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
			//		which can lead to infinite loops.
			// description:
			//		Usage: Viewport.on("resize", myCallback).
			//
			//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
			//		which would interpret the argument as the size to make the widget.
		};
		=====*/
	
		var Viewport = new Evented();
	
		var focusedNode;
	
		domReady(function(){
			var oldBox = winUtils.getBox();
			Viewport._rlh = on(window, "resize", function(){
				var newBox = winUtils.getBox();
				if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
				oldBox = newBox;
				Viewport.emit("resize");
			});
	
			// Also catch zoom changes on IE8, since they don't naturally generate resize events
			if(has("ie") == 8){
				var deviceXDPI = screen.deviceXDPI;
				setInterval(function(){
					if(screen.deviceXDPI != deviceXDPI){
						deviceXDPI = screen.deviceXDPI;
						Viewport.emit("resize");
					}
				}, 500);
			}
	
			// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
			if(has("ios")){
				on(document, "focusin", function(evt){
					focusedNode = evt.target;
				});
				on(document, "focusout", function(evt){
					focusedNode = null;
				});
			}
		});
	
		Viewport.getEffectiveBox = function(/*Document*/ doc){
			// summary:
			//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
			//		virtual keyboard.
	
			var box = winUtils.getBox(doc);
	
			// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
			var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
			if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
				/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){
	
				// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
				// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
				box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);
	
				// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
				// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
				// We know the visible size is at least the distance from the top of the viewport to the focused node.
				var rect = focusedNode.getBoundingClientRect();
				box.h = Math.max(box.h, rect.top + rect.height);
			}
	
			return box;
		};
	
		return Viewport;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(27), 
		__webpack_require__(23), 
		__webpack_require__(15), 
		__webpack_require__(8),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, domClass, domGeometry, domStyle, lang,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/layout/utils", (function(){
	
		// module:
		//		dijit/layout/utils
	
		function capitalize(word){
			return word.substring(0,1).toUpperCase() + word.substring(1);
		}
	
		function size(widget, dim){
			// size the child
			var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);
	
			// record child's size
			if(newSize){
				// if the child returned it's new size then use that
				lang.mixin(widget, newSize);
			}else{
				// otherwise, call getMarginBox(), but favor our own numbers when we have them.
				// the browser lies sometimes
				lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
				lang.mixin(widget, dim);
			}
		}
	
		var utils = {
			// summary:
			//		Utility functions for doing layout
	
			marginBox2contentBox: function(/*DomNode*/ node, /*Object*/ mb){
				// summary:
				//		Given the margin-box size of a node, return its content box size.
				//		Functions like domGeometry.contentBox() but is more reliable since it doesn't have
				//		to wait for the browser to compute sizes.
				var cs = domStyle.getComputedStyle(node);
				var me = domGeometry.getMarginExtents(node, cs);
				var pb = domGeometry.getPadBorderExtents(node, cs);
				return {
					l: domStyle.toPixelValue(node, cs.paddingLeft),
					t: domStyle.toPixelValue(node, cs.paddingTop),
					w: mb.w - (me.w + pb.w),
					h: mb.h - (me.h + pb.h)
				};
			},
	
	
			layoutChildren: function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
					/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
				// summary:
				//		Layout a bunch of child dom nodes within a parent dom node
				// container:
				//		parent node
				// dim:
				//		{l, t, w, h} object specifying dimensions of container into which to place children
				// children:
				//		An array of Widgets or at least objects containing:
				//
				//		- domNode: pointer to DOM node to position
				//		- region or layoutAlign: position to place DOM node
				//		- resize(): (optional) method to set size of node
				//		- id: (optional) Id of widgets, referenced from resize object, below.
				//
				//		The widgets in this array should be ordered according to how they should be laid out
				//		(each element will be processed in order, and take up as much remaining space as needed),
				//		with the center widget last.
				// changedRegionId:
				//		If specified, the slider for the region with the specified id has been dragged, and thus
				//		the region's height or width should be adjusted according to changedRegionSize
				// changedRegionSize:
				//		See changedRegionId.
	
				// copy dim because we are going to modify it
				dim = lang.mixin({}, dim);
	
				domClass.add(container, "dijitLayoutContainer");
	
				// Move "client" elements to the end of the array for layout.  a11y dictates that the author
				// needs to be able to put them in the document in tab-order, but this algorithm requires that
				// client be last.    TODO: remove for 2.0, all dijit client code already sends children as last item.
				children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
					.concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));
	
				// set positions/sizes
				array.forEach(children, function(child){
					var elm = child.domNode,
						pos = (child.region || child.layoutAlign);
					if(!pos){
						throw new Error("No region setting for " + child.id)
					}
	
					// set elem to upper left corner of unused space; may move it later
					var elmStyle = elm.style;
					elmStyle.left = dim.l+"px";
					elmStyle.top = dim.t+"px";
					elmStyle.position = "absolute";
	
					domClass.add(elm, "dijitAlign" + capitalize(pos));
	
					// Size adjustments to make to this child widget
					var sizeSetting = {};
	
					// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
					// panes and width adjustment for left/right align panes.
					if(changedRegionId && changedRegionId == child.id){
						sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
					}
	
					if(pos == "leading"){
						pos = child.isLeftToRight() ? "left" : "right";
					}
					if(pos == "trailing"){
						pos = child.isLeftToRight() ? "right" : "left";
					}
	
					// set size && adjust record of remaining space.
					// note that setting the width of a <div> may affect its height.
					if(pos == "top" || pos == "bottom"){
						sizeSetting.w = dim.w;
						size(child, sizeSetting);
						dim.h -= child.h;
						if(pos == "top"){
							dim.t += child.h;
						}else{
							elmStyle.top = dim.t + dim.h + "px";
						}
					}else if(pos == "left" || pos == "right"){
						sizeSetting.h = dim.h;
						size(child, sizeSetting);
						dim.w -= child.w;
						if(pos == "left"){
							dim.l += child.w;
						}else{
							elmStyle.left = dim.l + dim.w + "px";
						}
					}else if(pos == "client" || pos == "center"){
						size(child, dim);
					}
				});
			}
		};
	
		lang.setObject("dijit.layout.utils", utils);	// remove for 2.0
	
		return utils;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(6),
		__webpack_require__(1), 
		__webpack_require__(27), 
		__webpack_require__(4), 
		__webpack_require__(2), 
		__webpack_require__(8), 
		__webpack_require__(70),
		__webpack_require__(115),
		__webpack_require__(118),
		__webpack_require__(119),__webpack_require__(6),
		__webpack_require__(82)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(require, declare, domClass, has, kernel, lang, ready, _FormWidget, _ButtonMixin, template,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/Button", (function(){
	
		// module:
		//		dijit/form/Button
	
		// Back compat w/1.6, remove for 2.0
		
	
		var Button = declare("dijit.form.Button" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormWidget, _ButtonMixin], {
			// summary:
			//		Basically the same thing as a normal HTML button, but with special styling.
			// description:
			//		Buttons can display a label, an icon, or both.
			//		A label should always be specified (through innerHTML) or the label
			//		attribute.  It can be hidden via showLabel=false.
			// example:
			// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
			//
			// example:
			// |	var button1 = new Button({label: "hello world", onClick: foo});
			// |	dojo.body().appendChild(button1.domNode);
	
			// showLabel: Boolean
			//		Set this to true to hide the label text and display only the icon.
			//		(If showLabel=false then iconClass must be specified.)
			//		Especially useful for toolbars.
			//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
			//
			//		The exception case is for computers in high-contrast mode, where the label
			//		will still be displayed, since the icon doesn't appear.
			showLabel: true,
	
			// iconClass: String
			//		Class to apply to DOMNode in button to make it display an icon
			iconClass: "dijitNoIcon",
			_setIconClassAttr: { node: "iconNode", type: "class" },
	
			baseClass: "dijitButton",
	
			templateString: template,
	
			// Map widget attributes to DOMNode attributes.
			_setValueAttr: "valueNode",
			_setNameAttr: function(name){
				// avoid breaking existing subclasses where valueNode undefined.  Perhaps in 2.0 require it to be defined?
				if(this.valueNode){
					this.valueNode.setAttribute("name", name);
				}
			},
	
			postCreate: function(){
				this.inherited(arguments);
				this._setLabelFromContainer();
			},
	
			_setLabelFromContainer: function(){
				if(this.containerNode && !this.label){
					// When markup was set as srcNodeRef.innerHTML, copy it to this.label, in case someone tries to
					// reference that variable.  Alternately, could have a _getLabelAttr() method to return
					// this.containerNode.innerHTML.
					this.label = lang.trim(this.containerNode.innerHTML);
				}
				this.onLabelSet();		// set this.titleNode.title etc. according to label
			},
	
			_setShowLabelAttr: function(val){
				if(this.containerNode){
					domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
				}
				this._set("showLabel", val);
			},
	
			setLabel: function(/*String*/ content){
				// summary:
				//		Deprecated.  Use set('label', ...) instead.
				kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
				this.set("label", content);
			},
	
			onLabelSet: function(){
				this.inherited(arguments);
				if(!this.showLabel && !("title" in this.params)){
					this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
				}
			}
		});
	
		if(has("dojo-bidi")){
			Button = declare("dijit.form.Button", Button, {
				onLabelSet: function(){
					this.inherited(arguments);
					if(this.titleNode.title){
						this.applyTextDir(this.titleNode, this.titleNode.title);
					}
				},
	
				_setTextDirAttr: function(/*String*/ textDir){
					if(this._created && this.textDir != textDir){
						this._set("textDir", textDir);
						this._setLabelAttr(this.label); // call applyTextDir on both focusNode and titleNode
					}
				}
			});
		}
	
		return Button;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(9), 
		__webpack_require__(2), 
		__webpack_require__(70),
		__webpack_require__(96),
		__webpack_require__(116),
		__webpack_require__(76),
		__webpack_require__(117),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_FormWidget", (function(){
	
		// module:
		//		dijit/form/_FormWidget
	
		// Back compat w/1.6, remove for 2.0
		
	
		return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
			// summary:
			//		Base class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
			//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
			//
			// description:
			//		Represents a single HTML element.
			//		All these widgets should have these attributes just like native HTML input elements.
			//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
			//
			//		They also share some common methods.
	
			setDisabled: function(/*Boolean*/ disabled){
				// summary:
				//		Deprecated.  Use set('disabled', ...) instead.
				kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
				this.set('disabled', disabled);
			},
	
			setValue: function(/*String*/ value){
				// summary:
				//		Deprecated.  Use set('value', ...) instead.
				kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
				this.set('value', value);
			},
	
			getValue: function(){
				// summary:
				//		Deprecated.  Use get('value') instead.
				kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
				return this.get('value');
			},
	
			postMixInProperties: function(){
				// Setup name=foo string to be referenced from the template (but only if a name has been specified).
				// Unfortunately we can't use _setNameAttr to set the name in IE due to IE limitations, see #8484, #8660.
				// But when IE6 and IE7 are desupported, then we probably don't need this anymore, so should remove it in 2.0.
				// Also, don't do this for Windows 8 Store Apps because it causes a security exception (see #16452).
				// Regarding escaping, see heading "Attribute values" in
				// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
				this.nameAttrSetting = (this.name && !has("msapp")) ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
				this.inherited(arguments);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(27), 
		__webpack_require__(4),
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(71),
		__webpack_require__(81),
		__webpack_require__(12), 
		__webpack_require__(82),
		__webpack_require__(74),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_CssStateMixin", (function(){
	
		// module:
		//		dijit/_CssStateMixin
	
		var CssStateMixin = declare("dijit._CssStateMixin", [], {
			// summary:
			//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
			//		state changes, and also higher-level state changes such becoming disabled or selected.
			//
			// description:
			//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
			//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
			//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
			//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
			//
			//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
			//
			//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
			//		within the widget).
	
			/*=====
			 // cssStateNodes: [protected] Object
			 //		Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
			 //		need CSS classes applied on mouse hover/press and focus.
			 //
			 //		Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
			 //		(like "dijitUpArrowButton"). Example:
			 //	|		{
			 //	|			"upArrowButton": "dijitUpArrowButton",
			 //	|			"downArrowButton": "dijitDownArrowButton"
			 //	|		}
			 //		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
			 //		is hovered, etc.
			 cssStateNodes: {},
			 =====*/
	
			// hovering: [readonly] Boolean
			//		True if cursor is over this widget
			hovering: false,
	
			// active: [readonly] Boolean
			//		True if mouse was pressed while over this widget, and hasn't been released yet
			active: false,
	
			_applyAttributes: function(){
				// This code would typically be in postCreate(), but putting in _applyAttributes() for
				// performance: so the class changes happen before DOM is inserted into the document.
				// Change back to postCreate() in 2.0.  See #11635.
	
				this.inherited(arguments);
	
				// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
				array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function(attr){
					this.watch(attr, lang.hitch(this, "_setStateClass"));
				}, this);
	
				// Track hover and active mouse events on widget root node, plus possibly on subnodes
				for(var ap in this.cssStateNodes || {}){
					this._trackMouseState(this[ap], this.cssStateNodes[ap]);
				}
				this._trackMouseState(this.domNode, this.baseClass);
	
				// Set state initially; there's probably no hover/active/focus state but widget might be
				// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
				this._setStateClass();
			},
	
			_cssMouseEvent: function(/*Event*/ event){
				// summary:
				//		Handler for CSS event on this.domNode. Sets hovering and active properties depending on mouse state,
				//		which triggers _setStateClass() to set appropriate CSS classes for this.domNode.
	
				if(!this.disabled){
					switch(event.type){
						case "mouseover":
						case "MSPointerOver":
						case "pointerover":
							this._set("hovering", true);
							this._set("active", this._mouseDown);
							break;
						case "mouseout":
						case "MSPointerOut":
						case "pointerout":
							this._set("hovering", false);
							this._set("active", false);
							break;
						case "mousedown":
						case "touchstart":
						case "MSPointerDown":
						case "pointerdown":
						case "keydown":
							this._set("active", true);
							break;
						case "mouseup":
						case "dojotouchend":
						case "MSPointerUp":
						case "pointerup":
						case "keyup":
							this._set("active", false);
							break;
					}
				}
			},
	
			_setStateClass: function(){
				// summary:
				//		Update the visual state of the widget by setting the css classes on this.domNode
				//		(or this.stateNode if defined) by combining this.baseClass with
				//		various suffixes that represent the current widget state(s).
				//
				// description:
				//		In the case where a widget has multiple
				//		states, it sets the class based on all possible
				//		combinations.  For example, an invalid form widget that is being hovered
				//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
				//
				//		The widget may have one or more of the following states, determined
				//		by this.state, this.checked, this.valid, and this.selected:
				//
				//		- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
				//		- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
				//		- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
				//		- Selected - ex: currently selected tab will have this.selected==true
				//
				//		In addition, it may have one or more of the following states,
				//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
				//
				//		- Disabled	- if the widget is disabled
				//		- Active		- if the mouse (or space/enter key?) is being pressed down
				//		- Focused		- if the widget has focus
				//		- Hover		- if the mouse is over the widget
	
				// Compute new set of classes
				var newStateClasses = this.baseClass.split(" ");
	
				function multiply(modifier){
					newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){
						return c + modifier;
					}), "dijit" + modifier);
				}
	
				if(!this.isLeftToRight()){
					// For RTL mode we need to set an addition class like dijitTextBoxRtl.
					multiply("Rtl");
				}
	
				var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
				if(this.checked){
					multiply(checkedState);
				}
				if(this.state){
					multiply(this.state);
				}
				if(this.selected){
					multiply("Selected");
				}
				if(this._opened){
					multiply("Opened");
				}
	
				if(this.disabled){
					multiply("Disabled");
				}else if(this.readOnly){
					multiply("ReadOnly");
				}else{
					if(this.active){
						multiply("Active");
					}else if(this.hovering){
						multiply("Hover");
					}
				}
	
				if(this.focused){
					multiply("Focused");
				}
	
				// Remove old state classes and add new ones.
				// For performance concerns we only write into domNode.className once.
				var tn = this.stateNode || this.domNode,
					classHash = {};	// set of all classes (state and otherwise) for node
	
				array.forEach(tn.className.split(" "), function(c){
					classHash[c] = true;
				});
	
				if("_stateClasses" in this){
					array.forEach(this._stateClasses, function(c){
						delete classHash[c];
					});
				}
	
				array.forEach(newStateClasses, function(c){
					classHash[c] = true;
				});
	
				var newClasses = [];
				for(var c in classHash){
					newClasses.push(c);
				}
				tn.className = newClasses.join(" ");
	
				this._stateClasses = newStateClasses;
			},
	
			_subnodeCssMouseEvent: function(node, clazz, evt){
				// summary:
				//		Handler for hover/active mouse event on widget's subnode
				if(this.disabled || this.readOnly){
					return;
				}
	
				function hover(isHovering){
					domClass.toggle(node, clazz + "Hover", isHovering);
				}
	
				function active(isActive){
					domClass.toggle(node, clazz + "Active", isActive);
				}
	
				function focused(isFocused){
					domClass.toggle(node, clazz + "Focused", isFocused);
				}
	
				switch(evt.type){
					case "mouseover":
					case "MSPointerOver":
					case "pointerover":
						hover(true);
						break;
					case "mouseout":
					case "MSPointerOut":
					case "pointerout":
						hover(false);
						active(false);
						break;
					case "mousedown":
					case "touchstart":
					case "MSPointerDown":
					case "pointerdown":
					case "keydown":
						active(true);
						break;
					case "mouseup":
					case "MSPointerUp":
					case "pointerup":
					case "dojotouchend":
					case "keyup":
						active(false);
						break;
					case "focus":
					case "focusin":
						focused(true);
						break;
					case "blur":
					case "focusout":
						focused(false);
						break;
				}
			},
	
			_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
				// summary:
				//		Track mouse/focus events on specified node and set CSS class on that node to indicate
				//		current state.   Usually not called directly, but via cssStateNodes attribute.
				// description:
				//		Given class=foo, will set the following CSS class on the node
				//
				//		- fooActive: if the user is currently pressing down the mouse button while over the node
				//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
				//		- fooFocus: if the node is focused
				//
				//		Note that it won't set any classes if the widget is disabled.
				// node: DomNode
				//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
				//		is handled specially and automatically just by mixing in this class.
				// clazz: String
				//		CSS class name (ex: dijitSliderUpArrow)
	
				// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
				// when node is hovered/active
				node._cssState = clazz;
			}
		});
	
		domReady(function(){
			// Document level listener to catch hover etc. events on widget root nodes and subnodes.
			// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
			// have been hovered or unhovered (try test_Accordion.html)
	
			function pointerHandler(evt, target, relatedTarget){
				// Handler for mouseover, mouseout, a11yclick.press and a11click.release events
	
				// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
				// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
				// such events shouldn't be interpreted as a mouseleave on the widget.
				if(relatedTarget && dom.isDescendant(relatedTarget, target)){
					return;
				}
	
				for(var node = target; node && node != relatedTarget; node = node.parentNode){
					// Process any nodes with _cssState property.   They are generally widget root nodes,
					// but could also be sub-nodes within a widget
					if(node._cssState){
						var widget = registry.getEnclosingWidget(node);
						if(widget){
							if(node == widget.domNode){
								// event on the widget's root node
								widget._cssMouseEvent(evt);
							}else{
								// event on widget's sub-node
								widget._subnodeCssMouseEvent(node, node._cssState, evt);
							}
						}
					}
				}
			}
	
			var body = win.body(), activeNode;
	
			// Handle pointer related events (i.e. mouse or touch)
			on(body, touch.over, function(evt){
				// Using touch.over rather than mouseover mainly to ignore phantom mouse events on iOS.
				pointerHandler(evt, evt.target, evt.relatedTarget);
			});
			on(body, touch.out, function(evt){
				// Using touch.out rather than mouseout mainly to ignore phantom mouse events on iOS.
				pointerHandler(evt, evt.target, evt.relatedTarget);
			});
			on(body, a11yclick.press, function(evt){
				// Save the a11yclick.press target to reference when the a11yclick.release comes.
				activeNode = evt.target;
				pointerHandler(evt, activeNode)
			});
			on(body, a11yclick.release, function(evt){
				// The release event could come on a separate node than the press event, if for example user slid finger.
				// Reference activeNode to reset the state of the node that got state set in the a11yclick.press handler.
				pointerHandler(evt, activeNode);
				activeNode = null;
			});
	
			// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
			// However, don't track focus events on the widget root nodes, because focus is tracked via the
			// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
			// nodes or a subwidget's node or a popup node, etc.)
			// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
			on(body, "focusin, focusout", function(evt){
				var node = evt.target;
				if(node._cssState && !node.getAttribute("widgetId")){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						widget._subnodeCssMouseEvent(node, node._cssState, evt);
					}
				}
			});
		});
	
		return CssStateMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(14), 
		__webpack_require__(15), 
		__webpack_require__(8), 
		__webpack_require__(24), 
		__webpack_require__(18),
		__webpack_require__(9), 
		__webpack_require__(91), 
		__webpack_require__(92),__webpack_require__(6)    
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_FormWidgetMixin", (function(){
	
		// module:
		//		dijit/form/_FormWidgetMixin
	
		return declare("dijit.form._FormWidgetMixin", null, {
			// summary:
			//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
			//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
			//
			// description:
			//		Represents a single HTML element.
			//		All these widgets should have these attributes just like native HTML input elements.
			//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
			//
			//		They also share some common methods.
	
			// name: [const] String
			//		Name used when submitting form; same as "name" attribute or plain HTML elements
			name: "",
	
			// alt: String
			//		Corresponds to the native HTML `<input>` element's attribute.
			alt: "",
	
			// value: String
			//		Corresponds to the native HTML `<input>` element's attribute.
			value: "",
	
			// type: [const] String
			//		Corresponds to the native HTML `<input>` element's attribute.
			type: "text",
	
			// type: String
			//		Apply aria-label in markup to the widget's focusNode
			"aria-label": "focusNode",
	
			// tabIndex: String
			//		Order fields are traversed when user hits the tab key
			tabIndex: "0",
			_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>
	
			// disabled: Boolean
			//		Should this widget respond to user input?
			//		In markup, this is specified as "disabled='disabled'", or just "disabled".
			disabled: false,
	
			// intermediateChanges: Boolean
			//		Fires onChange for each value change or only on demand
			intermediateChanges: false,
	
			// scrollOnFocus: Boolean
			//		On focus, should this widget scroll into view?
			scrollOnFocus: true,
	
			// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
			// works with screen reader
			_setIdAttr: "focusNode",
	
			_setDisabledAttr: function(/*Boolean*/ value){
				this._set("disabled", value);
	
				// Set disabled property if focusNode is an <input>, but aria-disabled attribute if focusNode is a <span>.
				// Can't use "disabled" in this.focusNode as a test because on IE, that's true for all nodes.
				if(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(this.focusNode.tagName)){
					domAttr.set(this.focusNode, 'disabled', value);
				}else{
					this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
				}
	
				// And also set disabled on the hidden <input> node
				if(this.valueNode){
					domAttr.set(this.valueNode, 'disabled', value);
				}
	
				if(value){
					// reset these, because after the domNode is disabled, we can no longer receive
					// mouse related events, see #4200
					this._set("hovering", false);
					this._set("active", false);
	
					// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
					var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
						("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
					array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
						var node = this[attachPointName];
						// complex code because tabIndex=-1 on a <div> doesn't work on FF
						if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
							node.setAttribute('tabIndex', "-1");
						}else{
							node.removeAttribute('tabIndex');
						}
					}, this);
				}else{
					if(this.tabIndex != ""){
						this.set('tabIndex', this.tabIndex);
					}
				}
			},
	
			_onFocus: function(/*String*/ by){
				// If user clicks on the widget, even if the mouse is released outside of it,
				// this widget's focusNode should get focus (to mimic native browser behavior).
				// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
				// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
				if(by == "mouse" && this.isFocusable()){
					// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
					var focusHandle = this.own(on(this.focusNode, "focus", function(){
						mouseUpHandle.remove();
						focusHandle.remove();
					}))[0];
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
						has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
						"mouseup";
					var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
						mouseUpHandle.remove();
						focusHandle.remove();
						// if here, then the mousedown did not focus the focusNode as the default action
						if(this.focused){
							if(evt.type == "touchend"){
								this.defer("focus"); // native focus hasn't occurred yet
							}else{
								this.focus(); // native focus already occurred on mousedown
							}
						}
					})))[0];
				}
				if(this.scrollOnFocus){
					this.defer(function(){
						winUtils.scrollIntoView(this.domNode);
					}); // without defer, the input caret position can change on mouse click
				}
				this.inherited(arguments);
			},
	
			isFocusable: function(){
				// summary:
				//		Tells if this widget is focusable or not.  Used internally by dijit.
				// tags:
				//		protected
				return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
			},
	
			focus: function(){
				// summary:
				//		Put focus on this widget
				if(!this.disabled && this.focusNode.focus){
					try{
						this.focusNode.focus();
					}catch(e){
					}
					/*squelch errors from hidden nodes*/
				}
			},
	
			compare: function(/*anything*/ val1, /*anything*/ val2){
				// summary:
				//		Compare 2 values (as returned by get('value') for this widget).
				// tags:
				//		protected
				if(typeof val1 == "number" && typeof val2 == "number"){
					return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
				}else if(val1 > val2){
					return 1;
				}else if(val1 < val2){
					return -1;
				}else{
					return 0;
				}
			},
	
			onChange: function(/*===== newValue =====*/){
				// summary:
				//		Callback when this widget's value is changed.
				// tags:
				//		callback
			},
	
			// _onChangeActive: [private] Boolean
			//		Indicates that changes to the value should call onChange() callback.
			//		This is false during widget initialization, to avoid calling onChange()
			//		when the initial value is set.
			_onChangeActive: false,
	
			_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
				// summary:
				//		Called when the value of the widget is set.  Calls onChange() if appropriate
				// newValue:
				//		the new value
				// priorityChange:
				//		For a slider, for example, dragging the slider is priorityChange==false,
				//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
				//		onChange is only called form priorityChange=true events.
				// tags:
				//		private
				if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
					// this block executes not for a change, but during initialization,
					// and is used to store away the original value (or for ToggleButton, the original checked state)
					this._resetValue = this._lastValueReported = newValue;
				}
				this._pendingOnChange = this._pendingOnChange
					|| (typeof newValue != typeof this._lastValueReported)
					|| (this.compare(newValue, this._lastValueReported) != 0);
				if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
					this._lastValueReported = newValue;
					this._pendingOnChange = false;
					if(this._onChangeActive){
						if(this._onChangeHandle){
							this._onChangeHandle.remove();
						}
						// defer allows hidden value processing to run and
						// also the onChange handler can safely adjust focus, etc
						this._onChangeHandle = this.defer(
							function(){
								this._onChangeHandle = null;
								this.onChange(newValue);
							}); // try to collapse multiple onChange's fired faster than can be processed
					}
				}
			},
	
			create: function(){
				// Overrides _Widget.create()
				this.inherited(arguments);
				this._onChangeActive = true;
			},
	
			destroy: function(){
				if(this._onChangeHandle){ // destroy called before last onChange has fired
					this._onChangeHandle.remove();
					this.onChange(this._lastValueReported);
				}
				this.inherited(arguments);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(4),
		__webpack_require__(74),__webpack_require__(6)        
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, dom, has, registry,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_ButtonMixin", (function(){
	
		// module:
		//		dijit/form/_ButtonMixin
	
		var ButtonMixin = declare("dijit.form._ButtonMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
			// summary:
			//		A mixin to add a thin standard API wrapper to a normal HTML button
			// description:
			//		A label should always be specified (through innerHTML) or the label attribute.
			//
			//		Attach points:
			//
			//		- focusNode (required): this node receives focus
			//		- valueNode (optional): this node's value gets submitted with FORM elements
			//		- containerNode (optional): this node gets the innerHTML assignment for label
			// example:
			// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
			// example:
			// |	var button1 = new Button({label: "hello world", onClick: foo});
			// |	dojo.body().appendChild(button1.domNode);
	
			// label: HTML String
			//		Content to display in button.
			label: "",
	
			// type: [const] String
			//		Type of button (submit, reset, button, checkbox, radio)
			type: "button",
	
			__onClick: function(/*Event*/ e){
				// summary:
				//		Internal function to divert the real click onto the hidden INPUT that has a native default action associated with it
				// type:
				//		private
				e.stopPropagation();
				e.preventDefault();
				if(!this.disabled){
					// cannot use on.emit since button default actions won't occur
					this.valueNode.click(e);
				}
				return false;
			},
	
			_onClick: function(/*Event*/ e){
				// summary:
				//		Internal function to handle click actions
				if(this.disabled){
					e.stopPropagation();
					e.preventDefault();
					return false;
				}
				if(this.onClick(e) === false){
					e.preventDefault();
				}
				var cancelled = e.defaultPrevented;
	
				// Signal Form/Dialog to submit/close.  For 2.0, consider removing this code and instead making the Form/Dialog
				// listen for bubbled click events where evt.target.type == "submit" && !evt.defaultPrevented.
				if(!cancelled && this.type == "submit" && !(this.valueNode || this.focusNode).form){
					for(var node = this.domNode; node.parentNode; node = node.parentNode){
						var widget = registry.byNode(node);
						if(widget && typeof widget._onSubmit == "function"){
							widget._onSubmit(e);
							e.preventDefault(); // action has already occurred
							cancelled = true;
							break;
						}
					}
				}
	
				return !cancelled;
			},
	
			postCreate: function(){
				this.inherited(arguments);
				dom.setSelectable(this.focusNode, false);
			},
	
			onClick: function(/*Event*/ /*===== e =====*/){
				// summary:
				//		Callback for when button is clicked.
				//		If type="submit", return true to perform submit, or false to cancel it.
				// type:
				//		callback
				return true;		// Boolean
			},
	
			_setLabelAttr: function(/*String*/ content){
				// summary:
				//		Hook for set('label', ...) to work.
				// description:
				//		Set the label (text) of the button; takes an HTML string.
				this._set("label", content);
				var labelNode = this.containerNode || this.focusNode;
				labelNode.innerHTML = content;
				this.onLabelSet();
			},
	
			onLabelSet: function(){
			}
		});
	
		if(has("dojo-bidi")){
			ButtonMixin = declare("dijit.form._ButtonMixin", ButtonMixin, {
				onLabelSet: function(){
					this.inherited(arguments);
					var labelNode = this.containerNode || this.focusNode;
					this.applyTextDir(labelNode);
				}
			});
		}
	
		return ButtonMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = "<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\r\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\r\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\"\r\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\r\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\r\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\tid=\"${id}_label\"\r\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\r\n\t\t\t></span\r\n\t\t></span\r\n\t></span\r\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\r\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\r\n\t\ttabIndex=\"-1\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"\r\n/></span>\r\n"

/***/ },
/* 120 */,
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(6), __webpack_require__(4), __webpack_require__(28), __webpack_require__(7), __webpack_require__(8), __webpack_require__(122), __webpack_require__(51), module], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, require, has, array, config, lang, xhr, json, module){module={id:"dojo/i18n"}
	
		// module:
		//		dojo/i18n
	
		has.add("dojo-preload-i18n-Api",
			// if true, define the preload localizations machinery
			1
		);
	
		has.add("dojo-v1x-i18n-Api",
			// if true, define the v1.x i18n functions
			1
		);
	
		var
			thisModule = dojo.i18n =
				{
					// summary:
					//		This module implements the dojo/i18n! plugin and the v1.6- i18n API
					// description:
					//		We choose to include our own plugin to leverage functionality already contained in dojo
					//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
					//		allows foreign AMD loaders to be used without their plugins.
				},
	
			nlsRe =
				// regexp for reconstructing the master bundle name from parts of the regexp match
				// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
				// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
				// nlsRe.exec("foo/bar/baz/nls/foo") gives:
				// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
				// so, if match[5] is blank, it means this is the top bundle definition.
				// courtesy of http://requirejs.org
				/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,
	
			getAvailableLocales = function(
				root,
				locale,
				bundlePath,
				bundleName
			){
				// summary:
				//		return a vector of module ids containing all available locales with respect to the target locale
				//		For example, assuming:
				//
				//		- the root bundle indicates specific bundles for "fr" and "fr-ca",
				//		-  bundlePath is "myPackage/nls"
				//		- bundleName is "myBundle"
				//
				//		Then a locale argument of "fr-ca" would return
				//
				//			["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
				//
				//		Notice that bundles are returned least-specific to most-specific, starting with the root.
				//
				//		If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
				//		therefore, assume everything is available and get 404 errors that indicate a particular localization is not available
	
				for(var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i<localeParts.length; i++){
					current += (current ? "-" : "") + localeParts[i];
					if(!root || root[current]){
						result.push(bundlePath + current + "/" + bundleName);
						result.specificity = current;
					}
				}
				return result;
			},
	
			cache = {},
	
			getBundleName = function(moduleName, bundleName, locale){
				locale = locale ? locale.toLowerCase() : dojo.locale;
				moduleName = moduleName.replace(/\./g, "/");
				bundleName = bundleName.replace(/\./g, "/");
				return (/root/i.test(locale)) ?
					(moduleName + "/nls/" + bundleName) :
					(moduleName + "/nls/" + locale + "/" + bundleName);
			},
	
			getL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){
				return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
			},
	
			doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
				// summary:
				//		get the root bundle which instructs which other bundles are required to construct the localized bundle
				require([bundlePathAndName], function(root){
					var current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT
						availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
					require(availableLocales, function(){
						for (var i = 1; i<availableLocales.length; i++){
							current = lang.mixin(lang.clone(current), arguments[i]);
						}
						// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
						var target = bundlePathAndName + "/" + locale;
						cache[target] = current;
						current.$locale = availableLocales.specificity;
						load();
					});
				});
			},
	
			normalize = function(id, toAbsMid){
				// summary:
				//		id may be relative.
				//		preload has form `*preload*<path>/nls/<module>*<flattened locales>` and
				//		therefore never looks like a relative
				return /^\./.test(id) ? toAbsMid(id) : id;
			},
	
			getLocalesToLoad = function(targetLocale){
				var list = config.extraLocale || [];
				list = lang.isArray(list) ? list : [list];
				list.push(targetLocale);
				return list;
			},
	
			load = function(id, require, load){
				// summary:
				//		id is in one of the following formats
				//
				//		1. <path>/nls/<bundle>
				//			=> load the bundle, localized to config.locale; load all bundles localized to
				//			config.extraLocale (if any); return the loaded bundle localized to config.locale.
				//
				//		2. <path>/nls/<locale>/<bundle>
				//			=> load then return the bundle localized to <locale>
				//
				//		3. *preload*<path>/nls/<module>*<JSON array of available locales>
				//			=> for config.locale and all config.extraLocale, load all bundles found
				//			in the best-matching bundle rollup. A value of 1 is returned, which
				//			is meaningless other than to say the plugin is executing the requested
				//			preloads
				//
				//		In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
				//		normalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.
				//
				//		To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
				//		value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
				//
				//			<path>/nls/<bundle>/<locale>
				//
				//		will hold the value. Similarly, then plugin will publish this value to the loader by
				//
				//			define("<path>/nls/<bundle>/<locale>", <bundle-value>);
				//
				//		Given this algorithm, other machinery can provide fast load paths be preplacing
				//		values in the plugin's cache, which is public. When a load is demanded the
				//		cache is inspected before starting any loading. Explicitly placing values in the plugin
				//		cache is an advanced/experimental feature that should not be needed; use at your own risk.
				//
				//		For the normal AMD algorithm, the root bundle is loaded first, which instructs the
				//		plugin what additional localized bundles are required for a particular locale. These
				//		additional locales are loaded and a mix of the root and each progressively-specific
				//		locale is returned. For example:
				//
				//		1. The client demands "dojo/i18n!some/path/nls/someBundle
				//
				//		2. The loader demands load(some/path/nls/someBundle)
				//
				//		3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
				//
				//		4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
				//		are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
				//		requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
				//
				//		5. Upon receiving all required bundles, the plugin constructs the value of the bundle
				//		ab-cd-ef as...
				//
				//				mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
				//		  			require("some/path/nls/ab/someBundle")),
				//					require("some/path/nls/ab-cd-ef/someBundle"));
				//
				//		This value is inserted into the cache and published to the loader at the
				//		key/module-id some/path/nls/someBundle/ab-cd-ef.
				//
				//		The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
				//		(further preload requests will be serviced) until all ongoing preloading has completed.
				//
				//		The preload signature instructs the plugin that a special rollup module is available that contains
				//		one or more flattened, localized bundles. The JSON array of available locales indicates which locales
				//		are available. Here is an example:
				//
				//			*preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
				//
				//		This indicates the following rollup modules are available:
				//
				//			some/path/nls/someModule_ROOT
				//			some/path/nls/someModule_ab
				//			some/path/nls/someModule_ab-cd-ef
				//
				//		Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
				//		For example, assume someModule contained the bundles some/bundle/path/someBundle and
				//		some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
				//
				//			define({
				//				some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
				//				some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
				//			});
				//
				//		E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
				//
				//			require(["some/path/nls/someModule_ab"], function(rollup){
				//				for(var p in rollup){
				//					var id = p + "/ab",
				//					cache[id] = rollup[p];
				//					define(id, rollup[p]);
				//				}
				//			});
				//
				//		Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
				//		load accordingly.
				//
				//		The builder will write such rollups for every layer if a non-empty localeList  profile property is
				//		provided. Further, the builder will include the following cache entry in the cache associated with
				//		any layer.
				//
				//			"*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
				//
				//		The *now special cache module instructs the loader to apply the provided function to context-require
				//		with respect to the particular layer being defined. This causes the plugin to hold all normal service
				//		requests until all preloading is complete.
				//
				//		Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
				//		where the target locale has a single segment and a layer depends on a single bundle:
				//
				//		Without Preloads:
				//
				//		1. Layer loads root bundle.
				//		2. bundle is demanded; plugin loads single localized bundle.
				//
				//		With Preloads:
				//
				//		1. Layer causes preloading of target bundle.
				//		2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
				//
				//		In each case a single transaction is required to load the target bundle. In cases where multiple bundles
				//		are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
				//		the normal path requires an additional transaction for each additional bundle/locale-segment. However all
				//		of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
				//		algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.
	
				if(has("dojo-preload-i18n-Api")){
					var split = id.split("*"),
						preloadDemand = split[1] == "preload";
					if(preloadDemand){
						if(!cache[id]){
							// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
							// who knows what over-aggressive human optimizers may attempt
							cache[id] = 1;
							preloadL10n(split[2], json.parse(split[3]), 1, require);
						}
						// don't stall the loader!
						load(1);
					}
					if(preloadDemand || waitForPreloads(id, require, load)){
						return;
					}
				}
	
				var match = nlsRe.exec(id),
					bundlePath = match[1] + "/",
					bundleName = match[5] || match[4],
					bundlePathAndName = bundlePath + bundleName,
					localeSpecified = (match[5] && match[4]),
					targetLocale =	localeSpecified || dojo.locale || "",
					loadTarget = bundlePathAndName + "/" + targetLocale,
					loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
					remaining = loadList.length,
					finish = function(){
						if(!--remaining){
							load(lang.delegate(cache[loadTarget]));
						}
					};
				array.forEach(loadList, function(locale){
					var target = bundlePathAndName + "/" + locale;
					if(has("dojo-preload-i18n-Api")){
						checkForLegacyModules(target);
					}
					if(!cache[target]){
						doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
					}else{
						finish();
					}
				});
			};
	
		if(has("dojo-preload-i18n-Api") || has("dojo-v1x-i18n-Api")){
			var normalizeLocale = thisModule.normalizeLocale = function(locale){
					var result = locale ? locale.toLowerCase() : dojo.locale;
					return result == "root" ? "ROOT" : result;
				},
	
				isXd = function(mid, contextRequire){
					return (has("dojo-sync-loader") && has("dojo-v1x-i18n-Api")) ?
						contextRequire.isXdUrl(require.toUrl(mid + ".js")) :
						true;
				},
	
				preloading = 0,
	
				preloadWaitQueue = [],
	
				preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){
					// summary:
					//		Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
					// description:
					//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
					//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
					//		in that the v1.6- would only load ab-cd...which was *always* flattened.
					//
					//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
					//		and the extra possible extra transaction.
	
					// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
					// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
					// itself may have been mapped.
					contextRequire = contextRequire || require;
	
					function doRequire(mid, callback){
						if(isXd(mid, contextRequire) || guaranteedAmdFormat){
							contextRequire([mid], callback);
						}else{
							syncRequire([mid], callback, contextRequire);
						}
					}
	
					function forEachLocale(locale, func){
						// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
						var parts = locale.split("-");
						while(parts.length){
							if(func(parts.join("-"))){
								return;
							}
							parts.pop();
						}
						func("ROOT");
					}
	
						function preloadingAddLock(){
							preloading++;
						}
	
						function preloadingRelLock(){
							--preloading;
							while(!preloading && preloadWaitQueue.length){
								load.apply(null, preloadWaitQueue.shift());
							}
						}
	
						function cacheId(path, name, loc, require){
							// path is assumed to have a trailing "/"
							return require.toAbsMid(path + name + "/" + loc)
						}
	
						function preload(locale){
							locale = normalizeLocale(locale);
							forEachLocale(locale, function(loc){
								if(array.indexOf(localesGenerated, loc) >= 0){
									var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
									preloadingAddLock();
									doRequire(mid, function(rollup){
										for(var p in rollup){
											var bundle = rollup[p],
												match = p.match(/(.+)\/([^\/]+)$/),
												bundleName, bundlePath;
												
												// If there is no match, the bundle is not a regular bundle from an AMD layer.
												if (!match){continue;}
	
												bundleName = match[2];
												bundlePath = match[1] + "/";
	
											// backcompat
											if(!bundle._localized){continue;}
	
											var localized;
											if(loc === "ROOT"){
												var root = localized = bundle._localized;
												delete bundle._localized;
												root.root = bundle;
												cache[require.toAbsMid(p)] = root;
											}else{
												localized = bundle._localized;
												cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
											}
	
											if(loc !== locale){
												// capture some locale variables
												function improveBundle(bundlePath, bundleName, bundle, localized){
													// locale was not flattened and we've fallen back to a less-specific locale that was flattened
													// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and
													// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by
													// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'
													// version of the bundle.
													//
													// Remember, different bundles may have different sets of locales available.
													//
													// we are really falling back on the regular algorithm here, but--hopefully--starting with most
													// of the required bundles already on board as given by the rollup and we need to "manually" load
													// only one locale from a few bundles...or even better...we won't find anything better to load.
													// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.
													//
													// note: this feature is only available in async mode
	
													// inspect the loaded bundle that came from the rollup to see if something better is available
													// for any bundle in a rollup, more-specific available locales are given at localized.
													var requiredBundles = [],
														cacheIds = [];
													forEachLocale(locale, function(loc){
														if(localized[loc]){
															requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
															cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
														}
													});
	
													if(requiredBundles.length){
														preloadingAddLock();
														contextRequire(requiredBundles, function(){
															// requiredBundles was constructed by forEachLocale so it contains locales from 
															// less specific to most specific. 
															// the loop starts with the most specific locale, the last one.
															for(var i = requiredBundles.length - 1; i >= 0 ; i--){
																bundle = lang.mixin(lang.clone(bundle), arguments[i]);
																cache[cacheIds[i]] = bundle;
															}
															// this is the best possible (maybe a perfect match, maybe not), accept it
															cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
															preloadingRelLock();
														});
													}else{
														// this is the best possible (definitely not a perfect match), accept it
														cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
													}
												}
												improveBundle(bundlePath, bundleName, bundle, localized);
											}
										}
										preloadingRelLock();
									});
									return true;
								}
								return false;
							});
						}
	
					preload();
					array.forEach(dojo.config.extraLocale, preload);
				},
	
				waitForPreloads = function(id, require, load){
					if(preloading){
						preloadWaitQueue.push([id, require, load]);
					}
					return preloading;
				},
	
				checkForLegacyModules = function()
					{};
		}
	
		if(has("dojo-v1x-i18n-Api")){
			// this code path assumes the dojo loader and won't work with a standard AMD loader
			var amdValue = {},
				evalBundle =
					// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
					new Function(
						"__bundle",				   // the bundle to evalutate
						"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
						"__mid",				   // the mid that __bundle is intended to define
						"__amdValue",
	
						// returns one of:
						//		1 => the bundle was an AMD bundle
						//		a legacy bundle object that is the value of __mid
						//		instance of Error => could not figure out how to evaluate bundle
	
						  // used to detect when __bundle calls define
						  "var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},"
						+ "	   require = function(){define.called = 1;};"
	
						+ "try{"
						+		"define.called = 0;"
						+		"eval(__bundle);"
						+		"if(define.called==1)"
									// bundle called define; therefore signal it's an AMD bundle
						+			"return __amdValue;"
	
						+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
									// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
						+			"return __checkForLegacyModules;"
	
						+ "}catch(e){}"
						// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
						// either way, re-eval *after* surrounding with parentheses
	
						+ "try{"
						+		"return eval('('+__bundle+')');"
						+ "}catch(e){"
						+		"return e;"
						+ "}"
					),
	
				syncRequire = function(deps, callback, require){
					var results = [];
					array.forEach(deps, function(mid){
						var url = require.toUrl(mid + ".js");
	
						function load(text){
							var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
							if(result===amdValue){
								// the bundle was an AMD module; re-inject it through the normal AMD path
								// we gotta do this since it could be an anonymous module and simply evaluating
								// the text here won't provide the loader with the context to know what
								// module is being defined()'d. With browser caching, this should be free; further
								// this entire code path can be circumvented by using the AMD format to begin with
								results.push(cache[url] = amdValue.result);
							}else{
								if(result instanceof Error){
									console.error("failed to evaluate i18n bundle; url=" + url, result);
									result = {};
								}
								// nls/<locale>/<bundle-name> indicates not the root.
								results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
							}
						}
	
						if(cache[url]){
							results.push(cache[url]);
						}else{
							var bundle = require.syncLoadNls(mid);
							// need to check for legacy module here because there might be a legacy module for a
							// less specific locale (which was not looked up during the first checkForLegacyModules
							// call in load()).
							// Also need to reverse the locale and the module name in the mid because syncRequire
							// deps parameters uses the AMD style package/nls/locale/module while legacy code uses
							// package/nls/module/locale.
							if(!bundle){
								bundle = checkForLegacyModules(mid.replace(/nls\/([^\/]*)\/([^\/]*)$/, "nls/$2/$1"));
							}
							if(bundle){
								results.push(bundle);
							}else{
								if(!xhr){
									try{
										require.getText(url, true, load);
									}catch(e){
										results.push(cache[url] = {});
									}
								}else{
									xhr.get({
										url:url,
										sync:true,
										load:load,
										error:function(){
											results.push(cache[url] = {});
										}
									});
								}
							}
						}
					});
					callback && callback.apply(null, results);
				};
	
			checkForLegacyModules = function(target){
				// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
				for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
				if(object){
					result = object[names[i]];
					if(!result){
						// fallback for incorrect bundle build of 1.6
						result = object[names[i].replace(/-/g,"_")];
					}
					if(result){
						cache[target] = result;
					}
				}
				return result;
			};
	
			thisModule.getLocalization = function(moduleName, bundleName, locale){
				var result,
					l10nName = getBundleName(moduleName, bundleName, locale);
				load(
					l10nName,
	
					// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.
					// Since this legacy function does not have the concept of a reference module, resolve with respect to this
					// dojo/i18n module, which, itself may have been mapped.
					(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),
	
					function(result_){ result = result_; }
				);
				return result;
			};
		}
	
		return lang.mixin(thisModule, {
			dynamic:true,
			normalize:normalize,
			load:load,
			cache:cache,
			getL10nName: getL10nName
		});
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(2),
		__webpack_require__(25),
		__webpack_require__(6),
		__webpack_require__(48),
		
		__webpack_require__(13),
		__webpack_require__(124),
		__webpack_require__(125),
		__webpack_require__(7),
		__webpack_require__(123),
		__webpack_require__(8),
		__webpack_require__(28),
		__webpack_require__(18),
		__webpack_require__(19),
		__webpack_require__(43),
		__webpack_require__(40),
		__webpack_require__(44)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, has, require, ioq, /*===== declare, =====*/ dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util){
		// module:
		//		dojo/_base/xhr
	
		/*=====
		dojo._xhrObj = function(){
			// summary:
			//		does the work of portably generating a new XMLHTTPRequest object.
		};
		=====*/
		dojo._xhrObj = _xhr._create;
	
		var cfg = dojo.config;
	
		// mix in io-query and dom-form
		dojo.objectToQuery = ioq.objectToQuery;
		dojo.queryToObject = ioq.queryToObject;
		dojo.fieldToObject = domForm.fieldToObject;
		dojo.formToObject = domForm.toObject;
		dojo.formToQuery = domForm.toQuery;
		dojo.formToJson = domForm.toJson;
	
		// need to block async callbacks from snatching this thread as the result
		// of an async callback might call another sync XHR, this hangs khtml forever
		// must checked by watchInFlight()
	
		dojo._blockAsync = false;
	
		// MOW: remove dojo._contentHandlers alias in 2.0
		var handlers = dojo._contentHandlers = dojo.contentHandlers = {
			// summary:
			//		A map of available XHR transport handle types. Name matches the
			//		`handleAs` attribute passed to XHR calls.
			// description:
			//		A map of available XHR transport handle types. Name matches the
			//		`handleAs` attribute passed to XHR calls. Each contentHandler is
			//		called, passing the xhr object for manipulation. The return value
			//		from the contentHandler will be passed to the `load` or `handle`
			//		functions defined in the original xhr call.
			// example:
			//		Creating a custom content-handler:
			//	|	xhr.contentHandlers.makeCaps = function(xhr){
			//	|		return xhr.responseText.toUpperCase();
			//	|	}
			//	|	// and later:
			//	|	dojo.xhrGet({
			//	|		url:"foo.txt",
			//	|		handleAs:"makeCaps",
			//	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
			//	|	});
	
			"text": function(xhr){
				// summary:
				//		A contentHandler which simply returns the plaintext response data
				return xhr.responseText;
			},
			"json": function(xhr){
				// summary:
				//		A contentHandler which returns a JavaScript object created from the response data
				return json.fromJson(xhr.responseText || null);
			},
			"json-comment-filtered": function(xhr){
				// summary:
				//		A contentHandler which expects comment-filtered JSON.
				// description:
				//		A contentHandler which expects comment-filtered JSON.
				//		the json-comment-filtered option was implemented to prevent
				//		"JavaScript Hijacking", but it is less secure than standard JSON. Use
				//		standard JSON instead. JSON prefixing can be used to subvert hijacking.
				//
				//		Will throw a notice suggesting to use application/json mimetype, as
				//		json-commenting can introduce security issues. To decrease the chances of hijacking,
				//		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
				//
				//		use djConfig.useCommentedJson = true to turn off the notice
				if(!config.useCommentedJson){
					console.warn("Consider using the standard mimetype:application/json."
						+ " json-commenting can introduce security issues. To"
						+ " decrease the chances of hijacking, use the standard the 'json' handler and"
						+ " prefix your json with: {}&&\n"
						+ "Use djConfig.useCommentedJson=true to turn off this message.");
				}
	
				var value = xhr.responseText;
				var cStartIdx = value.indexOf("\/*");
				var cEndIdx = value.lastIndexOf("*\/");
				if(cStartIdx == -1 || cEndIdx == -1){
					throw new Error("JSON was not comment filtered");
				}
				return json.fromJson(value.substring(cStartIdx+2, cEndIdx));
			},
			"javascript": function(xhr){
				// summary:
				//		A contentHandler which evaluates the response data, expecting it to be valid JavaScript
	
				// FIXME: try Moz and IE specific eval variants?
				return dojo.eval(xhr.responseText);
			},
			"xml": function(xhr){
				// summary:
				//		A contentHandler returning an XML Document parsed from the response data
				var result = xhr.responseXML;
	
				if(result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")){
					// http://bugs.dojotoolkit.org/ticket/15631
					// IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
					// returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
					// the fuller-featured implementation and avoid bugs caused by the inconsistency
					result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
				}
	
				if(has("ie")){
					if((!result || !result.documentElement)){
						//WARNING: this branch used by the xml handling in dojo.io.iframe,
						//so be sure to test dojo.io.iframe if making changes below.
						var ms = function(n){ return "MSXML" + n + ".DOMDocument"; };
						var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
						array.some(dp, function(p){
							try{
								var dom = new ActiveXObject(p);
								dom.async = false;
								dom.loadXML(xhr.responseText);
								result = dom;
							}catch(e){ return false; }
							return true;
						});
					}
				}
				return result; // DOMDocument
			},
			"json-comment-optional": function(xhr){
				// summary:
				//		A contentHandler which checks the presence of comment-filtered JSON and
				//		alternates between the `json` and `json-comment-filtered` contentHandlers.
				if(xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)){
					return handlers["json-comment-filtered"](xhr);
				}else{
					return handlers["json"](xhr);
				}
			}
		};
	
		/*=====
	
		// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
		// because they are used by dojo/io modules too
	
		dojo.__IoArgs = declare(null, {
			// url: String
			//		URL to server endpoint.
			// content: Object?
			//		Contains properties with string values. These
			//		properties will be serialized as name1=value2 and
			//		passed in the request.
			// timeout: Integer?
			//		Milliseconds to wait for the response. If this time
			//		passes, the then error callbacks are called.
			// form: DOMNode?
			//		DOM node for a form. Used to extract the form values
			//		and send to the server.
			// preventCache: Boolean?
			//		Default is false. If true, then a
			//		"dojo.preventCache" parameter is sent in the request
			//		with a value that changes with each request
			//		(timestamp). Useful only with GET-type requests.
			// handleAs: String?
			//		Acceptable values depend on the type of IO
			//		transport (see specific IO calls for more information).
			// rawBody: String?
			//		Sets the raw body for an HTTP request. If this is used, then the content
			//		property is ignored. This is mostly useful for HTTP methods that have
			//		a body to their requests, like PUT or POST. This property can be used instead
			//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
			// ioPublish: Boolean?
			//		Set this explicitly to false to prevent publishing of topics related to
			//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
			//		will be published via dojo/topic.publish() for different phases of an IO operation.
			//		See dojo/main.__IoPublish for a list of topics that are published.
	
			load: function(response, ioArgs){
				// summary:
				//		This function will be
				//		called on a successful HTTP response code.
		 		// ioArgs: dojo/main.__IoCallbackArgs
				//		Provides additional information about the request.
				// response: Object
				//		The response in the format as defined with handleAs.
			},
	
			error: function(response, ioArgs){
				// summary:
				//		This function will
				//		be called when the request fails due to a network or server error, the url
				//		is invalid, etc. It will also be called if the load or handle callback throws an
				//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
				//		to continue to run even when a logic error happens in the callback, while making
				//		it easier to troubleshoot while in debug mode.
				// ioArgs: dojo/main.__IoCallbackArgs
				//		Provides additional information about the request.
				// response: Object
				//		The response in the format as defined with handleAs.
			},
	
			handle: function(loadOrError, response, ioArgs){
				// summary:
		 		//		This function will
		 		//		be called at the end of every request, whether or not an error occurs.
				// loadOrError: String
				//		Provides a string that tells you whether this function
				//		was called because of success (load) or failure (error).
				// response: Object
				//		The response in the format as defined with handleAs.
				// ioArgs: dojo/main.__IoCallbackArgs
				//		Provides additional information about the request.
			}
		});
	
		dojo.__IoCallbackArgs = declare(null, {
			// args: Object
			//		the original object argument to the IO call.
			// xhr: XMLHttpRequest
			//		For XMLHttpRequest calls only, the
			//		XMLHttpRequest object that was used for the
			//		request.
			// url: String
			//		The final URL used for the call. Many times it
			//		will be different than the original args.url
			//		value.
			// query: String
			//		For non-GET requests, the
			//		name1=value1&name2=value2 parameters sent up in
			//		the request.
			// handleAs: String
			//		The final indicator on how the response will be
			//		handled.
			// id: String
			//		For dojo/io/script calls only, the internal
			//		script ID used for the request.
			// canDelete: Boolean
			//		For dojo/io/script calls only, indicates
			//		whether the script tag that represents the
			//		request can be deleted after callbacks have
			//		been called. Used internally to know when
			//		cleanup can happen on JSONP-type requests.
			// json: Object
			//		For dojo/io/script calls only: holds the JSON
			//		response for JSONP-type requests. Used
			//		internally to hold on to the JSON responses.
			//		You should not need to access it directly --
			//		the same object should be passed to the success
			//		callbacks directly.
		});
	
		dojo.__IoPublish = declare(null, {
			// summary:
			//		This is a list of IO topics that can be published
			//		if djConfig.ioPublish is set to true. IO topics can be
			//		published for any Input/Output, network operation. So,
			//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
			//		trigger these topics to be published.
			// start: String
			//		"/dojo/io/start" is sent when there are no outstanding IO
			//		requests, and a new IO request is started. No arguments
			//		are passed with this topic.
			// send: String
			//		"/dojo/io/send" is sent whenever a new IO request is started.
			//		It passes the dojo.Deferred for the request with the topic.
			// load: String
			//		"/dojo/io/load" is sent whenever an IO request has loaded
			//		successfully. It passes the response and the dojo.Deferred
			//		for the request with the topic.
			// error: String
			//		"/dojo/io/error" is sent whenever an IO request has errored.
			//		It passes the error and the dojo.Deferred
			//		for the request with the topic.
			// done: String
			//		"/dojo/io/done" is sent whenever an IO request has completed,
			//		either by loading or by erroring. It passes the error and
			//		the dojo.Deferred for the request with the topic.
			// stop: String
			//		"/dojo/io/stop" is sent when all outstanding IO requests have
			//		finished. No arguments are passed with this topic.
		});
		=====*/
	
	
		dojo._ioSetArgs = function(/*dojo/main.__IoArgs*/args,
				/*Function*/canceller,
				/*Function*/okHandler,
				/*Function*/errHandler){
			// summary:
			//		sets up the Deferred and ioArgs property on the Deferred so it
			//		can be used in an io call.
			// args:
			//		The args object passed into the public io call. Recognized properties on
			//		the args object are:
			// canceller:
			//		The canceller function used for the Deferred object. The function
			//		will receive one argument, the Deferred object that is related to the
			//		canceller.
			// okHandler:
			//		The first OK callback to be registered with Deferred. It has the opportunity
			//		to transform the OK response. It will receive one argument -- the Deferred
			//		object returned from this function.
			// errHandler:
			//		The first error callback to be registered with Deferred. It has the opportunity
			//		to do cleanup on an error. It will receive two arguments: error (the
			//		Error object) and dfd, the Deferred object returned from this function.
	
			var ioArgs = {args: args, url: args.url};
	
			//Get values from form if requested.
			var formObject = null;
			if(args.form){
				var form = dom.byId(args.form);
				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all. See #2844
				var actnNode = form.getAttributeNode("action");
				ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : (dojo.doc ? dojo.doc.URL : null));
				formObject = domForm.toObject(form);
			}
	
			// set up the query params
			var miArgs = [{}];
	
			if(formObject){
				// potentially over-ride url-provided params w/ form values
				miArgs.push(formObject);
			}
			if(args.content){
				// stuff in content over-rides what's set by form
				miArgs.push(args.content);
			}
			if(args.preventCache){
				miArgs.push({"dojo.preventCache": new Date().valueOf()});
			}
			ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));
	
			// .. and the real work of getting the deferred in order, etc.
			ioArgs.handleAs = args.handleAs || "text";
			var d = new Deferred(function(dfd){
				dfd.canceled = true;
				canceller && canceller(dfd);
	
				var err = dfd.ioArgs.error;
				if(!err){
					err = new Error("request cancelled");
					err.dojoType="cancel";
					dfd.ioArgs.error = err;
				}
				return err;
			});
			d.addCallback(okHandler);
	
			//Support specifying load, error and handle callback functions from the args.
			//For those callbacks, the "this" object will be the args object.
			//The callbacks will get the deferred result value as the
			//first argument and the ioArgs object as the second argument.
			var ld = args.load;
			if(ld && lang.isFunction(ld)){
				d.addCallback(function(value){
					return ld.call(args, value, ioArgs);
				});
			}
			var err = args.error;
			if(err && lang.isFunction(err)){
				d.addErrback(function(value){
					return err.call(args, value, ioArgs);
				});
			}
			var handle = args.handle;
			if(handle && lang.isFunction(handle)){
				d.addBoth(function(value){
					return handle.call(args, value, ioArgs);
				});
			}
	
			// Attach error handler last (not including topic publishing)
			// to catch any errors that may have been generated from load
			// or handle functions.
			d.addErrback(function(error){
				return errHandler(error, d);
			});
	
			//Plug in topic publishing, if dojo.publish is loaded.
			if(cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false){
				d.addCallbacks(
					function(res){
						dojo.publish("/dojo/io/load", [d, res]);
						return res;
					},
					function(res){
						dojo.publish("/dojo/io/error", [d, res]);
						return res;
					}
				);
				d.addBoth(function(res){
					dojo.publish("/dojo/io/done", [d, res]);
					return res;
				});
			}
	
			d.ioArgs = ioArgs;
	
			// FIXME: need to wire up the xhr object's abort method to something
			// analogous in the Deferred
			return d;
		};
	
		var _deferredOk = function(/*Deferred*/dfd){
			// summary:
			//		okHandler function for dojo._ioSetArgs call.
	
			var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
			return ret === undefined ? null : ret;
		};
		var _deferError = function(/*Error*/error, /*Deferred*/dfd){
			// summary:
			//		errHandler function for dojo._ioSetArgs call.
	
			if(!dfd.ioArgs.args.failOk){
				console.error(error);
			}
			return error;
		};
	
		//Use a separate count for knowing if we are starting/stopping io calls.
		var _checkPubCount = function(dfd){
			if(_pubCount <= 0){
				_pubCount = 0;
				if(cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)){
					dojo.publish("/dojo/io/stop");
				}
			}
		};
	
		var _pubCount = 0;
		aspect.after(watch, "_onAction", function(){
			_pubCount -= 1;
		});
		aspect.after(watch, "_onInFlight", _checkPubCount);
	
		dojo._ioCancelAll = watch.cancelAll;
		/*=====
		dojo._ioCancelAll = function(){
			// summary:
			//		Cancels all pending IO requests, regardless of IO type
			//		(xhr, script, iframe).
		};
		=====*/
	
		dojo._ioNotifyStart = function(/*Deferred*/dfd){
			// summary:
			//		If dojo.publish is available, publish topics
			//		about the start of a request queue and/or the
			//		the beginning of request.
			//
			//		Used by IO transports. An IO transport should
			//		call this method before making the network connection.
			if(cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false){
				if(!_pubCount){
					dojo.publish("/dojo/io/start");
				}
				_pubCount += 1;
				dojo.publish("/dojo/io/send", [dfd]);
			}
		};
	
		dojo._ioWatch = function(dfd, validCheck, ioCheck, resHandle){
			// summary:
			//		Watches the io request represented by dfd to see if it completes.
			// dfd: Deferred
			//		The Deferred object to watch.
			// validCheck: Function
			//		Function used to check if the IO request is still valid. Gets the dfd
			//		object as its only argument.
			// ioCheck: Function
			//		Function used to check if basic IO call worked. Gets the dfd
			//		object as its only argument.
			// resHandle: Function
			//		Function used to process response. Gets the dfd
			//		object as its only argument.
	
			var args = dfd.ioArgs.options = dfd.ioArgs.args;
			lang.mixin(dfd, {
				response: dfd.ioArgs,
				isValid: function(response){
					return validCheck(dfd);
				},
				isReady: function(response){
					return ioCheck(dfd);
				},
				handleResponse: function(response){
					return resHandle(dfd);
				}
			});
			watch(dfd);
	
			_checkPubCount(dfd);
		};
	
		var _defaultContentType = "application/x-www-form-urlencoded";
	
		dojo._ioAddQueryToUrl = function(/*dojo.__IoCallbackArgs*/ioArgs){
			// summary:
			//		Adds query params discovered by the io deferred construction to the URL.
			//		Only use this for operations which are fundamentally GET-type operations.
			if(ioArgs.query.length){
				ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
				ioArgs.query = null;
			}
		};
	
		/*=====
		dojo.__XhrArgs = declare(dojo.__IoArgs, {
			// summary:
			//		In addition to the properties listed for the dojo._IoArgs type,
			//		the following properties are allowed for dojo.xhr* methods.
			// handleAs: String?
			//		Acceptable values are: text (default), json, json-comment-optional,
			//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
		 	// sync: Boolean?
			//		false is default. Indicates whether the request should
			//		be a synchronous (blocking) request.
			// headers: Object?
			//		Additional HTTP headers to send in the request.
			// failOk: Boolean?
			//		false is default. Indicates whether a request should be
			//		allowed to fail (and therefore no console error message in
			//		the event of a failure)
			// contentType: String|Boolean
			//		"application/x-www-form-urlencoded" is default. Set to false to
			//		prevent a Content-Type header from being sent, or to a string
			//		to send a different Content-Type.
		 });
		=====*/
	
		dojo.xhr = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){
			// summary:
			//		Deprecated.   Use dojo/request instead.
			// description:
			//		Sends an HTTP request with the given method.
			//		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
			//		for those HTTP methods. There are also methods for "raw" PUT and POST methods
			//		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
			// method:
			//		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
			// hasBody:
			//		If the request has an HTTP body, then pass true for hasBody.
	
			var rDfd;
			//Make the Deferred object for this xhr request.
			var dfd = dojo._ioSetArgs(args, function(dfd){
				rDfd && rDfd.cancel();
			}, _deferredOk, _deferError);
			var ioArgs = dfd.ioArgs;
	
			//Allow for specifying the HTTP body completely.
			if("postData" in args){
				ioArgs.query = args.postData;
			}else if("putData" in args){
				ioArgs.query = args.putData;
			}else if("rawBody" in args){
				ioArgs.query = args.rawBody;
			}else if((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1){
				//Check for hasBody being passed. If no hasBody,
				//then only append query string if not a POST or PUT request.
				dojo._ioAddQueryToUrl(ioArgs);
			}
	
			var options = {
				method: method,
				handleAs: "text",
				timeout: args.timeout,
				withCredentials: args.withCredentials,
				ioArgs: ioArgs
			};
	
			if(typeof args.headers !== 'undefined'){
				options.headers = args.headers;
			}
			if(typeof args.contentType !== 'undefined'){
				if(!options.headers){
					options.headers = {};
				}
				options.headers['Content-Type'] = args.contentType;
			}
			if(typeof ioArgs.query !== 'undefined'){
				options.data = ioArgs.query;
			}
			if(typeof args.sync !== 'undefined'){
				options.sync = args.sync;
			}
	
			dojo._ioNotifyStart(dfd);
			try{
				rDfd = _xhr(ioArgs.url, options, true);
			}catch(e){
				// If XHR creation fails, dojo/request/xhr throws
				// When this happens, cancel the deferred
				dfd.cancel();
				return dfd;
			}
	
			// sync ioArgs
			dfd.ioArgs.xhr = rDfd.response.xhr;
	
			rDfd.then(function(){
				dfd.resolve(dfd);
			}).otherwise(function(error){
				ioArgs.error = error;
				if(error.response){
					error.status = error.response.status;
					error.responseText = error.response.text;
					error.xhr = error.response.xhr;
				}
				dfd.reject(error);
			});
			return dfd; // dojo/_base/Deferred
		};
	
		dojo.xhrGet = function(/*dojo.__XhrArgs*/ args){
			// summary:
			//		Sends an HTTP GET request to the server.
			return dojo.xhr("GET", args); // dojo/_base/Deferred
		};
	
		dojo.rawXhrPost = dojo.xhrPost = function(/*dojo.__XhrArgs*/ args){
			// summary:
			//		Sends an HTTP POST request to the server. In addition to the properties
			//		listed for the dojo.__XhrArgs type, the following property is allowed:
			// postData:
			//		String. Send raw data in the body of the POST request.
			return dojo.xhr("POST", args, true); // dojo/_base/Deferred
		};
	
		dojo.rawXhrPut = dojo.xhrPut = function(/*dojo.__XhrArgs*/ args){
			// summary:
			//		Sends an HTTP PUT request to the server. In addition to the properties
			//		listed for the dojo.__XhrArgs type, the following property is allowed:
			// putData:
			//		String. Send raw data in the body of the PUT request.
			return dojo.xhr("PUT", args, true); // dojo/_base/Deferred
		};
	
		dojo.xhrDelete = function(/*dojo.__XhrArgs*/ args){
			// summary:
			//		Sends an HTTP DELETE request to the server.
			return dojo.xhr("DELETE", args); // dojo/_base/Deferred
		};
	
		/*
		dojo.wrapForm = function(formNode){
			// summary:
			//		A replacement for FormBind, but not implemented yet.
	
			// FIXME: need to think harder about what extensions to this we might
			// want. What should we allow folks to do w/ this? What events to
			// set/send?
			throw new Error("dojo.wrapForm not yet implemented");
		}
		*/
	
		dojo._isDocumentOk = function(x){
			return util.checkStatus(x.status);
		};
	
		dojo._getText = function(url){
			var result;
			dojo.xhrGet({url:url, sync:true, load:function(text){
				result = text;
			}});
			return result;
		};
	
		// Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
		lang.mixin(dojo.xhr, {
			_xhrObj: dojo._xhrObj,
			fieldToObject: domForm.fieldToObject,
			formToObject: domForm.toObject,
			objectToQuery: ioq.objectToQuery,
			formToQuery: domForm.toQuery,
			formToJson: domForm.toJson,
			queryToObject: ioq.queryToObject,
			contentHandlers: handlers,
			_ioSetArgs: dojo._ioSetArgs,
			_ioCancelAll: dojo._ioCancelAll,
			_ioNotifyStart: dojo._ioNotifyStart,
			_ioWatch: dojo._ioWatch,
			_ioAddQueryToUrl: dojo._ioAddQueryToUrl,
			_isDocumentOk: dojo._isDocumentOk,
			_getText: dojo._getText,
			get: dojo.xhrGet,
			post: dojo.xhrPost,
			put: dojo.xhrPut,
			del: dojo.xhrDelete	// because "delete" is a reserved word
		});
	
		return dojo.xhr;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, json){
	
	// module:
	//		dojo/_base/json
	
	/*=====
	return {
		// summary:
		//		This module defines the dojo JSON API.
	};
	=====*/
	
	dojo.fromJson = function(/*String*/ js){
		// summary:
		//		Parses a JavaScript expression and returns a JavaScript value.
		// description:
		//		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
		//		always delegates to eval(). The content passed to this method must therefore come
		//		from a trusted source.
		//		It is recommend that you use dojo/json's parse function for an
		//		implementation uses the (faster) native JSON parse when available.
		// js:
		//		a string literal of a JavaScript expression, for instance:
		//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
	
		return eval("(" + js + ")"); // Object
	};
	
	/*=====
	dojo._escapeString = function(){
		// summary:
		//		Adds escape sequences for non-visual characters, double quote and
		//		backslash and surrounds with double quotes to form a valid string
		//		literal.
	};
	=====*/
	dojo._escapeString = json.stringify; // just delegate to json.stringify
	
	dojo.toJsonIndentStr = "\t";
	dojo.toJson = function(/*Object*/ it, /*Boolean?*/ prettyPrint){
		// summary:
		//		Returns a [JSON](http://json.org) serialization of an object.
		// description:
		//		Returns a [JSON](http://json.org) serialization of an object.
		//		Note that this doesn't check for infinite recursion, so don't do that!
		//		It is recommend that you use dojo/json's stringify function for an lighter
		//		and faster implementation that matches the native JSON API and uses the
		//		native JSON serializer when available.
		// it:
		//		an object to be serialized. Objects may define their own
		//		serialization via a special "__json__" or "json" function
		//		property. If a specialized serializer has been defined, it will
		//		be used as a fallback.
		//		Note that in 1.6, toJson would serialize undefined, but this no longer supported
		//		since it is not supported by native JSON serializer.
		// prettyPrint:
		//		if true, we indent objects and arrays to make the output prettier.
		//		The variable `dojo.toJsonIndentStr` is used as the indent string --
		//		to use something other than the default (tab), change that variable
		//		before calling dojo.toJson().
		//		Note that if native JSON support is available, it will be used for serialization,
		//		and native implementations vary on the exact spacing used in pretty printing.
		// returns:
		//		A JSON string serialization of the passed-in object.
		// example:
		//		simple serialization of a trivial object
		//		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
		//		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
		// example:
		//		a custom serializer for an objects of a particular class:
		//		|	dojo.declare("Furby", null, {
		//		|		furbies: "are strange",
		//		|		furbyCount: 10,
		//		|		__json__: function(){
		//		|		},
		//		|	});
	
		// use dojo/json
		return json.stringify(it, function(key, value){
			if(value){
				var tf = value.__json__||value.json;
				if(typeof tf == "function"){
					return tf.call(value);
				}
			}
			return value;
		}, prettyPrint && dojo.toJsonIndentStr);	// String
	};
	
	return dojo;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(13), __webpack_require__(48), __webpack_require__(51)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, dom, ioq, json){
		// module:
		//		dojo/dom-form
	
	    function setValue(/*Object*/ obj, /*String*/ name, /*String*/ value){
	        // summary:
	        //		For the named property in object, set the value. If a value
	        //		already exists and it is a string, convert the value to be an
	        //		array of values.
	
	        // Skip it if there is no value
	        if(value === null){
	            return;
	        }
	
	        var val = obj[name];
	        if(typeof val == "string"){ // inline'd type check
	            obj[name] = [val, value];
	        }else if(lang.isArray(val)){
	            val.push(value);
	        }else{
	            obj[name] = value;
	        }
	    }
	
		var exclude = "file|submit|image|reset|button";
	
		var form = {
			// summary:
			//		This module defines form-processing functions.
	
			fieldToObject: function fieldToObject(/*DOMNode|String*/ inputNode){
				// summary:
				//		Serialize a form field to a JavaScript object.
				// description:
				//		Returns the value encoded in a form field as
				//		as a string or an array of strings. Disabled form elements
				//		and unchecked radio and checkboxes are skipped.	Multi-select
				//		elements are returned as an array of string values.
				// inputNode: DOMNode|String
				// returns: Object
	
				var ret = null;
				inputNode = dom.byId(inputNode);
				if(inputNode){
					var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
					if(_in && type && !inputNode.disabled){
						if(type == "radio" || type == "checkbox"){
							if(inputNode.checked){
								ret = inputNode.value;
							}
						}else if(inputNode.multiple){
							ret = [];
							var nodes = [inputNode.firstChild];
							while(nodes.length){
								for(var node = nodes.pop(); node; node = node.nextSibling){
									if(node.nodeType == 1 && node.tagName.toLowerCase() == "option"){
										if(node.selected){
											ret.push(node.value);
										}
									}else{
										if(node.nextSibling){
											nodes.push(node.nextSibling);
										}
										if(node.firstChild){
											nodes.push(node.firstChild);
										}
										break;
									}
								}
							}
						}else{
							ret = inputNode.value;
						}
					}
				}
				return ret; // Object
			},
	
			toObject: function formToObject(/*DOMNode|String*/ formNode){
				// summary:
				//		Serialize a form node to a JavaScript object.
				// description:
				//		Returns the values encoded in an HTML form as
				//		string properties in an object which it then returns. Disabled form
				//		elements, buttons, and other non-value form elements are skipped.
				//		Multi-select elements are returned as an array of string values.
				// formNode: DOMNode|String
				// example:
				//		This form:
				//		|	<form id="test_form">
				//		|		<input type="text" name="blah" value="blah">
				//		|		<input type="text" name="no_value" value="blah" disabled>
				//		|		<input type="button" name="no_value2" value="blah">
				//		|		<select type="select" multiple name="multi" size="5">
				//		|			<option value="blah">blah</option>
				//		|			<option value="thud" selected>thud</option>
				//		|			<option value="thonk" selected>thonk</option>
				//		|		</select>
				//		|	</form>
				//
				//		yields this object structure as the result of a call to
				//		formToObject():
				//
				//		|	{
				//		|		blah: "blah",
				//		|		multi: [
				//		|			"thud",
				//		|			"thonk"
				//		|		]
				//		|	};
	
				var ret = {}, elems = dom.byId(formNode).elements;
				for(var i = 0, l = elems.length; i < l; ++i){
					var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
					if(_in && type && exclude.indexOf(type) < 0 && !item.disabled){
						setValue(ret, _in, form.fieldToObject(item));
						if(type == "image"){
							ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
						}
					}
				}
				return ret; // Object
			},
	
			toQuery: function formToQuery(/*DOMNode|String*/ formNode){
				// summary:
				//		Returns a URL-encoded string representing the form passed as either a
				//		node or string ID identifying the form to serialize
				// formNode: DOMNode|String
				// returns: String
	
				return ioq.objectToQuery(form.toObject(formNode)); // String
			},
	
			toJson: function formToJson(/*DOMNode|String*/ formNode, /*Boolean?*/ prettyPrint){
				// summary:
				//		Create a serialized JSON string from a form node or string
				//		ID identifying the form to serialize
				// formNode: DOMNode|String
				// prettyPrint: Boolean?
				// returns: String
	
				return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0); // String
			}
		};
	
	    return form;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(2),
		__webpack_require__(46),
		__webpack_require__(47),
		__webpack_require__(45),
		__webpack_require__(4),
		__webpack_require__(8),
		__webpack_require__(53)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, NewDeferred, Promise, CancelError, has, lang, when){
		// module:
		//		dojo/_base/Deferred
	
		var mutator = function(){};
		var freeze = Object.freeze || function(){};
		// A deferred provides an API for creating and resolving a promise.
		var Deferred = dojo.Deferred = function(/*Function?*/ canceller){
			// summary:
			//		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
			//		New code should use dojo/Deferred instead.
			// description:
			//		The Deferred API is based on the concept of promises that provide a
			//		generic interface into the eventual completion of an asynchronous action.
			//		The motivation for promises fundamentally is about creating a
			//		separation of concerns that allows one to achieve the same type of
			//		call patterns and logical data flow in asynchronous code as can be
			//		achieved in synchronous code. Promises allows one
			//		to be able to call a function purely with arguments needed for
			//		execution, without conflating the call with concerns of whether it is
			//		sync or async. One shouldn't need to alter a call's arguments if the
			//		implementation switches from sync to async (or vice versa). By having
			//		async functions return promises, the concerns of making the call are
			//		separated from the concerns of asynchronous interaction (which are
			//		handled by the promise).
			//
			//		The Deferred is a type of promise that provides methods for fulfilling the
			//		promise with a successful result or an error. The most important method for
			//		working with Dojo's promises is the then() method, which follows the
			//		CommonJS proposed promise API. An example of using a Dojo promise:
			//
			//		|	var resultingPromise = someAsyncOperation.then(function(result){
			//		|		... handle result ...
			//		|	},
			//		|	function(error){
			//		|		... handle error ...
			//		|	});
			//
			//		The .then() call returns a new promise that represents the result of the
			//		execution of the callback. The callbacks will never affect the original promises value.
			//
			//		The Deferred instances also provide the following functions for backwards compatibility:
			//
			//		- addCallback(handler)
			//		- addErrback(handler)
			//		- callback(result)
			//		- errback(result)
			//
			//		Callbacks are allowed to return promises themselves, so
			//		you can build complicated sequences of events with ease.
			//
			//		The creator of the Deferred may specify a canceller.  The canceller
			//		is a function that will be called if Deferred.cancel is called
			//		before the Deferred fires. You can use this to implement clean
			//		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
			//		deferred with a CancelledError (unless your canceller returns
			//		another kind of error), so the errbacks should be prepared to
			//		handle that error for cancellable Deferreds.
			// example:
			//	|	var deferred = new Deferred();
			//	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
			//	|	return deferred;
			// example:
			//		Deferred objects are often used when making code asynchronous. It
			//		may be easiest to write functions in a synchronous manner and then
			//		split code using a deferred to trigger a response to a long-lived
			//		operation. For example, instead of register a callback function to
			//		denote when a rendering operation completes, the function can
			//		simply return a deferred:
			//
			//		|	// callback style:
			//		|	function renderLotsOfData(data, callback){
			//		|		var success = false
			//		|		try{
			//		|			for(var x in data){
			//		|				renderDataitem(data[x]);
			//		|			}
			//		|			success = true;
			//		|		}catch(e){ }
			//		|		if(callback){
			//		|			callback(success);
			//		|		}
			//		|	}
			//
			//		|	// using callback style
			//		|	renderLotsOfData(someDataObj, function(success){
			//		|		// handles success or failure
			//		|		if(!success){
			//		|			promptUserToRecover();
			//		|		}
			//		|	});
			//		|	// NOTE: no way to add another callback here!!
			// example:
			//		Using a Deferred doesn't simplify the sending code any, but it
			//		provides a standard interface for callers and senders alike,
			//		providing both with a simple way to service multiple callbacks for
			//		an operation and freeing both sides from worrying about details
			//		such as "did this get called already?". With Deferreds, new
			//		callbacks can be added at any time.
			//
			//		|	// Deferred style:
			//		|	function renderLotsOfData(data){
			//		|		var d = new Deferred();
			//		|		try{
			//		|			for(var x in data){
			//		|				renderDataitem(data[x]);
			//		|			}
			//		|			d.callback(true);
			//		|		}catch(e){
			//		|			d.errback(new Error("rendering failed"));
			//		|		}
			//		|		return d;
			//		|	}
			//
			//		|	// using Deferred style
			//		|	renderLotsOfData(someDataObj).then(null, function(){
			//		|		promptUserToRecover();
			//		|	});
			//		|	// NOTE: addErrback and addCallback both return the Deferred
			//		|	// again, so we could chain adding callbacks or save the
			//		|	// deferred for later should we need to be notified again.
			// example:
			//		In this example, renderLotsOfData is synchronous and so both
			//		versions are pretty artificial. Putting the data display on a
			//		timeout helps show why Deferreds rock:
			//
			//		|	// Deferred style and async func
			//		|	function renderLotsOfData(data){
			//		|		var d = new Deferred();
			//		|		setTimeout(function(){
			//		|			try{
			//		|				for(var x in data){
			//		|					renderDataitem(data[x]);
			//		|				}
			//		|				d.callback(true);
			//		|			}catch(e){
			//		|				d.errback(new Error("rendering failed"));
			//		|			}
			//		|		}, 100);
			//		|		return d;
			//		|	}
			//
			//		|	// using Deferred style
			//		|	renderLotsOfData(someDataObj).then(null, function(){
			//		|		promptUserToRecover();
			//		|	});
			//
			//		Note that the caller doesn't have to change his code at all to
			//		handle the asynchronous case.
	
			var result, finished, canceled, fired, isError, head, nextListener;
			var promise = (this.promise = new Promise());
	
			function complete(value){
				if(finished){
					throw new Error("This deferred has already been resolved");
				}
				result = value;
				finished = true;
				notify();
			}
			function notify(){
				var mutated;
				while(!mutated && nextListener){
					var listener = nextListener;
					nextListener = nextListener.next;
					if((mutated = (listener.progress == mutator))){ // assignment and check
						finished = false;
					}
	
					var func = (isError ? listener.error : listener.resolved);
					if(has("config-useDeferredInstrumentation")){
						if(isError && NewDeferred.instrumentRejected){
							NewDeferred.instrumentRejected(result, !!func);
						}
					}
					if(func){
						try{
							var newResult = func(result);
							if (newResult && typeof newResult.then === "function"){
								newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
								continue;
							}
							var unchanged = mutated && newResult === undefined;
							if(mutated && !unchanged){
								isError = newResult instanceof Error;
							}
							listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
						}catch(e){
							listener.deferred.reject(e);
						}
					}else{
						if(isError){
							listener.deferred.reject(result);
						}else{
							listener.deferred.resolve(result);
						}
					}
				}
			}
	
			this.isResolved = promise.isResolved = function(){
				// summary:
				//		Checks whether the deferred has been resolved.
				// returns: Boolean
	
				return fired == 0;
			};
	
			this.isRejected = promise.isRejected = function(){
				// summary:
				//		Checks whether the deferred has been rejected.
				// returns: Boolean
	
				return fired == 1;
			};
	
			this.isFulfilled = promise.isFulfilled = function(){
				// summary:
				//		Checks whether the deferred has been resolved or rejected.
				// returns: Boolean
	
				return fired >= 0;
			};
	
			this.isCanceled = promise.isCanceled = function(){
				// summary:
				//		Checks whether the deferred has been canceled.
				// returns: Boolean
	
				return canceled;
			};
	
			// calling resolve will resolve the promise
			this.resolve = this.callback = function(value){
				// summary:
				//		Fulfills the Deferred instance successfully with the provide value
				this.fired = fired = 0;
				this.results = [value, null];
				complete(value);
			};
	
	
			// calling error will indicate that the promise failed
			this.reject = this.errback = function(error){
				// summary:
				//		Fulfills the Deferred instance as an error with the provided error
				isError = true;
				this.fired = fired = 1;
				if(has("config-useDeferredInstrumentation")){
					if(NewDeferred.instrumentRejected){
						NewDeferred.instrumentRejected(error, !!nextListener);
					}
				}
				complete(error);
				this.results = [null, error];
			};
			// call progress to provide updates on the progress on the completion of the promise
			this.progress = function(update){
				// summary:
				//		Send progress events to all listeners
				var listener = nextListener;
				while(listener){
					var progress = listener.progress;
					progress && progress(update);
					listener = listener.next;
				}
			};
			this.addCallbacks = function(callback, errback){
				// summary:
				//		Adds callback and error callback for this deferred instance.
				// callback: Function?
				//		The callback attached to this deferred object.
				// errback: Function?
				//		The error callback attached to this deferred object.
				// returns:
				//		Returns this deferred object.
				this.then(callback, errback, mutator);
				return this;	// Deferred
			};
			// provide the implementation of the promise
			promise.then = this.then = function(/*Function?*/resolvedCallback, /*Function?*/errorCallback, /*Function?*/progressCallback){
				// summary:
				//		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
				//		completion of a promise. The fulfilledHandler is called when the promise
				//		is fulfilled. The errorHandler is called when a promise fails. The
				//		progressHandler is called for progress events. All arguments are optional
				//		and non-function values are ignored. The progressHandler is not only an
				//		optional argument, but progress events are purely optional. Promise
				//		providers are not required to ever create progress events.
				//
				//		This function will return a new promise that is fulfilled when the given
				//		fulfilledHandler or errorHandler callback is finished. This allows promise
				//		operations to be chained together. The value returned from the callback
				//		handler is the fulfillment value for the returned promise. If the callback
				//		throws an error, the returned promise will be moved to failed state.
				//
				// returns:
				//		Returns a new promise that represents the result of the
				//		execution of the callback. The callbacks will never affect the original promises value.
				// example:
				//		An example of using a CommonJS compliant promise:
				//		|	asyncComputeTheAnswerToEverything().
				//		|		then(addTwo).
				//		|		then(printResult, onError);
				//		|	>44
				//
				var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
				var listener = {
					resolved: resolvedCallback,
					error: errorCallback,
					progress: progressCallback,
					deferred: returnDeferred
				};
				if(nextListener){
					head = head.next = listener;
				}
				else{
					nextListener = head = listener;
				}
				if(finished){
					notify();
				}
				return returnDeferred.promise; // Promise
			};
			var deferred = this;
			promise.cancel = this.cancel = function(){
				// summary:
				//		Cancels the asynchronous operation
				if(!finished){
					var error = canceller && canceller(deferred);
					if(!finished){
						if (!(error instanceof Error)){
							error = new CancelError(error);
						}
						error.log = false;
						deferred.reject(error);
					}
				}
				canceled = true;
			};
			freeze(promise);
		};
		lang.extend(Deferred, {
			addCallback: function(/*Function*/ callback){
				// summary:
				//		Adds successful callback for this deferred instance.
				// returns:
				//		Returns this deferred object.
				return this.addCallbacks(lang.hitch.apply(dojo, arguments));	// Deferred
			},
	
			addErrback: function(/*Function*/ errback){
				// summary:
				//		Adds error callback for this deferred instance.
				// returns:
				//		Returns this deferred object.
				return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));	// Deferred
			},
	
			addBoth: function(/*Function*/ callback){
				// summary:
				//		Add handler as both successful callback and error callback for this deferred instance.
				// returns:
				//		Returns this deferred object.
				var enclosed = lang.hitch.apply(dojo, arguments);
				return this.addCallbacks(enclosed, enclosed);	// Deferred
			},
			fired: -1
		});
	
		Deferred.when = dojo.when = when;
	
		return Deferred;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 126 */,
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(19),
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(14), 
		__webpack_require__(11), 
		__webpack_require__(23), 
		__webpack_require__(15), 
		__webpack_require__(4), 
		__webpack_require__(26),
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(128),
		__webpack_require__(129),
		__webpack_require__(105),
		__webpack_require__(75),__webpack_require__(6),    
		__webpack_require__(81)		
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, aspect, declare, dom, domAttr, domConstruct, domGeometry, domStyle, has, keys, lang, on,
				place, BackgroundIframe, Viewport, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/popup", (function(){
	
		// module:
		//		dijit/popup
	
		/*=====
		 var __OpenArgs = {
			 // popup: Widget
			 //		widget to display
			 // parent: Widget
			 //		the button etc. that is displaying this popup
			 // around: DomNode
			 //		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
			 // x: Integer
			 //		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
			 // y: Integer
			 //		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
			 // orient: Object|String
			 //		When the around parameter is specified, orient should be a list of positions to try, ex:
			 //	|	[ "below", "above" ]
			 //		For backwards compatibility it can also be an (ordered) hash of tuples of the form
			 //		(around-node-corner, popup-node-corner), ex:
			 //	|	{ "BL": "TL", "TL": "BL" }
			 //		where BL means "bottom left" and "TL" means "top left", etc.
			 //
			 //		dijit/popup.open() tries to position the popup according to each specified position, in order,
			 //		until the popup appears fully within the viewport.
			 //
			 //		The default value is ["below", "above"]
			 //
			 //		When an (x,y) position is specified rather than an around node, orient is either
			 //		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
			 //		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
			 //		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
			 //		and the top-right corner.
			 // onCancel: Function
			 //		callback when user has canceled the popup by:
			 //
			 //		1. hitting ESC or
			 //		2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
			 //		   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
			 // onClose: Function
			 //		callback whenever this popup is closed
			 // onExecute: Function
			 //		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
			 // padding: place.__Position
			 //		adding a buffer around the opening position. This is only useful when around is not set.
			 // maxHeight: Integer
			 //		The max height for the popup.  Any popup taller than this will have scrollbars.
			 //		Set to Infinity for no max height.  Default is to limit height to available space in viewport,
			 //		above or below the aroundNode or specified x/y position.
		 };
		 =====*/
	
		function destroyWrapper(){
			// summary:
			//		Function to destroy wrapper when popup widget is destroyed.
			//		Left in this scope to avoid memory leak on IE8 on refresh page, see #15206.
			if(this._popupWrapper){
				domConstruct.destroy(this._popupWrapper);
				delete this._popupWrapper;
			}
		}
	
		var PopupManager = declare(null, {
			// summary:
			//		Used to show drop downs (ex: the select list of a ComboBox)
			//		or popups (ex: right-click context menus).
	
			// _stack: dijit/_WidgetBase[]
			//		Stack of currently popped up widgets.
			//		(someone opened _stack[0], and then it opened _stack[1], etc.)
			_stack: [],
	
			// _beginZIndex: Number
			//		Z-index of the first popup.   (If first popup opens other
			//		popups they get a higher z-index.)
			_beginZIndex: 1000,
	
			_idGen: 1,
	
			_repositionAll: function(){
				// summary:
				//		If screen has been scrolled, reposition all the popups in the stack.
				//		Then set timer to check again later.
	
				if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
					var oldPos = this._firstAroundPosition,
						newPos = domGeometry.position(this._firstAroundNode, true),
						dx = newPos.x - oldPos.x,
						dy = newPos.y - oldPos.y;
	
					if(dx || dy){
						this._firstAroundPosition = newPos;
						for(var i = 0; i < this._stack.length; i++){
							var style = this._stack[i].wrapper.style;
							style.top = (parseFloat(style.top) + dy) + "px";
							if(style.right == "auto"){
								style.left = (parseFloat(style.left) + dx) + "px";
							}else{
								style.right = (parseFloat(style.right) - dx) + "px";
							}
						}
					}
	
					this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
				}
			},
	
			_createWrapper: function(/*Widget*/ widget){
				// summary:
				//		Initialization for widgets that will be used as popups.
				//		Puts widget inside a wrapper DIV (if not already in one),
				//		and returns pointer to that wrapper DIV.
	
				var wrapper = widget._popupWrapper,
					node = widget.domNode;
	
				if(!wrapper){
					// Create wrapper <div> for when this widget [in the future] will be used as a popup.
					// This is done early because of IE bugs where creating/moving DOM nodes causes focus
					// to go wonky, see tests/robot/Toolbar.html to reproduce
					wrapper = domConstruct.create("div", {
						"class": "dijitPopup",
						style: { display: "none"},
						role: "region",
						"aria-label": widget["aria-label"] || widget.label || widget.name || widget.id
					}, widget.ownerDocumentBody);
					wrapper.appendChild(node);
	
					var s = node.style;
					s.display = "";
					s.visibility = "";
					s.position = "";
					s.top = "0px";
	
					widget._popupWrapper = wrapper;
					aspect.after(widget, "destroy", destroyWrapper, true);
	
					// Workaround iOS problem where clicking a Menu can focus an <input> (or click a button) behind it.
					// Need to be careful though that you can still focus <input>'s and click <button>'s in a TooltipDialog.
					// Also, be careful not to break (native) scrolling of dropdown like ComboBox's options list.
					if("ontouchend" in document) {
						on(wrapper, "touchend", function (evt){
							if(!/^(input|button|textarea)$/i.test(evt.target.tagName)) {
								evt.preventDefault();
							}
						});
					}
	
					// Calling evt.preventDefault() suppresses the native click event on most browsers.  However, it doesn't
					// suppress the synthetic click event emitted by dojo/touch.  In order for clicks in popups to work
					// consistently, always use dojo/touch in popups.  See #18150.
					wrapper.dojoClick = true;
				}
	
				return wrapper;
			},
	
			moveOffScreen: function(/*Widget*/ widget){
				// summary:
				//		Moves the popup widget off-screen.
				//		Do not use this method to hide popups when not in use, because
				//		that will create an accessibility issue: the offscreen popup is
				//		still in the tabbing order.
	
				// Create wrapper if not already there
				var wrapper = this._createWrapper(widget);
	
				// Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
				var ltr = domGeometry.isBodyLtr(widget.ownerDocument),
					style = {
						visibility: "hidden",
						top: "-9999px",
						display: ""
					};
				style[ltr ? "left" : "right"] = "-9999px";
				style[ltr ? "right" : "left"] = "auto";
				domStyle.set(wrapper, style);
	
				return wrapper;
			},
	
			hide: function(/*Widget*/ widget){
				// summary:
				//		Hide this popup widget (until it is ready to be shown).
				//		Initialization for widgets that will be used as popups
				//
				//		Also puts widget inside a wrapper DIV (if not already in one)
				//
				//		If popup widget needs to layout it should
				//		do so when it is made visible, and popup._onShow() is called.
	
				// Create wrapper if not already there
				var wrapper = this._createWrapper(widget);
	
				domStyle.set(wrapper, {
					display: "none",
					height: "auto",			// Open() may have limited the height to fit in the viewport,
					overflowY: "visible",	// and set overflowY to "auto".
					border: ""				// Open() may have moved border from popup to wrapper.
				});
	
				// Open() may have moved border from popup to wrapper.  Move it back.
				var node = widget.domNode;
				if("_originalStyle" in node){
					node.style.cssText = node._originalStyle;
				}
			},
	
			getTopPopup: function(){
				// summary:
				//		Compute the closest ancestor popup that's *not* a child of another popup.
				//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
				var stack = this._stack;
				for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
					/* do nothing, just trying to get right value for pi */
				}
				return stack[pi];
			},
	
			open: function(/*__OpenArgs*/ args){
				// summary:
				//		Popup the widget at the specified position
				//
				// example:
				//		opening at the mouse position
				//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
				//
				// example:
				//		opening the widget as a dropdown
				//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
				//
				//		Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
				//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.
	
				var stack = this._stack,
					widget = args.popup,
					node = widget.domNode,
					orient = args.orient || ["below", "below-alt", "above", "above-alt"],
					ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),
					around = args.around,
					id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);
	
				// If we are opening a new popup that isn't a child of a currently opened popup, then
				// close currently opened popup(s).   This should happen automatically when the old popups
				// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
				while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){
					this.close(stack[stack.length - 1].widget);
				}
	
				// Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
				// off screen) so we can do sizing calculations.
				var wrapper = this.moveOffScreen(widget);
	
				if(widget.startup && !widget._started){
					widget.startup(); // this has to be done after being added to the DOM
				}
	
				// Limit height to space available in viewport either above or below aroundNode (whichever side has more
				// room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
				// dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
				var maxHeight, popupSize = domGeometry.position(node);
				if("maxHeight" in args && args.maxHeight != -1){
					maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
				}else{
					var viewport = Viewport.getEffectiveBox(this.ownerDocument),
						aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
					maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
				}
				if(popupSize.h > maxHeight){
					// Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
					// and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
					var cs = domStyle.getComputedStyle(node),
						borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;
					domStyle.set(wrapper, {
						overflowY: "scroll",
						height: maxHeight + "px",
						border: borderStyle	// so scrollbar is inside border
					});
					node._originalStyle = node.style.cssText;
					node.style.border = "none";
				}
	
				domAttr.set(wrapper, {
					id: id,
					style: {
						zIndex: this._beginZIndex + stack.length
					},
					"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup",
					dijitPopupParent: args.parent ? args.parent.id : ""
				});
	
				if(stack.length == 0 && around){
					// First element on stack. Save position of aroundNode and setup listener for changes to that position.
					this._firstAroundNode = around;
					this._firstAroundPosition = domGeometry.position(around, true);
					this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
				}
	
				if(has("config-bgIframe") && !widget.bgIframe){
					// setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()
					widget.bgIframe = new BackgroundIframe(wrapper);
				}
	
				// position the wrapper node and make it visible
				var layoutFunc = widget.orient ? lang.hitch(widget, "orient") : null,
					best = around ?
						place.around(wrapper, around, orient, ltr, layoutFunc) :
						place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
							layoutFunc);
	
				wrapper.style.visibility = "visible";
				node.style.visibility = "visible";	// counteract effects from _HasDropDown
	
				var handlers = [];
	
				// provide default escape and tab key handling
				// (this will work for any widget, not just menu)
				handlers.push(on(wrapper, "keydown", lang.hitch(this, function(evt){
					if(evt.keyCode == keys.ESCAPE && args.onCancel){
						evt.stopPropagation();
						evt.preventDefault();
						args.onCancel();
					}else if(evt.keyCode == keys.TAB){
						evt.stopPropagation();
						evt.preventDefault();
						var topPopup = this.getTopPopup();
						if(topPopup && topPopup.onCancel){
							topPopup.onCancel();
						}
					}
				})));
	
				// watch for cancel/execute events on the popup and notify the caller
				// (for a menu, "execute" means clicking an item)
				if(widget.onCancel && args.onCancel){
					handlers.push(widget.on("cancel", args.onCancel));
				}
	
				handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onExecute){
						topPopup.onExecute();
					}
				})));
	
				stack.push({
					widget: widget,
					wrapper: wrapper,
					parent: args.parent,
					onExecute: args.onExecute,
					onCancel: args.onCancel,
					onClose: args.onClose,
					handlers: handlers
				});
	
				if(widget.onOpen){
					// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
					widget.onOpen(best);
				}
	
				return best;
			},
	
			close: function(/*Widget?*/ popup){
				// summary:
				//		Close specified popup and any popups that it parented.
				//		If no popup is specified, closes all popups.
	
				var stack = this._stack;
	
				// Basically work backwards from the top of the stack closing popups
				// until we hit the specified popup, but IIRC there was some issue where closing
				// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
				// closing C might close B indirectly and then the while() condition will run where stack==[A]...
				// so the while condition is constructed defensively.
				while((popup && array.some(stack, function(elem){
					return elem.widget == popup;
				})) ||
					(!popup && stack.length)){
					var top = stack.pop(),
						widget = top.widget,
						onClose = top.onClose;
	
					if (widget.bgIframe) {
						// push the iframe back onto the stack.
						widget.bgIframe.destroy();
						delete widget.bgIframe;
					}
	
					if(widget.onClose){
						// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).
						// Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted
						// (i.e. that the TabContainer's tab's [x] icon was clicked)
						widget.onClose();
					}
	
					var h;
					while(h = top.handlers.pop()){
						h.remove();
					}
	
					// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
					if(widget && widget.domNode){
						this.hide(widget);
					}
	
					if(onClose){
						onClose();
					}
				}
	
				if(stack.length == 0 && this._aroundMoveListener){
					clearTimeout(this._aroundMoveListener);
					this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
				}
			}
		});
	
		return (dijit.popup = new PopupManager());
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(23), 
		__webpack_require__(15), 
		__webpack_require__(2), 
		__webpack_require__(12), 
		__webpack_require__(105), 
		__webpack_require__(75),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, domGeometry, domStyle, kernel, win, Viewport, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/place", (function(){
	
		// module:
		//		dijit/place
	
	
		function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
			// summary:
			//		Given a list of spots to put node, put it at the first spot where it fits,
			//		of if it doesn't fit anywhere then the place with the least overflow
			// choices: Array
			//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
			//		Above example says to put the top-left corner of the node at (10,20)
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
			//		for things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			//		It also passes in the available size for the popup, which is useful for tooltips to
			//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
			//		how much the popup had to be modified to fit into the available space.	 This is used to determine
			//		what the best placement is.
			// aroundNodeCoords: Object
			//		Size of aroundNode, ex: {w: 200, h: 50}
	
			// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
			// viewport over document
			var view = Viewport.getEffectiveBox(node.ownerDocument);
	
			// This won't work if the node is inside a <div style="position: relative">,
			// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
			// and also it might get cutoff.)
			if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
				win.body(node.ownerDocument).appendChild(node);
			}
	
			var best = null;
			array.some(choices, function(choice){
				var corner = choice.corner;
				var pos = choice.pos;
				var overflow = 0;
	
				// calculate amount of space available given specified position of node
				var spaceAvailable = {
					w: {
						'L': view.l + view.w - pos.x,
						'R': pos.x - view.l,
						'M': view.w
					}[corner.charAt(1)],
					h: {
						'T': view.t + view.h - pos.y,
						'B': pos.y - view.t,
						'M': view.h
					}[corner.charAt(0)]
				};
	
				// Clear left/right position settings set earlier so they don't interfere with calculations,
				// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
				var s = node.style;
				s.left = s.right = "auto";
	
				// configure node to be displayed in given position relative to button
				// (need to do this in order to get an accurate size for the node, because
				// a tooltip's size changes based on position, due to triangle)
				if(layoutNode){
					var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
					overflow = typeof res == "undefined" ? 0 : res;
				}
	
				// get node's size
				var style = node.style;
				var oldDisplay = style.display;
				var oldVis = style.visibility;
				if(style.display == "none"){
					style.visibility = "hidden";
					style.display = "";
				}
				var bb = domGeometry.position(node);
				style.display = oldDisplay;
				style.visibility = oldVis;
	
				// coordinates and size of node with specified corner placed at pos,
				// and clipped by viewport
				var
					startXpos = {
						'L': pos.x,
						'R': pos.x - bb.w,
						'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
					}[corner.charAt(1)],
					startYpos = {
						'T': pos.y,
						'B': pos.y - bb.h,
						'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
					}[corner.charAt(0)],
					startX = Math.max(view.l, startXpos),
					startY = Math.max(view.t, startYpos),
					endX = Math.min(view.l + view.w, startXpos + bb.w),
					endY = Math.min(view.t + view.h, startYpos + bb.h),
					width = endX - startX,
					height = endY - startY;
	
				overflow += (bb.w - width) + (bb.h - height);
	
				if(best == null || overflow < best.overflow){
					best = {
						corner: corner,
						aroundCorner: choice.aroundCorner,
						x: startX,
						y: startY,
						w: width,
						h: height,
						overflow: overflow,
						spaceAvailable: spaceAvailable
					};
				}
	
				return !overflow;
			});
	
			// In case the best position is not the last one we checked, need to call
			// layoutNode() again.
			if(best.overflow && layoutNode){
				layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
			}
	
			// And then position the node.  Do this last, after the layoutNode() above
			// has sized the node, due to browser quirks when the viewport is scrolled
			// (specifically that a Tooltip will shrink to fit as though the window was
			// scrolled to the left).
	
			var top = best.y,
				side = best.x,
				body = win.body(node.ownerDocument);
	
			if(/relative|absolute/.test(domStyle.get(body, "position"))){
				// compensate for margin on <body>, see #16148
				top -= domStyle.get(body, "marginTop");
				side -= domStyle.get(body, "marginLeft");
			}
	
			var s = node.style;
			s.top = top + "px";
			s.left = side + "px";
			s.right = "auto";	// needed for FF or else tooltip goes to far left
	
			return best;
		}
	
		var reverse = {
			// Map from corner to kitty-corner
			"TL": "BR",
			"TR": "BL",
			"BL": "TR",
			"BR": "TL"
		};
	
		var place = {
			// summary:
			//		Code to place a DOMNode relative to another DOMNode.
			//		Load using require(["dijit/place"], function(place){ ... }).
	
			at: function(node, pos, corners, padding, layoutNode){
				// summary:
				//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
				//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
				//		where node is fully visible, or the corner where it's most visible.
				//
				//		Node is assumed to be absolutely or relatively positioned.
				// node: DOMNode
				//		The node to position
				// pos: dijit/place.__Position
				//		Object like {x: 10, y: 20}
				// corners: String[]
				//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
				//		Possible values are:
				//
				//		- "BL" - bottom left
				//		- "BR" - bottom right
				//		- "TL" - top left
				//		- "TR" - top right
				// padding: dijit/place.__Position?
				//		Optional param to set padding, to put some buffer around the element you want to position.
				//		Defaults to zero.
				// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
				//		For things like tooltip, they are displayed differently (and have different dimensions)
				//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
				// example:
				//		Try to place node's top right corner at (10,20).
				//		If that makes node go (partially) off screen, then try placing
				//		bottom left corner at (10,20).
				//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
				var choices = array.map(corners, function(corner){
					var c = {
						corner: corner,
						aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
						pos: {x: pos.x,y: pos.y}
					};
					if(padding){
						c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
						c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
					}
					return c;
				});
	
				return _place(node, choices, layoutNode);
			},
	
			around: function(
				/*DomNode*/		node,
				/*DomNode|dijit/place.__Rectangle*/ anchor,
				/*String[]*/	positions,
				/*Boolean*/		leftToRight,
				/*Function?*/	layoutNode){
	
				// summary:
				//		Position node adjacent or kitty-corner to anchor
				//		such that it's fully visible in viewport.
				// description:
				//		Place node such that corner of node touches a corner of
				//		aroundNode, and that node is fully visible.
				// anchor:
				//		Either a DOMNode or a rectangle (object with x, y, width, height).
				// positions:
				//		Ordered list of positions to try matching up.
				//
				//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
				//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
				//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
				//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
				//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
				//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
				//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
				//			in the case of RTL scripts like Hebrew and Arabic
				//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
				//			in the case of RTL scripts like Hebrew and Arabic
				//		- above-centered: drop down is centered above anchor node
				//		- above: drop down goes above anchor node, left sides aligned
				//		- above-alt: drop down goes above anchor node, right sides aligned
				//		- below-centered: drop down is centered above anchor node
				//		- below: drop down goes below anchor node
				//		- below-alt: drop down goes below anchor node, right sides aligned
				// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
				//		For things like tooltip, they are displayed differently (and have different dimensions)
				//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
				// leftToRight:
				//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
				//		positions slightly.
				// example:
				//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
				//		This will try to position node such that node's top-left corner is at the same position
				//		as the bottom left corner of the aroundNode (ie, put node below
				//		aroundNode, with left edges aligned).	If that fails it will try to put
				//		the bottom-right corner of node where the top right corner of aroundNode is
				//		(ie, put node above aroundNode, with right edges aligned)
				//
	
				// If around is a DOMNode (or DOMNode id), convert to coordinates.
				var aroundNodePos;
				if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
					aroundNodePos = domGeometry.position(anchor, true);
	
					// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
					// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
					// width of either anchor or popup because in both cases the border may be on an inner node.
					if(/^(above|below)/.test(positions[0])){
						var anchorBorder = domGeometry.getBorderExtents(anchor),
							anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
							nodeBorder =  domGeometry.getBorderExtents(node),
							nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
						aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
						aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
							Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
					}
				}else{
					aroundNodePos = anchor;
				}
	
				// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
				if(anchor.parentNode){
					// ignore nodes between position:relative and position:absolute
					var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
					var parent = anchor.parentNode;
					while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
						var parentPos = domGeometry.position(parent, true),
							pcs = domStyle.getComputedStyle(parent);
						if(/relative|absolute/.test(pcs.position)){
							sawPosAbsolute = false;
						}
						if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
							var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
							var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
							aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
							aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
							aroundNodePos.h = bottomYCoord - aroundNodePos.y;
							aroundNodePos.w = rightXCoord - aroundNodePos.x;
						}
						if(pcs.position == "absolute"){
							sawPosAbsolute = true;
						}
						parent = parent.parentNode;
					}
				}			
	
				var x = aroundNodePos.x,
					y = aroundNodePos.y,
					width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
					height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);
	
				// Convert positions arguments into choices argument for _place()
				var choices = [];
				function push(aroundCorner, corner){
					choices.push({
						aroundCorner: aroundCorner,
						corner: corner,
						pos: {
							x: {
								'L': x,
								'R': x + width,
								'M': x + (width >> 1)
							}[aroundCorner.charAt(1)],
							y: {
								'T': y,
								'B': y + height,
								'M': y + (height >> 1)
							}[aroundCorner.charAt(0)]
						}
					})
				}
				array.forEach(positions, function(pos){
					var ltr =  leftToRight;
					switch(pos){
						case "above-centered":
							push("TM", "BM");
							break;
						case "below-centered":
							push("BM", "TM");
							break;
						case "after-centered":
							ltr = !ltr;
							// fall through
						case "before-centered":
							push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
							break;
						case "after":
							ltr = !ltr;
							// fall through
						case "before":
							push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
							push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
							break;
						case "below-alt":
							ltr = !ltr;
							// fall through
						case "below":
							// first try to align left borders, next try to align right borders (or reverse for RTL mode)
							push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
							push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
							break;
						case "above-alt":
							ltr = !ltr;
							// fall through
						case "above":
							// first try to align left borders, next try to align right borders (or reverse for RTL mode)
							push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
							push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
							break;
						default:
							// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
							// Not meant to be used directly.  Remove for 2.0.
							push(pos.aroundCorner, pos.corner);
					}
				});
	
				var position = _place(node, choices, layoutNode, {w: width, h: height});
				position.aroundNodePos = aroundNodePos;
	
				return position;
			}
		};
	
		/*=====
		place.__Position = {
			// x: Integer
			//		horizontal coordinate in pixels, relative to document body
			// y: Integer
			//		vertical coordinate in pixels, relative to document body
		};
		place.__Rectangle = {
			// x: Integer
			//		horizontal offset in pixels, relative to document body
			// y: Integer
			//		vertical offset in pixels, relative to document body
			// w: Integer
			//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
			// h: Integer
			//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
		};
		=====*/
	
		return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(6),			
		__webpack_require__(75),	
		__webpack_require__(7),
		__webpack_require__(11), 
		__webpack_require__(15), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(9),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(require, dijit, config, domConstruct, domStyle, lang, on, has,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/BackgroundIframe", (function(){
	
		// module:
		//		dijit/BackgroundIFrame
	
		// Flag for whether to create background iframe behind popups like Menus and Dialog.
		// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
		// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
		// By default, it's enabled for IE6-10, excluding Windows Phone 8,
		// and it's also enabled for IE11 on Windows 7 and Windows 2008 Server.
		// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
		// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
		has.add("config-bgIframe",
			(has("ie") && !/IEMobile\/10\.0/.test(navigator.userAgent)) || // No iframe on WP8, to match 1.9 behavior
			(has("trident") && /Windows NT 6.[01]/.test(navigator.userAgent)));
	
		var _frames = new function(){
			// summary:
			//		cache of iframes
	
			var queue = [];
	
			this.pop = function(){
				var iframe;
				if(queue.length){
					iframe = queue.pop();
					iframe.style.display="";
				}else{
					// transparency needed for DialogUnderlay and for tooltips on IE (to see screen near connector)
					if(has("ie") < 9){
						var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
						var html="<iframe src='" + burl + "' role='presentation'"
							+ " style='position: absolute; left: 0px; top: 0px;"
							+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
						iframe = document.createElement(html);
					}else{
						iframe = domConstruct.create("iframe");
						iframe.src = 'javascript:""';
						iframe.className = "dijitBackgroundIframe";
						iframe.setAttribute("role", "presentation");
						domStyle.set(iframe, "opacity", 0.1);
					}
					iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
				}
				return iframe;
			};
	
			this.push = function(iframe){
				iframe.style.display="none";
				queue.push(iframe);
			}
		}();
	
	
		dijit.BackgroundIframe = function(/*DomNode*/ node){
			// summary:
			//		For IE/FF z-index shenanigans. id attribute is required.
			//
			// description:
			//		new dijit.BackgroundIframe(node).
			//
			//		Makes a background iframe as a child of node, that fills
			//		area (and position) of node
	
			if(!node.id){ throw new Error("no id"); }
			if(has("config-bgIframe")){
				var iframe = (this.iframe = _frames.pop());
				node.appendChild(iframe);
				if(has("ie")<7 || has("quirks")){
					this.resize(node);
					this._conn = on(node, 'resize', lang.hitch(this, "resize", node));
				}else{
					domStyle.set(iframe, {
						width: '100%',
						height: '100%'
					});
				}
			}
		};
	
		lang.extend(dijit.BackgroundIframe, {
			resize: function(node){
				// summary:
				//		Resize the iframe so it's the same size as node.
				//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
				if(this.iframe){
					domStyle.set(this.iframe, {
						width: node.offsetWidth + 'px',
						height: node.offsetHeight + 'px'
					});
				}
			},
			destroy: function(){
				// summary:
				//		destroy the iframe
				if(this._conn){
					this._conn.remove();
					this._conn = null;
				}
				if(this.iframe){
					this.iframe.parentNode.removeChild(this.iframe);
					_frames.push(this.iframe);
					delete this.iframe;
				}
			}
		});
	
		return dijit.BackgroundIframe;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(7),  __webpack_require__(8), __webpack_require__(21), __webpack_require__(143), __webpack_require__(19), __webpack_require__(9), __webpack_require__(13), __webpack_require__(15)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, config, /*===== declare, =====*/ lang, Evented, Color, aspect, has, dom, style){
		// module:
		//		dojo/_base/fx
		// notes:
		//		Animation loosely package based on Dan Pupius' work, contributed under CLA; see
		//		http://pupius.co.uk/js/Toolkit.Drawing.js
	
		var _mixin = lang.mixin;
	
		// Module export
		var basefx = {
			// summary:
			//		This module defines the base dojo/_base/fx implementation.
		};
	
		var _Line = basefx._Line = function(/*int*/ start, /*int*/ end){
			// summary:
			//		Object used to generate values from a start value to an end value
			// start: int
			//		Beginning value for range
			// end: int
			//		Ending value for range
			this.start = start;
			this.end = end;
		};
	
		_Line.prototype.getValue = function(/*float*/ n){
			// summary:
			//		Returns the point on the line
			// n:
			//		a floating point number greater than 0 and less than 1
			return ((this.end - this.start) * n) + this.start; // Decimal
		};
	
		var Animation = basefx.Animation = function(args){
			// summary:
			//		A generic animation class that fires callbacks into its handlers
			//		object at various states.
			// description:
			//		A generic animation class that fires callbacks into its handlers
			//		object at various states. Nearly all dojo animation functions
			//		return an instance of this method, usually without calling the
			//		.play() method beforehand. Therefore, you will likely need to
			//		call .play() on instances of `Animation` when one is
			//		returned.
			// args: Object
			//		The 'magic argument', mixing all the properties into this
			//		animation instance.
	
			_mixin(this, args);
			if(lang.isArray(this.curve)){
				this.curve = new _Line(this.curve[0], this.curve[1]);
			}
	
		};
		Animation.prototype = new Evented();
	
		lang.extend(Animation, {
			// duration: Integer
			//		The time in milliseconds the animation will take to run
			duration: 350,
	
		/*=====
			// curve: _Line|Array
			//		A two element array of start and end values, or a `_Line` instance to be
			//		used in the Animation.
			curve: null,
	
			// easing: Function?
			//		A Function to adjust the acceleration (or deceleration) of the progress
			//		across a _Line
			easing: null,
		=====*/
	
			// repeat: Integer?
			//		The number of times to loop the animation
			repeat: 0,
	
			// rate: Integer?
			//		the time in milliseconds to wait before advancing to next frame
			//		(used as a fps timer: 1000/rate = fps)
			rate: 20 /* 50 fps */,
	
		/*=====
			// delay: Integer?
			//		The time in milliseconds to wait before starting animation after it
			//		has been .play()'ed
			delay: null,
	
			// beforeBegin: Event?
			//		Synthetic event fired before a Animation begins playing (synchronous)
			beforeBegin: null,
	
			// onBegin: Event?
			//		Synthetic event fired as a Animation begins playing (useful?)
			onBegin: null,
	
			// onAnimate: Event?
			//		Synthetic event fired at each interval of the Animation
			onAnimate: null,
	
			// onEnd: Event?
			//		Synthetic event fired after the final frame of the Animation
			onEnd: null,
	
			// onPlay: Event?
			//		Synthetic event fired any time the Animation is play()'ed
			onPlay: null,
	
			// onPause: Event?
			//		Synthetic event fired when the Animation is paused
			onPause: null,
	
			// onStop: Event
			//		Synthetic event fires when the Animation is stopped
			onStop: null,
	
		=====*/
	
			_percent: 0,
			_startRepeatCount: 0,
	
			_getStep: function(){
				var _p = this._percent,
					_e = this.easing
				;
				return _e ? _e(_p) : _p;
			},
			_fire: function(/*Event*/ evt, /*Array?*/ args){
				// summary:
				//		Convenience function.  Fire event "evt" and pass it the
				//		arguments specified in "args".
				// description:
				//		Convenience function.  Fire event "evt" and pass it the
				//		arguments specified in "args".
				//		Fires the callback in the scope of this Animation
				//		instance.
				// evt:
				//		The event to fire.
				// args:
				//		The arguments to pass to the event.
				var a = args||[];
				if(this[evt]){
					if(config.debugAtAllCosts){
						this[evt].apply(this, a);
					}else{
						try{
							this[evt].apply(this, a);
						}catch(e){
							// squelch and log because we shouldn't allow exceptions in
							// synthetic event handlers to cause the internal timer to run
							// amuck, potentially pegging the CPU. I'm not a fan of this
							// squelch, but hopefully logging will make it clear what's
							// going on
							console.error("exception in animation handler for:", evt);
							console.error(e);
						}
					}
				}
				return this; // Animation
			},
	
			play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
				// summary:
				//		Start the animation.
				// delay:
				//		How many milliseconds to delay before starting.
				// gotoStart:
				//		If true, starts the animation from the beginning; otherwise,
				//		starts it from its current position.
				// returns: Animation
				//		The instance to allow chaining.
	
				var _t = this;
				if(_t._delayTimer){ _t._clearTimer(); }
				if(gotoStart){
					_t._stopTimer();
					_t._active = _t._paused = false;
					_t._percent = 0;
				}else if(_t._active && !_t._paused){
					return _t;
				}
	
				_t._fire("beforeBegin", [_t.node]);
	
				var de = delay || _t.delay,
					_p = lang.hitch(_t, "_play", gotoStart);
	
				if(de > 0){
					_t._delayTimer = setTimeout(_p, de);
					return _t;
				}
				_p();
				return _t;	// Animation
			},
	
			_play: function(gotoStart){
				var _t = this;
				if(_t._delayTimer){ _t._clearTimer(); }
				_t._startTime = new Date().valueOf();
				if(_t._paused){
					_t._startTime -= _t.duration * _t._percent;
				}
	
				_t._active = true;
				_t._paused = false;
				var value = _t.curve.getValue(_t._getStep());
				if(!_t._percent){
					if(!_t._startRepeatCount){
						_t._startRepeatCount = _t.repeat;
					}
					_t._fire("onBegin", [value]);
				}
	
				_t._fire("onPlay", [value]);
	
				_t._cycle();
				return _t; // Animation
			},
	
			pause: function(){
				// summary:
				//		Pauses a running animation.
				var _t = this;
				if(_t._delayTimer){ _t._clearTimer(); }
				_t._stopTimer();
				if(!_t._active){ return _t; /*Animation*/ }
				_t._paused = true;
				_t._fire("onPause", [_t.curve.getValue(_t._getStep())]);
				return _t; // Animation
			},
	
			gotoPercent: function(/*Decimal*/ percent, /*Boolean?*/ andPlay){
				// summary:
				//		Sets the progress of the animation.
				// percent:
				//		A percentage in decimal notation (between and including 0.0 and 1.0).
				// andPlay:
				//		If true, play the animation after setting the progress.
				var _t = this;
				_t._stopTimer();
				_t._active = _t._paused = true;
				_t._percent = percent;
				if(andPlay){ _t.play(); }
				return _t; // Animation
			},
	
			stop: function(/*boolean?*/ gotoEnd){
				// summary:
				//		Stops a running animation.
				// gotoEnd:
				//		If true, the animation will end.
				var _t = this;
				if(_t._delayTimer){ _t._clearTimer(); }
				if(!_t._timer){ return _t; /* Animation */ }
				_t._stopTimer();
				if(gotoEnd){
					_t._percent = 1;
				}
				_t._fire("onStop", [_t.curve.getValue(_t._getStep())]);
				_t._active = _t._paused = false;
				return _t; // Animation
			},
	
			destroy: function(){
				// summary:
				//		cleanup the animation
				this.stop();
			},
	
			status: function(){
				// summary:
				//		Returns a string token representation of the status of
				//		the animation, one of: "paused", "playing", "stopped"
				if(this._active){
					return this._paused ? "paused" : "playing"; // String
				}
				return "stopped"; // String
			},
	
			_cycle: function(){
				var _t = this;
				if(_t._active){
					var curr = new Date().valueOf();
					// Allow durations of 0 (instant) by setting step to 1 - see #13798
					var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / (_t.duration);
	
					if(step >= 1){
						step = 1;
					}
					_t._percent = step;
	
					// Perform easing
					if(_t.easing){
						step = _t.easing(step);
					}
	
					_t._fire("onAnimate", [_t.curve.getValue(step)]);
	
					if(_t._percent < 1){
						_t._startTimer();
					}else{
						_t._active = false;
	
						if(_t.repeat > 0){
							_t.repeat--;
							_t.play(null, true);
						}else if(_t.repeat == -1){
							_t.play(null, true);
						}else{
							if(_t._startRepeatCount){
								_t.repeat = _t._startRepeatCount;
								_t._startRepeatCount = 0;
							}
						}
						_t._percent = 0;
						_t._fire("onEnd", [_t.node]);
						!_t.repeat && _t._stopTimer();
					}
				}
				return _t; // Animation
			},
	
			_clearTimer: function(){
				// summary:
				//		Clear the play delay timer
				clearTimeout(this._delayTimer);
				delete this._delayTimer;
			}
	
		});
	
		// the local timer, stubbed into all Animation instances
		var ctr = 0,
			timer = null,
			runner = {
				run: function(){}
			};
	
		lang.extend(Animation, {
	
			_startTimer: function(){
				if(!this._timer){
					this._timer = aspect.after(runner, "run", lang.hitch(this, "_cycle"), true);
					ctr++;
				}
				if(!timer){
					timer = setInterval(lang.hitch(runner, "run"), this.rate);
				}
			},
	
			_stopTimer: function(){
				if(this._timer){
					this._timer.remove();
					this._timer = null;
					ctr--;
				}
				if(ctr <= 0){
					clearInterval(timer);
					timer = null;
					ctr = 0;
				}
			}
	
		});
	
		var _makeFadeable =
			has("ie") ? function(node){
				// only set the zoom if the "tickle" value would be the same as the
				// default
				var ns = node.style;
				// don't set the width to auto if it didn't already cascade that way.
				// We don't want to f anyones designs
				if(!ns.width.length && style.get(node, "width") == "auto"){
					ns.width = "auto";
				}
			} :
			function(){};
	
		basefx._fade = function(/*Object*/ args){
			// summary:
			//		Returns an animation that will fade the node defined by
			//		args.node from the start to end values passed (args.start
			//		args.end) (end is mandatory, start is optional)
	
			args.node = dom.byId(args.node);
			var fArgs = _mixin({ properties: {} }, args),
				props = (fArgs.properties.opacity = {});
	
			props.start = !("start" in fArgs) ?
				function(){
					return +style.get(fArgs.node, "opacity")||0;
				} : fArgs.start;
			props.end = fArgs.end;
	
			var anim = basefx.animateProperty(fArgs);
			aspect.after(anim, "beforeBegin", lang.partial(_makeFadeable, fArgs.node), true);
	
			return anim; // Animation
		};
	
		/*=====
		var __FadeArgs = declare(null, {
			// node: DOMNode|String
			//		The node referenced in the animation
			// duration: Integer?
			//		Duration of the animation in milliseconds.
			// easing: Function?
			//		An easing function.
		});
		=====*/
	
		basefx.fadeIn = function(/*__FadeArgs*/ args){
			// summary:
			//		Returns an animation that will fade node defined in 'args' from
			//		its current opacity to fully opaque.
			return basefx._fade(_mixin({ end: 1 }, args)); // Animation
		};
	
		basefx.fadeOut = function(/*__FadeArgs*/ args){
			// summary:
			//		Returns an animation that will fade node defined in 'args'
			//		from its current opacity to fully transparent.
			return basefx._fade(_mixin({ end: 0 }, args)); // Animation
		};
	
		basefx._defaultEasing = function(/*Decimal?*/ n){
			// summary:
			//		The default easing function for Animation(s)
			return 0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2);	// Decimal
		};
	
		var PropLine = function(properties){
			// PropLine is an internal class which is used to model the values of
			// an a group of CSS properties across an animation lifecycle. In
			// particular, the "getValue" function handles getting interpolated
			// values between start and end for a particular CSS value.
			this._properties = properties;
			for(var p in properties){
				var prop = properties[p];
				if(prop.start instanceof Color){
					// create a reusable temp color object to keep intermediate results
					prop.tempColor = new Color();
				}
			}
		};
	
		PropLine.prototype.getValue = function(r){
			var ret = {};
			for(var p in this._properties){
				var prop = this._properties[p],
					start = prop.start;
				if(start instanceof Color){
					ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
				}else if(!lang.isArray(start)){
					ret[p] = ((prop.end - start) * r) + start + (p != "opacity" ? prop.units || "px" : 0);
				}
			}
			return ret;
		};
	
		/*=====
		var __AnimArgs = declare(__FadeArgs, {
			// properties: Object?
			//		A hash map of style properties to Objects describing the transition,
			//		such as the properties of _Line with an additional 'units' property
			properties: {}
	
			//TODOC: add event callbacks
		});
		=====*/
	
		basefx.animateProperty = function(/*__AnimArgs*/ args){
			// summary:
			//		Returns an animation that will transition the properties of
			//		node defined in `args` depending how they are defined in
			//		`args.properties`
			//
			// description:
			//		Foundation of most `dojo/_base/fx`
			//		animations. It takes an object of "properties" corresponding to
			//		style properties, and animates them in parallel over a set
			//		duration.
			//
			// example:
			//		A simple animation that changes the width of the specified node.
			//	|	basefx.animateProperty({
			//	|		node: "nodeId",
			//	|		properties: { width: 400 },
			//	|	}).play();
			//		Dojo figures out the start value for the width and converts the
			//		integer specified for the width to the more expressive but
			//		verbose form `{ width: { end: '400', units: 'px' } }` which you
			//		can also specify directly. Defaults to 'px' if omitted.
			//
			// example:
			//		Animate width, height, and padding over 2 seconds... the
			//		pedantic way:
			//	|	basefx.animateProperty({ node: node, duration:2000,
			//	|		properties: {
			//	|			width: { start: '200', end: '400', units:"px" },
			//	|			height: { start:'200', end: '400', units:"px" },
			//	|			paddingTop: { start:'5', end:'50', units:"px" }
			//	|		}
			//	|	}).play();
			//		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
			//		are written using "mixed case", as the hyphen is illegal as an object key.
			//
			// example:
			//		Plug in a different easing function and register a callback for
			//		when the animation ends. Easing functions accept values between
			//		zero and one and return a value on that basis. In this case, an
			//		exponential-in curve.
			//	|	basefx.animateProperty({
			//	|		node: "nodeId",
			//	|		// dojo figures out the start value
			//	|		properties: { width: { end: 400 } },
			//	|		easing: function(n){
			//	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
			//	|		},
			//	|		onEnd: function(node){
			//	|			// called when the animation finishes. The animation
			//	|			// target is passed to this function
			//	|		}
			//	|	}).play(500); // delay playing half a second
			//
			// example:
			//		Like all `Animation`s, animateProperty returns a handle to the
			//		Animation instance, which fires the events common to Dojo FX. Use `aspect.after`
			//		to access these events outside of the Animation definition:
			//	|	var anim = basefx.animateProperty({
			//	|		node:"someId",
			//	|		properties:{
			//	|			width:400, height:500
			//	|		}
			//	|	});
			//	|	aspect.after(anim, "onEnd", function(){
			//	|		console.log("animation ended");
			//	|	}, true);
			//	|	// play the animation now:
			//	|	anim.play();
			//
			// example:
			//		Each property can be a function whose return value is substituted along.
			//		Additionally, each measurement (eg: start, end) can be a function. The node
			//		reference is passed directly to callbacks.
			//	|	basefx.animateProperty({
			//	|		node:"mine",
			//	|		properties:{
			//	|			height:function(node){
			//	|				// shrink this node by 50%
			//	|				return domGeom.position(node).h / 2
			//	|			},
			//	|			width:{
			//	|				start:function(node){ return 100; },
			//	|				end:function(node){ return 200; }
			//	|			}
			//	|		}
			//	|	}).play();
			//
	
			var n = args.node = dom.byId(args.node);
			if(!args.easing){ args.easing = dojo._defaultEasing; }
	
			var anim = new Animation(args);
			aspect.after(anim, "beforeBegin", lang.hitch(anim, function(){
				var pm = {};
				for(var p in this.properties){
					// Make shallow copy of properties into pm because we overwrite
					// some values below. In particular if start/end are functions
					// we don't want to overwrite them or the functions won't be
					// called if the animation is reused.
					if(p == "width" || p == "height"){
						this.node.display = "block";
					}
					var prop = this.properties[p];
					if(lang.isFunction(prop)){
						prop = prop(n);
					}
					prop = pm[p] = _mixin({}, (lang.isObject(prop) ? prop: { end: prop }));
	
					if(lang.isFunction(prop.start)){
						prop.start = prop.start(n);
					}
					if(lang.isFunction(prop.end)){
						prop.end = prop.end(n);
					}
					var isColor = (p.toLowerCase().indexOf("color") >= 0);
					function getStyle(node, p){
						// domStyle.get(node, "height") can return "auto" or "" on IE; this is more reliable:
						var v = { height: node.offsetHeight, width: node.offsetWidth }[p];
						if(v !== undefined){ return v; }
						v = style.get(node, p);
						return (p == "opacity") ? +v : (isColor ? v : parseFloat(v));
					}
					if(!("end" in prop)){
						prop.end = getStyle(n, p);
					}else if(!("start" in prop)){
						prop.start = getStyle(n, p);
					}
	
					if(isColor){
						prop.start = new Color(prop.start);
						prop.end = new Color(prop.end);
					}else{
						prop.start = (p == "opacity") ? +prop.start : parseFloat(prop.start);
					}
				}
				this.curve = new PropLine(pm);
			}), true);
			aspect.after(anim, "onAnimate", lang.hitch(style, "set", anim.node), true);
			return anim; // Animation
		};
	
		basefx.anim = function(	/*DOMNode|String*/	node,
								/*Object*/			properties,
								/*Integer?*/		duration,
								/*Function?*/		easing,
								/*Function?*/		onEnd,
								/*Integer?*/		delay){
			// summary:
			//		A simpler interface to `animateProperty()`, also returns
			//		an instance of `Animation` but begins the animation
			//		immediately, unlike nearly every other Dojo animation API.
			// description:
			//		Simpler (but somewhat less powerful) version
			//		of `animateProperty`.  It uses defaults for many basic properties
			//		and allows for positional parameters to be used in place of the
			//		packed "property bag" which is used for other Dojo animation
			//		methods.
			//
			//		The `Animation` object returned will be already playing, so
			//		calling play() on it again is (usually) a no-op.
			// node:
			//		a DOM node or the id of a node to animate CSS properties on
			// duration:
			//		The number of milliseconds over which the animation
			//		should run. Defaults to the global animation default duration
			//		(350ms).
			// easing:
			//		An easing function over which to calculate acceleration
			//		and deceleration of the animation through its duration.
			//		A default easing algorithm is provided, but you may
			//		plug in any you wish. A large selection of easing algorithms
			//		are available in `dojo/fx/easing`.
			// onEnd:
			//		A function to be called when the animation finishes
			//		running.
			// delay:
			//		The number of milliseconds to delay beginning the
			//		animation by. The default is 0.
			// example:
			//		Fade out a node
			//	|	basefx.anim("id", { opacity: 0 });
			// example:
			//		Fade out a node over a full second
			//	|	basefx.anim("id", { opacity: 0 }, 1000);
			return basefx.animateProperty({ // Animation
				node: node,
				duration: duration || Animation.prototype.duration,
				properties: properties,
				easing: easing,
				onEnd: onEnd
			}).play(delay || 0);
		};
	
	
		if(has("extend-dojo")){
			_mixin(dojo, basefx);
			// Alias to drop come 2.0:
			dojo._Animation = Animation;
		}
	
		return basefx;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(8), __webpack_require__(28), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojo, lang, ArrayUtil, config){
	
		var Color = dojo.Color = function(/*Array|String|Object*/ color){
			// summary:
			//		Takes a named string, hex string, array of rgb or rgba values,
			//		an object with r, g, b, and a properties, or another `Color` object
			//		and creates a new Color instance to work from.
			//
			// example:
			//		Work with a Color instance:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var c = new Color();
			//	|		c.setColor([0,0,0]); // black
			//	|		var hex = c.toHex(); // #000000
			//	|	});
			//
			// example:
			//		Work with a node's color:
			//	| 
			//	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
			//	|		var color = domStyle("someNode", "backgroundColor");
			//	|		var n = new Color(color);
			//	|		// adjust the color some
			//	|		n.r *= .5;
			//	|		console.log(n.toString()); // rgb(128, 255, 255);
			//	|	});
			if(color){ this.setColor(color); }
		};
	
		// FIXME:
		// there's got to be a more space-efficient way to encode or discover
		// these!! Use hex?
		Color.named = {
			// summary:
			//		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
			"black":  [0,0,0],
			"silver": [192,192,192],
			"gray":	  [128,128,128],
			"white":  [255,255,255],
			"maroon": [128,0,0],
			"red":	  [255,0,0],
			"purple": [128,0,128],
			"fuchsia":[255,0,255],
			"green":  [0,128,0],
			"lime":	  [0,255,0],
			"olive":  [128,128,0],
			"yellow": [255,255,0],
			"navy":	  [0,0,128],
			"blue":	  [0,0,255],
			"teal":	  [0,128,128],
			"aqua":	  [0,255,255],
			"transparent": config.transparentColor || [0,0,0,0]
		};
	
		lang.extend(Color, {
			r: 255, g: 255, b: 255, a: 1,
			_set: function(r, g, b, a){
				var t = this; t.r = r; t.g = g; t.b = b; t.a = a;
			},
			setColor: function(/*Array|String|Object*/ color){
				// summary:
				//		Takes a named string, hex string, array of rgb or rgba values,
				//		an object with r, g, b, and a properties, or another `Color` object
				//		and sets this color instance to that value.
				//
				// example:
				//	|	require(["dojo/_base/color"], function(Color){
				//	|		var c = new Color(); // no color
				//	|		c.setColor("#ededed"); // greyish
				//	|	});
				if(lang.isString(color)){
					Color.fromString(color, this);
				}else if(lang.isArray(color)){
					Color.fromArray(color, this);
				}else{
					this._set(color.r, color.g, color.b, color.a);
					if(!(color instanceof Color)){ this.sanitize(); }
				}
				return this;	// Color
			},
			sanitize: function(){
				// summary:
				//		Ensures the object has correct attributes
				// description:
				//		the default implementation does nothing, include dojo.colors to
				//		augment it with real checks
				return this;	// Color
			},
			toRgb: function(){
				// summary:
				//		Returns 3 component array of rgb values
				// example:
				//	|	require(["dojo/_base/color"], function(Color){
				//	|		var c = new Color("#000000");
				//	|		console.log(c.toRgb()); // [0,0,0]
				//	|	});
				var t = this;
				return [t.r, t.g, t.b]; // Array
			},
			toRgba: function(){
				// summary:
				//		Returns a 4 component array of rgba values from the color
				//		represented by this object.
				var t = this;
				return [t.r, t.g, t.b, t.a];	// Array
			},
			toHex: function(){
				// summary:
				//		Returns a CSS color string in hexadecimal representation
				// example:
				//	|	require(["dojo/_base/color"], function(Color){
				//	|		console.log(new Color([0,0,0]).toHex()); // #000000
				//	|	});
				var arr = ArrayUtil.map(["r", "g", "b"], function(x){
					var s = this[x].toString(16);
					return s.length < 2 ? "0" + s : s;
				}, this);
				return "#" + arr.join("");	// String
			},
			toCss: function(/*Boolean?*/ includeAlpha){
				// summary:
				//		Returns a css color string in rgb(a) representation
				// example:
				//	|	require(["dojo/_base/color"], function(Color){
				//	|		var c = new Color("#FFF").toCss();
				//	|		console.log(c); // rgb('255','255','255')
				//	|	});
				var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
				return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";	// String
			},
			toString: function(){
				// summary:
				//		Returns a visual representation of the color
				return this.toCss(true); // String
			}
		});
	
		Color.blendColors = dojo.blendColors = function(
			/*Color*/ start,
			/*Color*/ end,
			/*Number*/ weight,
			/*Color?*/ obj
		){
			// summary:
			//		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
			//		can reuse a previously allocated Color object for the result
			var t = obj || new Color();
			ArrayUtil.forEach(["r", "g", "b", "a"], function(x){
				t[x] = start[x] + (end[x] - start[x]) * weight;
				if(x != "a"){ t[x] = Math.round(t[x]); }
			});
			return t.sanitize();	// Color
		};
	
		Color.fromRgb = dojo.colorFromRgb = function(/*String*/ color, /*Color?*/ obj){
			// summary:
			//		Returns a `Color` instance from a string of the form
			//		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
			//		object to update with the parsed value and return instead of
			//		creating a new object.
			// returns:
			//		A Color object. If obj is passed, it will be the return value.
			var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
			return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);	// Color
		};
	
		Color.fromHex = dojo.colorFromHex = function(/*String*/ color, /*Color?*/ obj){
			// summary:
			//		Converts a hex string with a '#' prefix to a color object.
			//		Supports 12-bit #rgb shorthand. Optionally accepts a
			//		`Color` object to update with the parsed value.
			//
			// returns:
			//		A Color object. If obj is passed, it will be the return value.
			//
			// example:
			//	|	require(["dojo/_base/color"], function(Color){
			//	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
			//	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
			//	|	});
			var t = obj || new Color(),
				bits = (color.length == 4) ? 4 : 8,
				mask = (1 << bits) - 1;
			color = Number("0x" + color.substr(1));
			if(isNaN(color)){
				return null; // Color
			}
			ArrayUtil.forEach(["b", "g", "r"], function(x){
				var c = color & mask;
				color >>= bits;
				t[x] = bits == 4 ? 17 * c : c;
			});
			t.a = 1;
			return t;	// Color
		};
	
		Color.fromArray = dojo.colorFromArray = function(/*Array*/ a, /*Color?*/ obj){
			// summary:
			//		Builds a `Color` from a 3 or 4 element array, mapping each
			//		element in sequence to the rgb(a) values of the color.
			// example:
			//		|	require(["dojo/_base/color"], function(Color){
			//		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
			//		|	});
			// returns:
			//		A Color object. If obj is passed, it will be the return value.
			var t = obj || new Color();
			t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
			if(isNaN(t.a)){ t.a = 1; }
			return t.sanitize();	// Color
		};
	
		Color.fromString = dojo.colorFromString = function(/*String*/ str, /*Color?*/ obj){
			// summary:
			//		Parses `str` for a color value. Accepts hex, rgb, and rgba
			//		style color values.
			// description:
			//		Acceptable input values for str may include arrays of any form
			//		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
			//		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
			//		10, 50)"
			// returns:
			//		A Color object. If obj is passed, it will be the return value.
			var a = Color.named[str];
			return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);	// Color
		};
	
		return Color;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 144 */,
/* 145 */,
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(125),
		__webpack_require__(13), 
		__webpack_require__(14), 
		__webpack_require__(27), 
		__webpack_require__(23), 
		__webpack_require__(15), 
		__webpack_require__(4), 
		__webpack_require__(26), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(81),
		__webpack_require__(74), 
		__webpack_require__(90),
		__webpack_require__(127),
		__webpack_require__(89),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
				registry, focus, popup, _FocusMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_HasDropDown", (function(){
	
	
		// module:
		//		dijit/_HasDropDown
	
		return declare("dijit._HasDropDown", _FocusMixin, {
			// summary:
			//		Mixin for widgets that need drop down ability.
	
			// _buttonNode: [protected] DomNode
			//		The button/icon/node to click to display the drop down.
			//		Can be set via a data-dojo-attach-point assignment.
			//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
			_buttonNode: null,
	
			// _arrowWrapperNode: [protected] DomNode
			//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
			//		on where the drop down is set to be positioned.
			//		Can be set via a data-dojo-attach-point assignment.
			//		If missing, then _buttonNode will be used.
			_arrowWrapperNode: null,
	
			// _popupStateNode: [protected] DomNode
			//		The node to set the aria-expanded class on.
			//		Also sets popupActive class but that will be removed in 2.0.
			//		Can be set via a data-dojo-attach-point assignment.
			//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
			_popupStateNode: null,
	
			// _aroundNode: [protected] DomNode
			//		The node to display the popup around.
			//		Can be set via a data-dojo-attach-point assignment.
			//		If missing, then domNode will be used.
			_aroundNode: null,
	
			// dropDown: [protected] Widget
			//		The widget to display as a popup.  This widget *must* be
			//		defined before the startup function is called.
			dropDown: null,
	
			// autoWidth: [protected] Boolean
			//		Set to true to make the drop down at least as wide as this
			//		widget.  Set to false if the drop down should just be its
			//		default width.
			autoWidth: true,
	
			// forceWidth: [protected] Boolean
			//		Set to true to make the drop down exactly as wide as this
			//		widget.  Overrides autoWidth.
			forceWidth: false,
	
			// maxHeight: [protected] Integer
			//		The max height for our dropdown.
			//		Any dropdown taller than this will have scrollbars.
			//		Set to 0 for no max height, or -1 to limit height to available space in viewport
			maxHeight: -1,
	
			// dropDownPosition: [const] String[]
			//		This variable controls the position of the drop down.
			//		It's an array of strings with the following values:
			//
			//		- before: places drop down to the left of the target node/widget, or to the right in
			//		  the case of RTL scripts like Hebrew and Arabic
			//		- after: places drop down to the right of the target node/widget, or to the left in
			//		  the case of RTL scripts like Hebrew and Arabic
			//		- above: drop down goes above target node
			//		- below: drop down goes below target node
			//
			//		The list is positions is tried, in order, until a position is found where the drop down fits
			//		within the viewport.
			//
			dropDownPosition: ["below", "above"],
	
			// _stopClickEvents: Boolean
			//		When set to false, the click events will not be stopped, in
			//		case you want to use them in your subclass
			_stopClickEvents: true,
	
			_onDropDownMouseDown: function(/*Event*/ e){
				// summary:
				//		Callback when the user mousedown/touchstart on the arrow icon.
	
				if(this.disabled || this.readOnly){
					return;
				}
	
				// Prevent default to stop things like text selection, but don't stop propagation, so that:
				//		1. TimeTextBox etc. can focus the <input> on mousedown
				//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
				//		3. user defined onMouseDown handler fires
				//
				// Also, don't call preventDefault() on MSPointerDown event (on IE10) because that prevents the button
				// from getting focus, and then the focus manager doesn't know what's going on (#17262)
				if(e.type != "MSPointerDown" && e.type != "pointerdown"){
					e.preventDefault();
				}
	
				this.own(on.once(this.ownerDocument, touch.release, lang.hitch(this, "_onDropDownMouseUp")));
	
				this.toggleDropDown();
			},
	
			_onDropDownMouseUp: function(/*Event?*/ e){
				// summary:
				//		Callback on mouseup/touchend after mousedown/touchstart on the arrow icon.
				//		Note that this function is called regardless of what node the event occurred on (but only after
				//		a mousedown/touchstart on the arrow).
				//
				//		If the drop down is a simple menu and the cursor is over the menu, we execute it, otherwise, we focus our
				//		drop down widget.  If the event is missing, then we are not
				//		a mouseup event.
				//
				//		This is useful for the common mouse movement pattern
				//		with native browser `<select>` nodes:
				//
				//		1. mouse down on the select node (probably on the arrow)
				//		2. move mouse to a menu item while holding down the mouse button
				//		3. mouse up.  this selects the menu item as though the user had clicked it.
	
				var dropDown = this.dropDown, overMenu = false;
	
				if(e && this._opened){
					// This code deals with the corner-case when the drop down covers the original widget,
					// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
					// Find out if our target is somewhere in our dropdown widget,
					// but not over our _buttonNode (the clickable node)
					var c = domGeometry.position(this._buttonNode, true);
					if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) || !(e.pageY >= c.y && e.pageY <= c.y + c.h)){
						var t = e.target;
						while(t && !overMenu){
							if(domClass.contains(t, "dijitPopup")){
								overMenu = true;
							}else{
								t = t.parentNode;
							}
						}
						if(overMenu){
							t = e.target;
							if(dropDown.onItemClick){
								var menuItem;
								while(t && !(menuItem = registry.byNode(t))){
									t = t.parentNode;
								}
								if(menuItem && menuItem.onClick && menuItem.getParent){
									menuItem.getParent().onItemClick(menuItem, e);
								}
							}
							return;
						}
					}
				}
				if(this._opened){
					// Focus the dropdown widget unless it's a menu (in which case autoFocus is set to false).
					// Even if it's a menu, we need to focus it if this is a fake mouse event caused by the user typing
					// SPACE/ENTER while using JAWS.  Jaws converts the SPACE/ENTER key into mousedown/mouseup events.
					// If this.hovering is false then it's presumably actually a keyboard event.
					if(dropDown.focus && (dropDown.autoFocus !== false || (e.type == "mouseup" && !this.hovering))){
						// Do it on a delay so that we don't steal back focus from the dropdown.
						this._focusDropDownTimer = this.defer(function(){
							dropDown.focus();
							delete this._focusDropDownTimer;
						});
					}
				}else{
					// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
					// defer() needed to make it work on IE (test DateTextBox)
					if(this.focus){
						this.defer("focus");
					}
				}
			},
	
			_onDropDownClick: function(/*Event*/ e){
				// The drop down was already opened on mousedown/keydown; just need to stop the event
				if(this._stopClickEvents){
					e.stopPropagation();
					e.preventDefault();
				}
			},
	
			buildRendering: function(){
				this.inherited(arguments);
	
				this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
				this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;
	
				// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
				// based on where drop down will normally appear
				var defaultPos = {
					"after": this.isLeftToRight() ? "Right" : "Left",
					"before": this.isLeftToRight() ? "Left" : "Right",
					"above": "Up",
					"below": "Down",
					"left": "Left",
					"right": "Right"
				}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
				domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
			},
	
			postCreate: function(){
				// summary:
				//		set up nodes and connect our mouse and keyboard events
	
				this.inherited(arguments);
	
				var keyboardEventNode = this.focusNode || this.domNode;
				this.own(
					on(this._buttonNode, touch.press, lang.hitch(this, "_onDropDownMouseDown")),
					on(this._buttonNode, "click", lang.hitch(this, "_onDropDownClick")),
					on(keyboardEventNode, "keydown", lang.hitch(this, "_onKey")),
					on(keyboardEventNode, "keyup", lang.hitch(this, "_onKeyUp"))
				);
			},
	
			destroy: function(){
				// If dropdown is open, close it, to avoid leaving dijit/focus in a strange state.
				// Put focus back on me to avoid the focused node getting destroyed, which flummoxes IE.
				if(this._opened){
					this.closeDropDown(true);
				}
	
				if(this.dropDown){
					// Destroy the drop down, unless it's already been destroyed.  This can happen because
					// the drop down is a direct child of <body> even though it's logically my child.
					if(!this.dropDown._destroyed){
						this.dropDown.destroyRecursive();
					}
					delete this.dropDown;
				}
				this.inherited(arguments);
			},
	
			_onKey: function(/*Event*/ e){
				// summary:
				//		Callback when the user presses a key while focused on the button node
	
				if(this.disabled || this.readOnly){
					return;
				}
				var d = this.dropDown, target = e.target;
				if(d && this._opened && d.handleKey){
					if(d.handleKey(e) === false){
						/* false return code means that the drop down handled the key */
						e.stopPropagation();
						e.preventDefault();
						return;
					}
				}
				if(d && this._opened && e.keyCode == keys.ESCAPE){
					this.closeDropDown();
					e.stopPropagation();
					e.preventDefault();
				}else if(!this._opened &&
					(e.keyCode == keys.DOWN_ARROW ||
						// ignore unmodified SPACE if _KeyNavMixin has active searching in progress
						( (e.keyCode == keys.ENTER || (e.keyCode == keys.SPACE && (!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) &&
							//ignore enter and space if the event is for a text input
							((target.tagName || "").toLowerCase() !== 'input' ||
								(target.type && target.type.toLowerCase() !== 'text'))))){
					// Toggle the drop down, but wait until keyup so that the drop down doesn't
					// get a stray keyup event, or in the case of key-repeat (because user held
					// down key for too long), stray keydown events
					this._toggleOnKeyUp = true;
					e.stopPropagation();
					e.preventDefault();
				}
			},
	
			_onKeyUp: function(){
				if(this._toggleOnKeyUp){
					delete this._toggleOnKeyUp;
					this.toggleDropDown();
					var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
					if(d && d.focus){
						this.defer(lang.hitch(d, "focus"), 1);
					}
				}
			},
	
			_onBlur: function(){
				// summary:
				//		Called magically when focus has shifted away from this widget and it's dropdown
	
				// Close dropdown but don't focus my <input>.  User may have focused somewhere else (ex: clicked another
				// input), and even if they just clicked a blank area of the screen, focusing my <input> will unwantedly
				// popup the keyboard on mobile.
				this.closeDropDown(false);
	
				this.inherited(arguments);
			},
	
			isLoaded: function(){
				// summary:
				//		Returns true if the dropdown exists and it's data is loaded.  This can
				//		be overridden in order to force a call to loadDropDown().
				// tags:
				//		protected
	
				return true;
			},
	
			loadDropDown: function(/*Function*/ loadCallback){
				// summary:
				//		Creates the drop down if it doesn't exist, loads the data
				//		if there's an href and it hasn't been loaded yet, and then calls
				//		the given callback.
				// tags:
				//		protected
	
				// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
				loadCallback();
			},
	
			loadAndOpenDropDown: function(){
				// summary:
				//		Creates the drop down if it doesn't exist, loads the data
				//		if there's an href and it hasn't been loaded yet, and
				//		then opens the drop down.  This is basically a callback when the
				//		user presses the down arrow button to open the drop down.
				// returns: Deferred
				//		Deferred for the drop down widget that
				//		fires when drop down is created and loaded
				// tags:
				//		protected
				var d = new Deferred(),
					afterLoad = lang.hitch(this, function(){
						this.openDropDown();
						d.resolve(this.dropDown);
					});
				if(!this.isLoaded()){
					this.loadDropDown(afterLoad);
				}else{
					afterLoad();
				}
				return d;
			},
	
			toggleDropDown: function(){
				// summary:
				//		Callback when the user presses the down arrow button or presses
				//		the down arrow key to open/close the drop down.
				//		Toggle the drop-down widget; if it is up, close it, if not, open it
				// tags:
				//		protected
	
				if(this.disabled || this.readOnly){
					return;
				}
				if(!this._opened){
					this.loadAndOpenDropDown();
				}else{
					this.closeDropDown(true);	// refocus button to avoid hiding node w/focus
				}
			},
	
			openDropDown: function(){
				// summary:
				//		Opens the dropdown for this widget.   To be called only when this.dropDown
				//		has been created and is ready to display (ie, it's data is loaded).
				// returns:
				//		return value of dijit/popup.open()
				// tags:
				//		protected
	
				var dropDown = this.dropDown,
					ddNode = dropDown.domNode,
					aroundNode = this._aroundNode || this.domNode,
					self = this;
	
				var retVal = popup.open({
					parent: this,
					popup: dropDown,
					around: aroundNode,
					orient: this.dropDownPosition,
					maxHeight: this.maxHeight,
					onExecute: function(){
						self.closeDropDown(true);
					},
					onCancel: function(){
						self.closeDropDown(true);
					},
					onClose: function(){
						domAttr.set(self._popupStateNode, "popupActive", false);
						domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
						self._set("_opened", false);	// use set() because _CssStateMixin is watching
					}
				});
	
				// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
				// matches width of aroundNode
				if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
					var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
					var resizeArgs = {
						w: dropDown.domNode.offsetWidth + widthAdjust
					};
					this._origStyle = ddNode.style.cssText;
					if(lang.isFunction(dropDown.resize)){
						dropDown.resize(resizeArgs);
					}else{
						domGeometry.setMarginBox(ddNode, resizeArgs);
					}
	
					// If dropdown is right-aligned then compensate for width change by changing horizontal position
					if(retVal.corner[1] == "R"){
						dropDown._popupWrapper.style.left =
							(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
					}
				}
	
				domAttr.set(this._popupStateNode, "popupActive", "true");
				domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
				this._set("_opened", true);	// use set() because _CssStateMixin is watching
	
				this._popupStateNode.setAttribute("aria-expanded", "true");
				this._popupStateNode.setAttribute("aria-owns", dropDown.id);
	
				// Set aria-labelledby on dropdown if it's not already set to something more meaningful
				if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
					ddNode.setAttribute("aria-labelledby", this.id);
				}
	
				return retVal;
			},
	
			closeDropDown: function(/*Boolean*/ focus){
				// summary:
				//		Closes the drop down on this widget
				// focus:
				//		If true, refocuses the button widget
				// tags:
				//		protected
	
				if(this._focusDropDownTimer){
					this._focusDropDownTimer.remove();
					delete this._focusDropDownTimer;
				}
	
				if(this._opened){
					this._popupStateNode.setAttribute("aria-expanded", "false");
					if(focus && this.focus){
						this.focus();
					}
					popup.close(this.dropDown);
					this._opened = false;
				}
	
				if(this._origStyle){
					this.dropDown.domNode.style.cssText = this._origStyle;
					delete this._origStyle;
				}
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 147 */,
/* 148 */,
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(27), 
		__webpack_require__(23), 
		__webpack_require__(15),
		__webpack_require__(8), 
		__webpack_require__(34), 
		__webpack_require__(74), 
		__webpack_require__(105),
		__webpack_require__(106),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, domClass, domGeometry, domStyle, lang, query,
				registry, Viewport, layoutUtils,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/layout/_ContentPaneResizeMixin", (function(){
	
		// module:
		//		dijit/layout/_ContentPaneResizeMixin
	
		return declare("dijit.layout._ContentPaneResizeMixin", null, {
			// summary:
			//		Resize() functionality of ContentPane.   If there's a single layout widget
			//		child then it will call resize() with the same dimensions as the ContentPane.
			//		Otherwise just calls resize on each child.
			//
			//		Also implements basic startup() functionality, where starting the parent
			//		will start the children
	
			// doLayout: Boolean
			//		- false - don't adjust size of children
			//		- true - if there is a single visible child widget, set it's size to however big the ContentPane is
			doLayout: true,
	
			// isLayoutContainer: [protected] Boolean
			//		Indicates that this widget will call resize() on it's child widgets
			//		when they become visible.
			isLayoutContainer: true,
	
			startup: function(){
				// summary:
				//		See `dijit/layout/_LayoutWidget.startup()` for description.
				//		Although ContentPane doesn't extend _LayoutWidget, it does implement
				//		the same API.
	
				if(this._started){
					return;
				}
	
				var parent = this.getParent();
				this._childOfLayoutWidget = parent && parent.isLayoutContainer;
	
				// I need to call resize() on my child/children (when I become visible), unless
				// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
				this._needLayout = !this._childOfLayoutWidget;
	
				this.inherited(arguments);
	
				if(this._isShown()){
					this._onShow();
				}
	
				if(!this._childOfLayoutWidget){
					// Since my parent isn't a layout container, and my style *may be* width=height=100%
					// or something similar (either set directly or via a CSS class),
					// monitor when viewport size changes so that I can re-layout.
					// This is more for subclasses of ContentPane than ContentPane itself, although it
					// could be useful for a ContentPane if it has a single child widget inheriting ContentPane's size.
					this.own(Viewport.on("resize", lang.hitch(this, "resize")));
				}
			},
	
			_checkIfSingleChild: function(){
				// summary:
				//		Test if we have exactly one visible widget as a child,
				//		and if so assume that we are a container for that widget,
				//		and should propagate startup() and resize() calls to it.
				//		Skips over things like data stores since they aren't visible.
	
				if(!this.doLayout){ return; }
	
				var candidateWidgets = [],
					otherVisibleNodes = false;
	
				query("> *", this.containerNode).some(function(node){
					var widget = registry.byNode(node);
					if(widget && widget.resize){
						candidateWidgets.push(widget);
					}else if(!/script|link|style/i.test(node.nodeName) && node.offsetHeight){
						otherVisibleNodes = true;
					}
				});
	
				this._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ?
					candidateWidgets[0] : null;
	
				// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
				domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
			},
	
			resize: function(changeSize, resultSize){
				// summary:
				//		See `dijit/layout/_LayoutWidget.resize()` for description.
				//		Although ContentPane doesn't extend _LayoutWidget, it does implement
				//		the same API.
	
				this._resizeCalled = true;
	
				this._scheduleLayout(changeSize, resultSize);
			},
	
			_scheduleLayout: function(changeSize, resultSize){
				// summary:
				//		Resize myself, and call resize() on each of my child layout widgets, either now
				//		(if I'm currently visible) or when I become visible
				if(this._isShown()){
					this._layout(changeSize, resultSize);
				}else{
					this._needLayout = true;
					this._changeSize = changeSize;
					this._resultSize = resultSize;
				}
			},
	
			_layout: function(changeSize, resultSize){
				// summary:
				//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
				//		Also, since I am an isLayoutContainer widget, each of my children expects me to
				//		call resize() or layout() on it.
				//
				//		Should be called on initialization and also whenever we get new content
				//		(from an href, or from set('content', ...))... but deferred until
				//		the ContentPane is visible
	
				delete this._needLayout;
	
				// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
				// never called directly, so resize() is our trigger to do the initial href download (see [20099]).
				// However, don't load href for closed TitlePanes.
				if(!this._wasShown && this.open !== false){
					this._onShow();
				}
	
				// Set margin box size, unless it wasn't specified, in which case use current size.
				if(changeSize){
					domGeometry.setMarginBox(this.domNode, changeSize);
				}
	
				// Compute content box size of containerNode in case we [later] need to size our single child.
				var cn = this.containerNode;
				if(cn === this.domNode){
					// If changeSize or resultSize was passed to this method and this.containerNode ==
					// this.domNode then we can compute the content-box size without querying the node,
					// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
					var mb = resultSize || {};
					lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
					if(!("h" in mb) || !("w" in mb)){
						mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
					}
					this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
				}else{
					this._contentBox = domGeometry.getContentBox(cn);
				}
	
				this._layoutChildren();
			},
	
			_layoutChildren: function(){
				// Call _checkIfSingleChild() again in case app has manually mucked w/the content
				// of the ContentPane (rather than changing it through the set("content", ...) API.
				this._checkIfSingleChild();
	
				if(this._singleChild && this._singleChild.resize){
					var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);
	
					// note: if widget has padding this._contentBox will have l and t set,
					// but don't pass them to resize() or it will doubly-offset the child
					this._singleChild.resize({w: cb.w, h: cb.h});
				}else{
					// All my child widgets are independently sized (rather than matching my size),
					// but I still need to call resize() on each child to make it layout.
					var children = this.getChildren(),
						widget,
						i = 0;
					while(widget = children[i++]){
						if(widget.resize){
							widget.resize();
						}
					}
				}
			},
	
			_isShown: function(){
				// summary:
				//		Returns true if the content is currently shown.
				// description:
				//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
				//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
				//		tree every call, and at least solves the performance problem on page load by deferring loading
				//		hidden ContentPanes until they are first shown
	
				if(this._childOfLayoutWidget){
					// If we are TitlePane, etc - we return that only *IF* we've been resized
					if(this._resizeCalled && "open" in this){
						return this.open;
					}
					return this._resizeCalled;
				}else if("open" in this){
					return this.open;		// for TitlePane, etc.
				}else{
					var node = this.domNode, parent = this.domNode.parentNode;
					return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
						parent && parent.style && (parent.style.display != 'none');
				}
			},
	
			_onShow: function(){
				// summary:
				//		Called when the ContentPane is made visible
				// description:
				//		For a plain ContentPane, this is called on initialization, from startup().
				//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
				//		called whenever the pane is made visible.
				//
				//		Does layout/resize of child widget(s)
	
				// Need to keep track of whether ContentPane has been shown (which is different than
				// whether or not it's currently visible).
				this._wasShown = true;
	
				if(this._needLayout){
					// If a layout has been scheduled for when we become visible, do it now
					this._layout(this._changeSize, this._resultSize);
				}
	
				this.inherited(arguments);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(11), 
		__webpack_require__(15), 
		__webpack_require__(2), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(9), 
		__webpack_require__(155),
		__webpack_require__(157),
		__webpack_require__(158),
		__webpack_require__(75),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, domConstruct, domStyle, kernel, lang, on, has,
				_FormValueWidget, _TextBoxMixin, template, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/TextBox", (function(){
	
		// module:
		//		dijit/form/TextBox
	
		var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {
			// summary:
			//		A base class for textbox form inputs
	
			templateString: template,
			_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',
	
			_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events
	
			baseClass: "dijitTextBox",
	
			postMixInProperties: function(){
				var type = this.type.toLowerCase();
				if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
					this.templateString = this._singleNodeTemplate;
				}
				this.inherited(arguments);
			},
	
			postCreate: function(){
				this.inherited(arguments);
	
				if(has("ie") < 9){
					// IE INPUT tag fontFamily has to be set directly using STYLE
					// the defer gives IE a chance to render the TextBox and to deal with font inheritance
					this.defer(function(){
						try{
							var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
							if(s){
								var ff = s.fontFamily;
								if(ff){
									var inputs = this.domNode.getElementsByTagName("INPUT");
									if(inputs){
										for(var i=0; i < inputs.length; i++){
											inputs[i].style.fontFamily = ff;
										}
									}
								}
							}
						}catch(e){/*when used in a Dialog, and this is called before the dialog is
						 shown, s.fontFamily would trigger "Invalid Argument" error.*/}
					});
				}
			},
	
			_setPlaceHolderAttr: function(v){
				this._set("placeHolder", v);
				if(!this._phspan){
					this._attachPoints.push('_phspan');
					this._phspan = domConstruct.create('span', {
						// dijitInputField class gives placeHolder same padding as the input field
						// parent node already has dijitInputField class but it doesn't affect this <span>
						// since it's position: absolute.
						className: 'dijitPlaceHolder dijitInputField'
					}, this.textbox, 'after');
					this.own(
						on(this._phspan, "mousedown", function(evt){ evt.preventDefault(); }),
						on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function(){
							// If the user clicks placeholder rather than the <input>, need programmatic focus.  Normally this
							// is done in _FormWidgetMixin._onFocus() but after [30663] it's done on a delay, which is ineffective.
							this.focus();
						}))
					);
				}
				this._phspan.innerHTML="";
				this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
				this._updatePlaceHolder();
			},
	
			_onInput: function(/*Event*/ evt){
				// summary:
				//		Called AFTER the input event has happened
				//		See if the placeHolder text should be removed or added while editing.
				this.inherited(arguments);
				this._updatePlaceHolder();
			},
	
			_updatePlaceHolder: function(){
				if(this._phspan){
					this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
				}
			},
	
			_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
				this.inherited(arguments);
				this._updatePlaceHolder();
			},
	
			getDisplayedValue: function(){
				// summary:
				//		Deprecated.  Use get('displayedValue') instead.
				// tags:
				//		deprecated
				kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
				return this.get('displayedValue');
			},
	
			setDisplayedValue: function(/*String*/ value){
				// summary:
				//		Deprecated.  Use set('displayedValue', ...) instead.
				// tags:
				//		deprecated
				kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
				this.set('displayedValue', value);
			},
	
			_onBlur: function(e){
				if(this.disabled){ return; }
				this.inherited(arguments);
				this._updatePlaceHolder();
	
				if(has("mozilla")){
					if(this.selectOnClick){
						// clear selection so that the next mouse click doesn't reselect
						this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
					}
				}
			},
	
			_onFocus: function(/*String*/ by){
				if(this.disabled || this.readOnly){ return; }
				this.inherited(arguments);
				this._updatePlaceHolder();
			}
		});
	
		if(has("ie") < 9){
			TextBox.prototype._isTextSelected = function(){
				var range = this.ownerDocument.selection.createRange();
				var parent = range.parentElement();
				return parent == this.textbox && range.text.length > 0;
			};
	
			// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
			dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
				if(element.createTextRange){
					var r = element.createTextRange();
					r.collapse(true);
					r.moveStart("character", -99999); // move to 0
					r.moveStart("character", start); // delta from 0 is the correct position
					r.moveEnd("character", stop-start);
					r.select();
				}
			}
		}
	
		if(has("dojo-bidi")){
			TextBox = declare("dijit.form.TextBox", TextBox, {
				_setPlaceHolderAttr: function(v){
					this.inherited(arguments);
					this.applyTextDir(this._phspan);
				}
			});
		}
	
		return TextBox;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(9), 
		__webpack_require__(115),
		__webpack_require__(156),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, has, _FormWidget, _FormValueMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_FormValueWidget", (function(){
	
		// module:
		//		dijit/form/_FormValueWidget
	
		return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {
			// summary:
			//		Base class for widgets corresponding to native HTML elements such as `<input>` or `<select>`
			//		that have user changeable values.
			// description:
			//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,
			//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
			//		works as expected.
	
			// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
			// directly in the template as read by the parser in order to function. IE is known to specifically
			// require the 'name' attribute at element creation time.  See #8484, #8660.
	
			_layoutHackIE7: function(){
				// summary:
				//		Work around table sizing bugs on IE7 by forcing redraw
	
				if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
					var domNode = this.domNode;
					var parent = domNode.parentNode;
					var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
					var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
					var _this = this;
					while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
						(function ping(){
							var disconnectHandle = _this.connect(parent, "onscroll",
								function(){
									_this.disconnect(disconnectHandle); // only call once
									pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
									_this.defer(function(){
										pingNode.style.filter = origFilter;
									}); // restore custom filter, if any
								}
							);
						})();
						parent = parent.parentNode;
					}
				}
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(14), 
		__webpack_require__(26), 
		__webpack_require__(8),
		__webpack_require__(18),
		__webpack_require__(117),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, domAttr, keys, lang, on, _FormWidgetMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_FormValueMixin", (function(){
	
		// module:
		//		dijit/form/_FormValueMixin
	
		return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
			// summary:
			//		Mixin for widgets corresponding to native HTML elements such as `<input>` or `<select>`
			//		that have user changeable values.
			// description:
			//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) `<input>` element,
			//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
			//		works as expected.
	
			// readOnly: Boolean
			//		Should this widget respond to user input?
			//		In markup, this is specified as "readOnly".
			//		Similar to disabled except readOnly form values are submitted.
			readOnly: false,
	
			_setReadOnlyAttr: function(/*Boolean*/ value){
				domAttr.set(this.focusNode, 'readOnly', value);
				this._set("readOnly", value);
			},
	
			postCreate: function(){
				this.inherited(arguments);
	
				// Update our reset value if it hasn't yet been set (because this.set()
				// is only called when there *is* a value)
				if(this._resetValue === undefined){
					this._lastValueReported = this._resetValue = this.value;
				}
			},
	
			_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
				// summary:
				//		Hook so set('value', value) works.
				// description:
				//		Sets the value of the widget.
				//		If the value has changed, then fire onChange event, unless priorityChange
				//		is specified as null (or false?)
				this._handleOnChange(newValue, priorityChange);
			},
	
			_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
				// summary:
				//		Called when the value of the widget has changed.  Saves the new value in this.value,
				//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
				this._set("value", newValue);
				this.inherited(arguments);
			},
	
			undo: function(){
				// summary:
				//		Restore the value to the last value passed to onChange
				this._setValueAttr(this._lastValueReported, false);
			},
	
			reset: function(){
				// summary:
				//		Reset the widget's value to what it was at initialization time
				this._hasBeenBlurred = false;
				this._setValueAttr(this._resetValue, true);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(9),	
		__webpack_require__(26), 
		__webpack_require__(8), 
		__webpack_require__(18), 
		__webpack_require__(75),__webpack_require__(6)    
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, dom, has, keys, lang, on, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_TextBoxMixin", (function(){
	
		// module:
		//		dijit/form/_TextBoxMixin
	
		var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
			// summary:
			//		A mixin for textbox form input widgets
	
			// trim: Boolean
			//		Removes leading and trailing whitespace if true.  Default is false.
			trim: false,
	
			// uppercase: Boolean
			//		Converts all characters to uppercase if true.  Default is false.
			uppercase: false,
	
			// lowercase: Boolean
			//		Converts all characters to lowercase if true.  Default is false.
			lowercase: false,
	
			// propercase: Boolean
			//		Converts the first character of each word to uppercase if true.
			propercase: false,
	
			// maxLength: String
			//		HTML INPUT tag maxLength declaration.
			maxLength: "",
	
			// selectOnClick: [const] Boolean
			//		If true, all text will be selected when focused with mouse
			selectOnClick: false,
	
			// placeHolder: String
			//		Defines a hint to help users fill out the input field (as defined in HTML 5).
			//		This should only contain plain text (no html markup).
			placeHolder: "",
	
			_getValueAttr: function(){
				// summary:
				//		Hook so get('value') works as we like.
				// description:
				//		For `dijit/form/TextBox` this basically returns the value of the `<input>`.
				//
				//		For `dijit/form/MappedTextBox` subclasses, which have both
				//		a "displayed value" and a separate "submit value",
				//		This treats the "displayed value" as the master value, computing the
				//		submit value from it via this.parse().
				return this.parse(this.get('displayedValue'), this.constraints);
			},
	
			_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
				// summary:
				//		Hook so set('value', ...) works.
				//
				// description:
				//		Sets the value of the widget to "value" which can be of
				//		any type as determined by the widget.
				//
				// value:
				//		The visual element value is also set to a corresponding,
				//		but not necessarily the same, value.
				//
				// formattedValue:
				//		If specified, used to set the visual element value,
				//		otherwise a computed visual value is used.
				//
				// priorityChange:
				//		If true, an onChange event is fired immediately instead of
				//		waiting for the next blur event.
	
				var filteredValue;
				if(value !== undefined){
					// TODO: this is calling filter() on both the display value and the actual value.
					// I added a comment to the filter() definition about this, but it should be changed.
					filteredValue = this.filter(value);
					if(typeof formattedValue != "string"){
						if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
							formattedValue = this.filter(this.format(filteredValue, this.constraints));
						}else{
							formattedValue = '';
						}
						// Ensure the filtered value does not change after being formatted. See track #17955.
						//
						// This check is only applied when the formatted value is not specified by the caller in order to allow the 
						// behavior to be overriden. This is needed whenever value synonyms cannot be determined using parse/compare. For
						// example, dijit/form/FilteringSelect determines the formatted value asynchronously and applies it using a 
						// callback to this method.
						//
						// TODO: Should developers be warned that they broke the round trip on format?
						if (this.compare(filteredValue, this.filter(this.parse(formattedValue, this.constraints))) != 0){
							formattedValue = null;
						}
					}
				}
				if(formattedValue != null /* and !undefined */ && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
					this.textbox.value = formattedValue;
					this._set("displayedValue", this.get("displayedValue"));
				}
	
				this.inherited(arguments, [filteredValue, priorityChange]);
			},
	
			// displayedValue: String
			//		For subclasses like ComboBox where the displayed value
			//		(ex: Kentucky) and the serialized value (ex: KY) are different,
			//		this represents the displayed value.
			//
			//		Setting 'displayedValue' through set('displayedValue', ...)
			//		updates 'value', and vice-versa.  Otherwise 'value' is updated
			//		from 'displayedValue' periodically, like onBlur etc.
			//
			//		TODO: move declaration to MappedTextBox?
			//		Problem is that ComboBox references displayedValue,
			//		for benefit of FilteringSelect.
			displayedValue: "",
	
			_getDisplayedValueAttr: function(){
				// summary:
				//		Hook so get('displayedValue') works.
				// description:
				//		Returns the displayed value (what the user sees on the screen),
				//		after filtering (ie, trimming spaces etc.).
				//
				//		For some subclasses of TextBox (like ComboBox), the displayed value
				//		is different from the serialized value that's actually
				//		sent to the server (see `dijit/form/ValidationTextBox.serialize()`)
	
				// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
				// this method
				// TODO: this isn't really the displayed value when the user is typing
				return this.filter(this.textbox.value);
			},
	
			_setDisplayedValueAttr: function(/*String*/ value){
				// summary:
				//		Hook so set('displayedValue', ...) works.
				// description:
				//		Sets the value of the visual element to the string "value".
				//		The widget value is also set to a corresponding,
				//		but not necessarily the same, value.
	
				if(value == null /* or undefined */){
					value = ''
				}
				else if(typeof value != "string"){
					value = String(value)
				}
	
				this.textbox.value = value;
	
				// sets the serialized value to something corresponding to specified displayedValue
				// (if possible), and also updates the textbox.value, for example converting "123"
				// to "123.00"
				this._setValueAttr(this.get('value'), undefined);
	
				this._set("displayedValue", this.get('displayedValue'));
			},
	
			format: function(value /*=====, constraints =====*/){
				// summary:
				//		Replaceable function to convert a value to a properly formatted string.
				// value: String
				// constraints: Object
				// tags:
				//		protected extension
				return value == null /* or undefined */ ? "" : (value.toString ? value.toString() : value);
			},
	
			parse: function(value /*=====, constraints =====*/){
				// summary:
				//		Replaceable function to convert a formatted string to a value
				// value: String
				// constraints: Object
				// tags:
				//		protected extension
	
				return value;	// String
			},
	
			_refreshState: function(){
				// summary:
				//		After the user types some characters, etc., this method is
				//		called to check the field for validity etc.  The base method
				//		in `dijit/form/TextBox` does nothing, but subclasses override.
				// tags:
				//		protected
			},
	
			 onInput: function(/*Event*/ /*===== evt =====*/){
				 // summary:
				 //		Connect to this function to receive notifications of various user data-input events.
				 //		Return false to cancel the event and prevent it from being processed.
				 //		Note that although for historical reasons this method is called `onInput()`, it doesn't
				 //		correspond to the standard DOM "input" event, because it occurs before the input has been processed.
				 // event:
				 //		keydown | keypress | cut | paste | compositionend
				 // tags:
				 //		callback
			 },
	
			_onInput: function(/*Event*/ evt){
				// summary:
				//		Called AFTER the input event has happened and this.textbox.value has new value.
	
				this._lastInputEventValue = this.textbox.value;
	
				// For Combobox, this needs to be called w/the keydown/keypress event that was passed to onInput().
				// As a backup, use the "input" event itself.
				this._processInput(this._lastInputProducingEvent || evt);
				delete this._lastInputProducingEvent;
	
				if(this.intermediateChanges){
					this._handleOnChange(this.get('value'), false);
				}
			},
	
			_processInput: function(/*Event*/ /*===== evt =====*/){
				// summary:
				//		Default action handler for user input events.
				//		Called after the "input" event (i.e. after this.textbox.value has been updated),
				//		but `evt` is the keydown/keypress/etc. event that triggered the "input" event.
				// tags:
				//		protected
	
				this._refreshState();
	
				// In case someone is watch()'ing for changes to displayedValue
				this._set("displayedValue", this.get("displayedValue"));
			},
	
			postCreate: function(){
				// setting the value here is needed since value="" in the template causes "undefined"
				// and setting in the DOM (instead of the JS object) helps with form reset actions
				this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same
	
				this.inherited(arguments);
	
				// normalize input events to reduce spurious event processing
				//	keydown: do not forward modifier keys
				//		       set charOrCode to numeric keycode
				//	keypress: do not forward numeric charOrCode keys (already sent through onkeydown)
				//	paste, cut, compositionend: set charOrCode to 229 (IME)
				function handleEvent(e){
					var charOrCode;
	
					// Filter out keydown events that will be followed by keypress events.  Note that chrome/android
					// w/word suggestion has keydown/229 events on typing with no corresponding keypress events.
					if(e.type == "keydown" && e.keyCode != 229){
						charOrCode = e.keyCode;
						switch(charOrCode){ // ignore state keys
							case keys.SHIFT:
							case keys.ALT:
							case keys.CTRL:
							case keys.META:
							case keys.CAPS_LOCK:
							case keys.NUM_LOCK:
							case keys.SCROLL_LOCK:
								return;
						}
						if(!e.ctrlKey && !e.metaKey && !e.altKey){ // no modifiers
							switch(charOrCode){ // ignore location keys
								case keys.NUMPAD_0:
								case keys.NUMPAD_1:
								case keys.NUMPAD_2:
								case keys.NUMPAD_3:
								case keys.NUMPAD_4:
								case keys.NUMPAD_5:
								case keys.NUMPAD_6:
								case keys.NUMPAD_7:
								case keys.NUMPAD_8:
								case keys.NUMPAD_9:
								case keys.NUMPAD_MULTIPLY:
								case keys.NUMPAD_PLUS:
								case keys.NUMPAD_ENTER:
								case keys.NUMPAD_MINUS:
								case keys.NUMPAD_PERIOD:
								case keys.NUMPAD_DIVIDE:
									return;
							}
							if((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE){
								return; // keypress will handle simple non-modified printable keys
							}
							var named = false;
							for(var i in keys){
								if(keys[i] === e.keyCode){
									named = true;
									break;
								}
							}
							if(!named){
								return;
							} // only allow named ones through
						}
					}
	
					charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
					if(!charOrCode){
						charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
					}
					if(!charOrCode){
						charOrCode = 229; // IME
					}
					if(e.type == "keypress"){
						if(typeof charOrCode != "string"){
							return;
						}
						if((charOrCode >= 'a' && charOrCode <= 'z') || (charOrCode >= 'A' && charOrCode <= 'Z') || (charOrCode >= '0' && charOrCode <= '9') || (charOrCode === ' ')){
							if(e.ctrlKey || e.metaKey || e.altKey){
								return;
							} // can only be stopped reliably in keydown
						}
					}
	
					// create fake event to set charOrCode and to know if preventDefault() was called
					var faux = { faux: true }, attr;
					for(attr in e){
						if(!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)){ // prevent WebKit warnings
							var v = e[attr];
							if(typeof v != "function" && typeof v != "undefined"){
								faux[attr] = v;
							}
						}
					}
					lang.mixin(faux, {
						charOrCode: charOrCode,
						_wasConsumed: false,
						preventDefault: function(){
							faux._wasConsumed = true;
							e.preventDefault();
						},
						stopPropagation: function(){
							e.stopPropagation();
						}
					});
	
					this._lastInputProducingEvent = faux;
	
					// Give web page author a chance to consume the event.  Note that onInput() may be called multiple times
					// for same keystroke: once for keypress event and once for input event.
					//console.log(faux.type + ', charOrCode = (' + (typeof charOrCode) + ') ' + charOrCode + ', ctrl ' + !!faux.ctrlKey + ', alt ' + !!faux.altKey + ', meta ' + !!faux.metaKey + ', shift ' + !!faux.shiftKey);
					if(this.onInput(faux) === false){ // return false means stop
						faux.preventDefault();
						faux.stopPropagation();
					}
					if(faux._wasConsumed){
						return;
					} // if preventDefault was called
	
					// IE8 doesn't emit the "input" event at all, and IE9 doesn't emit it for backspace, delete, cut, etc.
					// Since the code below (and perhaps user code) depends on that event, emit it synthetically.
					// See http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html.
					if(has("ie") <= 9){
						switch(e.keyCode){
						case keys.TAB:
						case keys.ESCAPE:
						case keys.DOWN_ARROW:
						case keys.UP_ARROW:
						case keys.LEFT_ARROW:
						case keys.RIGHT_ARROW:
							// These keys may alter the <input>'s value indirectly, but we don't want to emit an "input"
							// event.  For example, the up/down arrows in TimeTextBox or ComboBox will cause the next
							// dropdown item's value to be copied to the <input>.
							break;
						default:
							if(e.keyCode == keys.ENTER && this.textbox.tagName.toLowerCase() != "textarea"){
								break;
							}
							this.defer(function(){
								if(this.textbox.value !== this._lastInputEventValue){
									on.emit(this.textbox, "input", {bubbles: true});
								}
							});
						}
					}
				}
				this.own(
					on(this.textbox, "keydown, keypress, paste, cut, compositionend", lang.hitch(this, handleEvent)),
					on(this.textbox, "input", lang.hitch(this, "_onInput")),
	
					// Allow keypress to bubble to this.domNode, so that TextBox.on("keypress", ...) works,
					// but prevent it from further propagating, so that typing into a TextBox inside a Toolbar doesn't
					// trigger the Toolbar's letter key navigation.
					on(this.domNode, "keypress", function(e){ e.stopPropagation(); })
				);
			},
	
			_blankValue: '', // if the textbox is blank, what value should be reported
			filter: function(val){
				// summary:
				//		Auto-corrections (such as trimming) that are applied to textbox
				//		value on blur or form submit.
				// description:
				//		For MappedTextBox subclasses, this is called twice
				//
				//		- once with the display value
				//		- once the value as set/returned by set('value', ...)
				//
				//		and get('value'), ex: a Number for NumberTextBox.
				//
				//		In the latter case it does corrections like converting null to NaN.  In
				//		the former case the NumberTextBox.filter() method calls this.inherited()
				//		to execute standard trimming code in TextBox.filter().
				//
				//		TODO: break this into two methods in 2.0
				//
				// tags:
				//		protected extension
				if(val === null){
					return this._blankValue;
				}
				if(typeof val != "string"){
					return val;
				}
				if(this.trim){
					val = lang.trim(val);
				}
				if(this.uppercase){
					val = val.toUpperCase();
				}
				if(this.lowercase){
					val = val.toLowerCase();
				}
				if(this.propercase){
					val = val.replace(/[^\s]+/g, function(word){
						return word.substring(0, 1).toUpperCase() + word.substring(1);
					});
				}
				return val;
			},
	
			_setBlurValue: function(){
				// Format the displayed value, for example (for NumberTextBox) convert 1.4 to 1.400,
				// or (for CurrencyTextBox) 2.50 to $2.50
	
				this._setValueAttr(this.get('value'), true);
			},
	
			_onBlur: function(e){
				if(this.disabled){
					return;
				}
				this._setBlurValue();
				this.inherited(arguments);
			},
	
			_isTextSelected: function(){
				return this.textbox.selectionStart != this.textbox.selectionEnd;
			},
	
			_onFocus: function(/*String*/ by){
				if(this.disabled || this.readOnly){
					return;
				}
	
				// Select all text on focus via click if nothing already selected.
				// Since mouse-up will clear the selection, need to defer selection until after mouse-up.
				// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
				if(this.selectOnClick && by == "mouse"){
					// Use on.once() to only select all text on first click only; otherwise users would have no way to clear
					// the selection.
					this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function(evt){
						// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
						// and if not, then select all the text
						if(!this._isTextSelected()){
							_TextBoxMixin.selectInputText(this.textbox);
						}
					}));
					this.own(this._selectOnClickHandle);
	
					// in case the mouseup never comes
					this.defer(function(){
						if(this._selectOnClickHandle){
							this._selectOnClickHandle.remove();
							this._selectOnClickHandle = null;
						}
					}, 500); // if mouseup not received soon, then treat it as some gesture
				}
				// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
				// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
				this.inherited(arguments);
	
				this._refreshState();
			},
	
			reset: function(){
				// Overrides `dijit/_FormWidget/reset()`.
				// Additionally resets the displayed textbox value to ''
				this.textbox.value = '';
				this.inherited(arguments);
			}
		});
	
		if(has("dojo-bidi")){
			_TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {
				_setValueAttr: function(){
					this.inherited(arguments);
					this.applyTextDir(this.focusNode);
				},
				_setDisplayedValueAttr: function(){
					this.inherited(arguments);
					this.applyTextDir(this.focusNode);
				},
				_onInput: function(){
					this.applyTextDir(this.focusNode);
					this.inherited(arguments);
				}
			});
		}
	
		_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.setSelectionRange){
				element.setSelectionRange(start, stop);
			}
		};
	
		_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			// summary:
			//		Select text in the input element argument, from start (default 0), to stop (default end).
	
			// TODO: use functions in _editor/selection.js?
			element = dom.byId(element);
			if(isNaN(start)){
				start = 0;
			}
			if(isNaN(stop)){
				stop = element.value ? element.value.length : 0;
			}
			try{
				element.focus();
				_TextBoxMixin._setSelectionRange(element, start, stop);
			}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */
			}
		};
	
		return _TextBoxMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = "<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${!nameAttrSetting} type='${type}'\r\n\t/></div\r\n></div>\r\n"

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(160),
		__webpack_require__(172),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Calendar, _DateTimeTextBox,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/DateTextBox", (function(){
	
		// module:
		//		dijit/form/DateTextBox
	
		return declare("dijit.form.DateTextBox", _DateTimeTextBox, {
			// summary:
			//		A validating, serializable, range-bound date text box with a drop down calendar
			// example:
			// |	new DateTextBox({value: new Date(2009, 0, 20)})
			// example:
			// |	<input data-dojo-type='dijit/form/DateTextBox' value='2009-01-20'>
	
			baseClass: "dijitTextBox dijitComboBox dijitDateTextBox",
			popupClass: Calendar,
			_selector: "date",
	
			// Prevent scrollbar on Calendar dropdown.  On iPad it often gets a scrollbar unnecessarily because Viewport
			// thinks the keyboard is showing.  Even if the keyboard is showing, it disappears when the calendar gets focus.
			maxHeight: Infinity,
	
			// value: Date
			//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
			//		If specified in markup, use the format specified in `stamp.fromISOString`.
			//		set("value", ...) accepts either a Date object or a string.
			value: new Date("")	// value.toString()="NaN"
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(162),
		__webpack_require__(161),
		__webpack_require__(1), 
		__webpack_require__(14), 
		__webpack_require__(27), 
		__webpack_require__(11),	
		__webpack_require__(2), 
		__webpack_require__(26), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(9), 
		__webpack_require__(168),
		__webpack_require__(96),
		__webpack_require__(116),
		__webpack_require__(76),
		__webpack_require__(170),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, date, local, declare, domAttr, domClass, domConstruct, kernel, keys, lang, on, has,
				CalendarLite, _Widget, _CssStateMixin, _TemplatedMixin, DropDownButton,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/Calendar", (function(){
	
		// module:
		//		dijit/Calendar
	
		// _Widget for deprecated methods like setAttribute()
		var Calendar = declare("dijit.Calendar", [CalendarLite, _Widget, _CssStateMixin], {
			// summary:
			//		A simple GUI for choosing a date in the context of a monthly calendar.
			//
			// description:
			//		See CalendarLite for general description.   Calendar extends CalendarLite, adding:
			//
			//		- month drop down list
			//		- keyboard navigation
			//		- CSS classes for hover/mousepress on date, month, and year nodes
			//		- support of deprecated methods (will be removed in 2.0)
	
			baseClass: "dijitCalendar",
	
			// Set node classes for various mouse events, see dijit._CssStateMixin for more details
			cssStateNodes: {
				"decrementMonth": "dijitCalendarArrow",
				"incrementMonth": "dijitCalendarArrow",
				"previousYearLabelNode": "dijitCalendarPreviousYear",
				"nextYearLabelNode": "dijitCalendarNextYear"
			},
	
			setValue: function(/*Date*/ value){
				// summary:
				//		Deprecated.   Use set('value', ...) instead.
				// tags:
				//		deprecated
				kernel.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
				this.set('value', value);
			},
	
			_createMonthWidget: function(){
				// summary:
				//		Creates the drop down button that displays the current month and lets user pick a new one
	
				return new Calendar._MonthDropDownButton({
					id: this.id + "_mddb",
					tabIndex: -1,
					onMonthSelect: lang.hitch(this, "_onMonthSelect"),
					lang: this.lang,
					dateLocaleModule: this.dateLocaleModule
				}, this.monthNode);
			},
	
			postCreate: function(){
				this.inherited(arguments);
	
				// Events specific to Calendar, not used in CalendarLite
				this.own(
					on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")),
					on(this.dateRowsNode, "mouseover", lang.hitch(this, "_onDayMouseOver")),
					on(this.dateRowsNode, "mouseout", lang.hitch(this, "_onDayMouseOut")),
					on(this.dateRowsNode, "mousedown", lang.hitch(this, "_onDayMouseDown")),
					on(this.dateRowsNode, "mouseup", lang.hitch(this, "_onDayMouseUp"))
				);
			},
	
			_onMonthSelect: function(/*Number*/ newMonth){
				// summary:
				//		Handler for when user selects a month from the drop down list
				// tags:
				//		protected
	
				// move to selected month, bounding by the number of days in the month
				// (ex: jan 31 --> feb 28, not feb 31)
				var date = new this.dateClassObj(this.currentFocus);
				date.setDate(1);
				date.setMonth(newMonth);
				var daysInMonth = this.dateModule.getDaysInMonth(date);
				var currentDate = this.currentFocus.getDate();
				date.setDate(Math.min(currentDate, daysInMonth));
				this._setCurrentFocusAttr(date);
			},
	
			_onDayMouseOver: function(/*Event*/ evt){
				// summary:
				//		Handler for mouse over events on days, sets hovered style
				// tags:
				//		protected
	
				// event can occur on <td> or the <span> inside the td,
				// set node to the <td>.
				var node =
					domClass.contains(evt.target, "dijitCalendarDateLabel") ?
						evt.target.parentNode :
						evt.target;
	
				if(node && (
					(node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate"))
						|| node == this.previousYearLabelNode || node == this.nextYearLabelNode
					)){
					domClass.add(node, "dijitCalendarHoveredDate");
					this._currentNode = node;
				}
			},
	
			_onDayMouseOut: function(/*Event*/ evt){
				// summary:
				//		Handler for mouse out events on days, clears hovered style
				// tags:
				//		protected
	
				if(!this._currentNode){
					return;
				}
	
				// if mouse out occurs moving from <td> to <span> inside <td>, ignore it
				if(evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode){
					return;
				}
				var cls = "dijitCalendarHoveredDate";
				if(domClass.contains(this._currentNode, "dijitCalendarActiveDate")){
					cls += " dijitCalendarActiveDate";
				}
				domClass.remove(this._currentNode, cls);
				this._currentNode = null;
			},
	
			_onDayMouseDown: function(/*Event*/ evt){
				var node = evt.target.parentNode;
				if(node && node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate")){
					domClass.add(node, "dijitCalendarActiveDate");
					this._currentNode = node;
				}
			},
	
			_onDayMouseUp: function(/*Event*/ evt){
				var node = evt.target.parentNode;
				if(node && node.dijitDateValue){
					domClass.remove(node, "dijitCalendarActiveDate");
				}
			},
	
			handleKey: function(/*Event*/ evt){
				// summary:
				//		Provides keyboard navigation of calendar.
				// description:
				//		Called from _onKeyDown() to handle keydown on a stand alone Calendar,
				//		and also from `dijit/form/_DateTimeTextBox` to pass a keydown event
				//		from the `dijit/form/DateTextBox` to be handled in this widget
				// returns:
				//		False if the key was recognized as a navigation key,
				//		to indicate that the event was handled by Calendar and shouldn't be propagated
				// tags:
				//		protected
				var increment = -1,
					interval,
					newValue = this.currentFocus;
				switch(evt.keyCode){
					case keys.RIGHT_ARROW:
						increment = 1;
					//fallthrough...
					case keys.LEFT_ARROW:
						interval = "day";
						if(!this.isLeftToRight()){
							increment *= -1;
						}
						break;
					case keys.DOWN_ARROW:
						increment = 1;
					//fallthrough...
					case keys.UP_ARROW:
						interval = "week";
						break;
					case keys.PAGE_DOWN:
						increment = 1;
					//fallthrough...
					case keys.PAGE_UP:
						interval = evt.ctrlKey || evt.altKey ? "year" : "month";
						break;
					case keys.END:
						// go to the next month
						newValue = this.dateModule.add(newValue, "month", 1);
						// subtract a day from the result when we're done
						interval = "day";
					//fallthrough...
					case keys.HOME:
						newValue = new this.dateClassObj(newValue);
						newValue.setDate(1);
						break;
					default:
						return true;
				}
	
				if(interval){
					newValue = this.dateModule.add(newValue, interval, increment);
				}
	
				this._setCurrentFocusAttr(newValue);
	
				return false;
			},
	
			_onKeyDown: function(/*Event*/ evt){
				// summary:
				//		For handling keydown events on a stand alone calendar
				if(!this.handleKey(evt)){
					evt.stopPropagation();
					evt.preventDefault();
				}
			},
	
			onValueSelected: function(/*Date*/ /*===== date =====*/){
				// summary:
				//		Deprecated.   Notification that a date cell was selected.  It may be the same as the previous value.
				// description:
				//		Formerly used by `dijit/form/_DateTimeTextBox` (and thus `dijit/form/DateTextBox`)
				//		to get notification when the user has clicked a date.  Now onExecute() (above) is used.
				// tags:
				//		protected
			},
	
			onChange: function(value){
				this.onValueSelected(value);	// remove in 2.0
			},
	
			getClassForDate: function(/*===== dateObject, locale =====*/){
				// summary:
				//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
				//		for example to indicate a holiday in specified locale.
				// dateObject: Date
				// locale: String?
				// tags:
				//		extension
	
				/*=====
				 return ""; // String
				 =====*/
			}
		});
	
		Calendar._MonthDropDownButton = declare("dijit.Calendar._MonthDropDownButton", DropDownButton, {
			// summary:
			//		DropDownButton for the current month.    Displays name of current month
			//		and a list of month names in the drop down
	
			onMonthSelect: function(){
			},
	
			postCreate: function(){
				this.inherited(arguments);
				this.dropDown = new Calendar._MonthDropDown({
					id: this.id + "_mdd", //do not change this id because it is referenced in the template
					onChange: this.onMonthSelect
				});
			},
			_setMonthAttr: function(month){
				// summary:
				//		Set the current month to display as a label
				var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month);
				this.dropDown.set("months", monthNames);
	
				// Set name of current month and also fill in spacer element with all the month names
				// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
				// the center <TH> overlaps the right <TH> (due to a browser bug).
				this.containerNode.innerHTML =
					(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" + this.dropDown.domNode.innerHTML + "</div>") +
						"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" + monthNames[month.getMonth()] + "</div>";
			}
		});
	
		Calendar._MonthDropDown = declare("dijit.Calendar._MonthDropDown", [_Widget, _TemplatedMixin, _CssStateMixin], {
			// summary:
			//		The list-of-months drop down from the MonthDropDownButton
	
			// months: String[]
			//		List of names of months, possibly w/some undefined entries for Hebrew leap months
			//		(ex: ["January", "February", undefined, "April", ...])
			months: [],
	
			baseClass: "dijitCalendarMonthMenu dijitMenu",
	
			templateString: "<div data-dojo-attach-event='ondijitclick:_onClick'></div>",
	
			_setMonthsAttr: function(/*String[]*/ months){
				this.domNode.innerHTML = "";
				array.forEach(months, function(month, idx){
					var div = domConstruct.create("div", {
						className: "dijitCalendarMonthLabel",
						month: idx,
						innerHTML: month
					}, this.domNode);
					div._cssState = "dijitCalendarMonthLabel";	// trigger _CSSStateMixin magic; property, not attribute.
				}, this);
			},
	
			_onClick: function(/*Event*/ evt){
				this.onChange(domAttr.get(evt.target, "month"));
			},
	
			onChange: function(/*Number*/ /*===== month =====*/){
				// summary:
				//		Callback when month is selected from drop down
			}
		});
	
		return Calendar;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(8),
		__webpack_require__(28),
		__webpack_require__(162),
		
		__webpack_require__(163),
		__webpack_require__(121),
		__webpack_require__(95),
		__webpack_require__(79),
		__webpack_require__(164),
		module
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, array, date, /*===== declare, =====*/ supplemental, i18n, regexp, string, gregorian, module){module={id:"dojo/date/locale"}
	
	// module:
	//		dojo/date/locale
	
	var exports = {
		// summary:
		//		This modules defines dojo/date/locale, localization methods for Date.
	};
	lang.setObject(module.id.replace(/\//g, "."), exports);
	
	// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.
	
	// Load the bundles containing localization information for
	// names and formats
	
	//NOTE: Everything in this module assumes Gregorian calendars.
	// Other calendars will be implemented in separate modules.
	
		// Format a pattern without literals
		function formatPattern(dateObject, bundle, options, pattern){
			return pattern.replace(/([a-z])\1*/ig, function(match){
				var s, pad,
					c = match.charAt(0),
					l = match.length,
					widthList = ["abbr", "wide", "narrow"];
				switch(c){
					case 'G':
						s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
						break;
					case 'y':
						s = dateObject.getFullYear();
						switch(l){
							case 1:
								break;
							case 2:
								if(!options.fullYear){
									s = String(s); s = s.substr(s.length - 2);
									break;
								}
								// fallthrough
							default:
								pad = true;
						}
						break;
					case 'Q':
					case 'q':
						s = Math.ceil((dateObject.getMonth()+1)/3);
	//					switch(l){
	//						case 1: case 2:
								pad = true;
	//							break;
	//						case 3: case 4: // unimplemented
	//					}
						break;
					case 'M':
					case 'L':
						var m = dateObject.getMonth();
						if(l<3){
							s = m+1; pad = true;
						}else{
							var propM = [
								"months",
								c == 'L' ? "standAlone" : "format",
								widthList[l-3]
							].join("-");
							s = bundle[propM][m];
						}
						break;
					case 'w':
						var firstDay = 0;
						s = exports._getWeekOfYear(dateObject, firstDay); pad = true;
						break;
					case 'd':
						s = dateObject.getDate(); pad = true;
						break;
					case 'D':
						s = exports._getDayOfYear(dateObject); pad = true;
						break;
					case 'e':
					case 'c':
						var d = dateObject.getDay();
						if(l<2){
							s = (d - supplemental.getFirstDayOfWeek(options.locale) + 8) % 7
							break;
						}
						// fallthrough
					case 'E':
						d = dateObject.getDay();
						if(l<3){
							s = d+1; pad = true;
						}else{
							var propD = [
								"days",
								c == 'c' ? "standAlone" : "format",
								widthList[l-3]
							].join("-");
							s = bundle[propD][d];
						}
						break;
					case 'a':
						var timePeriod = dateObject.getHours() < 12 ? 'am' : 'pm';
						s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
						break;
					case 'h':
					case 'H':
					case 'K':
					case 'k':
						var h = dateObject.getHours();
						// strange choices in the date format make it impossible to write this succinctly
						switch (c){
							case 'h': // 1-12
								s = (h % 12) || 12;
								break;
							case 'H': // 0-23
								s = h;
								break;
							case 'K': // 0-11
								s = (h % 12);
								break;
							case 'k': // 1-24
								s = h || 24;
								break;
						}
						pad = true;
						break;
					case 'm':
						s = dateObject.getMinutes(); pad = true;
						break;
					case 's':
						s = dateObject.getSeconds(); pad = true;
						break;
					case 'S':
						s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
						break;
					case 'v': // FIXME: don't know what this is. seems to be same as z?
					case 'z':
						// We only have one timezone to offer; the one from the browser
						s = exports._getZone(dateObject, true, options);
						if(s){break;}
						l=4;
						// fallthrough... use GMT if tz not available
					case 'Z':
						var offset = exports._getZone(dateObject, false, options);
						var tz = [
							(offset<=0 ? "+" : "-"),
							string.pad(Math.floor(Math.abs(offset)/60), 2),
							string.pad(Math.abs(offset)% 60, 2)
						];
						if(l==4){
							tz.splice(0, 0, "GMT");
							tz.splice(3, 0, ":");
						}
						s = tz.join("");
						break;
	//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A':
	//					console.log(match+" modifier unimplemented");
					default:
						throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
				}
				if(pad){ s = string.pad(s, l); }
				return s;
			});
		}
	
	/*=====
	var __FormatOptions = exports.__FormatOptions = declare(null, {
		// selector: String
		//		choice of 'time','date' (default: date and time)
		// formatLength: String
		//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
		// datePattern:String
		//		override pattern with this string
		// timePattern:String
		//		override pattern with this string
		// am: String
		//		override strings for am in times
		// pm: String
		//		override strings for pm in times
		// locale: String
		//		override the locale used to determine formatting rules
		// fullYear: Boolean
		//		(format only) use 4 digit years whenever 2 digit years are called for
		// strict: Boolean
		//		(parse only) strict parsing, off by default
	});
	=====*/
	
	exports._getZone = function(/*Date*/ dateObject, /*boolean*/ getName, /*__FormatOptions?*/ options){
		// summary:
		//		Returns the zone (or offset) for the given date and options.  This
		//		is broken out into a separate function so that it can be overridden
		//		by timezone-aware code.
		//
		// dateObject:
		//		the date and/or time being formatted.
		//
		// getName:
		//		Whether to return the timezone string (if true), or the offset (if false)
		//
		// options:
		//		The options being used for formatting
		if(getName){
			return date.getTimezoneName(dateObject);
		}else{
			return dateObject.getTimezoneOffset();
		}
	};
	
	
	exports.format = function(/*Date*/ dateObject, /*__FormatOptions?*/ options){
		// summary:
		//		Format a Date object as a String, using locale-specific settings.
		//
		// description:
		//		Create a string from a Date object using a known localized pattern.
		//		By default, this method formats both date and time from dateObject.
		//		Formatting patterns are chosen appropriate to the locale.  Different
		//		formatting lengths may be chosen, with "full" used by default.
		//		Custom patterns may be used or registered with translations using
		//		the dojo/date/locale.addCustomFormats() method.
		//		Formatting patterns are implemented using [the syntax described at
		//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
		//
		// dateObject:
		//		the date and/or time to be formatted.  If a time only is formatted,
		//		the values in the year, month, and day fields are irrelevant.  The
		//		opposite is true when formatting only dates.
	
		options = options || {};
	
		var locale = i18n.normalizeLocale(options.locale),
			formatLength = options.formatLength || 'short',
			bundle = exports._getGregorianBundle(locale),
			str = [],
			sauce = lang.hitch(this, formatPattern, dateObject, bundle, options);
		if(options.selector == "year"){
			return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
		}
		var pattern;
		if(options.selector != "date"){
			pattern = options.timePattern || bundle["timeFormat-"+formatLength];
			if(pattern){str.push(_processPattern(pattern, sauce));}
		}
		if(options.selector != "time"){
			pattern = options.datePattern || bundle["dateFormat-"+formatLength];
			if(pattern){str.push(_processPattern(pattern, sauce));}
		}
	
		return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\'/g,'').replace(/\{(\d+)\}/g,
			function(match, key){ return str[key]; }); // String
	};
	
	exports.regexp = function(/*__FormatOptions?*/ options){
		// summary:
		//		Builds the regular needed to parse a localized date
	
		return exports._parseInfo(options).regexp; // String
	};
	
	exports._parseInfo = function(/*__FormatOptions?*/ options){
		options = options || {};
		var locale = i18n.normalizeLocale(options.locale),
			bundle = exports._getGregorianBundle(locale),
			formatLength = options.formatLength || 'short',
			datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
			timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
			pattern;
		if(options.selector == 'date'){
			pattern = datePattern;
		}else if(options.selector == 'time'){
			pattern = timePattern;
		}else{
			pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
				function(match, key){ return [timePattern, datePattern][key]; });
		}
	
		var tokens = [],
			re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));
		return {regexp: re, tokens: tokens, bundle: bundle};
	};
	
	exports.parse = function(/*String*/ value, /*__FormatOptions?*/ options){
		// summary:
		//		Convert a properly formatted string to a primitive Date object,
		//		using locale-specific settings.
		//
		// description:
		//		Create a Date object from a string using a known localized pattern.
		//		By default, this method parses looking for both date and time in the string.
		//		Formatting patterns are chosen appropriate to the locale.  Different
		//		formatting lengths may be chosen, with "full" used by default.
		//		Custom patterns may be used or registered with translations using
		//		the dojo/date/locale.addCustomFormats() method.
		//
		//		Formatting patterns are implemented using [the syntax described at
		//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
		//		When two digit years are used, a century is chosen according to a sliding
		//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
		//		year < 100CE requires strict mode.
		//
		// value:
		//		A string representation of a date
	
		// remove non-printing bidi control chars from input and pattern
		var controlChars = /[\u200E\u200F\u202A\u202E]/g,
			info = exports._parseInfo(options),
			tokens = info.tokens, bundle = info.bundle,
			re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
				info.strict ? "" : "i"),
			match = re.exec(value && value.replace(controlChars, ""));
	
		if(!match){ return null; } // null
	
		var widthList = ['abbr', 'wide', 'narrow'],
			result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
			amPm = "",
			valid = array.every(match, function(v, i){
			if(!i){return true;}
			var token = tokens[i-1],
				l = token.length,
				c = token.charAt(0);
			switch(c){
				case 'y':
					if(l != 2 && options.strict){
						//interpret year literally, so '5' would be 5 A.D.
						result[0] = v;
					}else{
						if(v<100){
							v = Number(v);
							//choose century to apply, according to a sliding window
							//of 80 years before and 20 years after present year
							var year = '' + new Date().getFullYear(),
								century = year.substring(0, 2) * 100,
								cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
							result[0] = (v < cutoff) ? century + v : century - 100 + v;
						}else{
							//we expected 2 digits and got more...
							if(options.strict){
								return false;
							}
							//interpret literally, so '150' would be 150 A.D.
							//also tolerate '1950', if 'yyyy' input passed to 'yy' format
							result[0] = v;
						}
					}
					break;
				case 'M':
				case 'L':
					if(l>2){
						var months = bundle['months-' +
								    (c == 'L' ? 'standAlone' : 'format') +
								    '-' + widthList[l-3]].concat();
						if(!options.strict){
							//Tolerate abbreviating period in month part
							//Case-insensitive comparison
							v = v.replace(".","").toLowerCase();
							months = array.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
						}
						v = array.indexOf(months, v);
						if(v == -1){
	//						console.log("dojo/date/locale.parse: Could not parse month name: '" + v + "'.");
							return false;
						}
					}else{
						v--;
					}
					result[1] = v;
					break;
				case 'E':
				case 'e':
				case 'c':
					var days = bundle['days-' +
							  (c == 'c' ? 'standAlone' : 'format') +
							  '-' + widthList[l-3]].concat();
					if(!options.strict){
						//Case-insensitive comparison
						v = v.toLowerCase();
						days = array.map(days, function(d){return d.toLowerCase();});
					}
					v = array.indexOf(days, v);
					if(v == -1){
	//					console.log("dojo/date/locale.parse: Could not parse weekday name: '" + v + "'.");
						return false;
					}
	
					//TODO: not sure what to actually do with this input,
					//in terms of setting something on the Date obj...?
					//without more context, can't affect the actual date
					//TODO: just validate?
					break;
				case 'D':
					result[1] = 0;
					// fallthrough...
				case 'd':
					result[2] = v;
					break;
				case 'a': //am/pm
					var am = options.am || bundle['dayPeriods-format-wide-am'],
						pm = options.pm || bundle['dayPeriods-format-wide-pm'];
					if(!options.strict){
						var period = /\./g;
						v = v.replace(period,'').toLowerCase();
						am = am.replace(period,'').toLowerCase();
						pm = pm.replace(period,'').toLowerCase();
					}
					if(options.strict && v != am && v != pm){
	//					console.log("dojo/date/locale.parse: Could not parse am/pm part.");
						return false;
					}
	
					// we might not have seen the hours field yet, so store the state and apply hour change later
					amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
					break;
				case 'K': //hour (1-24)
					if(v == 24){ v = 0; }
					// fallthrough...
				case 'h': //hour (1-12)
				case 'H': //hour (0-23)
				case 'k': //hour (0-11)
					//TODO: strict bounds checking, padding
					if(v > 23){
	//					console.log("dojo/date/locale.parse: Illegal hours value");
						return false;
					}
	
					//in the 12-hour case, adjusting for am/pm requires the 'a' part
					//which could come before or after the hour, so we will adjust later
					result[3] = v;
					break;
				case 'm': //minutes
					result[4] = v;
					break;
				case 's': //seconds
					result[5] = v;
					break;
				case 'S': //milliseconds
					result[6] = v;
	//				break;
	//			case 'w':
	//TODO				var firstDay = 0;
	//			default:
	//TODO: throw?
	//				console.log("dojo/date/locale.parse: unsupported pattern char=" + token.charAt(0));
			}
			return true;
		});
	
		var hours = +result[3];
		if(amPm === 'p' && hours < 12){
			result[3] = hours + 12; //e.g., 3pm -> 15
		}else if(amPm === 'a' && hours == 12){
			result[3] = 0; //12am -> 0
		}
	
		//TODO: implement a getWeekday() method in order to test
		//validity of input strings containing 'EEE' or 'EEEE'...
	
		var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
		if(options.strict){
			dateObject.setFullYear(result[0]);
		}
	
		// Check for overflow.  The Date() constructor normalizes things like April 32nd...
		//TODO: why isn't this done for times as well?
		var allTokens = tokens.join(""),
			dateToken = allTokens.indexOf('d') != -1,
			monthToken = allTokens.indexOf('M') != -1;
	
		if(!valid ||
			(monthToken && dateObject.getMonth() > result[1]) ||
			(dateToken && dateObject.getDate() > result[2])){
			return null;
		}
	
		// Check for underflow, due to DST shifts.  See #9366
		// This assumes a 1 hour dst shift correction at midnight
		// We could compare the timezone offset after the shift and add the difference instead.
		if((monthToken && dateObject.getMonth() < result[1]) ||
			(dateToken && dateObject.getDate() < result[2])){
			dateObject = date.add(dateObject, "hour", 1);
		}
	
		return dateObject; // Date
	};
	
	function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
		//summary: Process a pattern with literals in it
	
		// Break up on single quotes, treat every other one as a literal, except '' which becomes '
		var identity = function(x){return x;};
		applyPattern = applyPattern || identity;
		applyLiteral = applyLiteral || identity;
		applyAll = applyAll || identity;
	
		//split on single quotes (which escape literals in date format strings)
		//but preserve escaped single quotes (e.g., o''clock)
		var chunks = pattern.match(/(''|[^'])+/g),
			literal = pattern.charAt(0) == "'";
	
		array.forEach(chunks, function(chunk, i){
			if(!chunk){
				chunks[i]='';
			}else{
				chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
				literal = !literal;
			}
		});
		return applyAll(chunks.join(''));
	}
	
	function _buildDateTimeRE(tokens, bundle, options, pattern){
		pattern = regexp.escapeString(pattern);
		if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
		return pattern.replace(/([a-z])\1*/ig, function(match){
			// Build a simple regexp.  Avoid captures, which would ruin the tokens list
			var s,
				c = match.charAt(0),
				l = match.length,
				p2 = '', p3 = '';
			if(options.strict){
				if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
				if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
			}else{
				p2 = '0?'; p3 = '0{0,2}';
			}
			switch(c){
				case 'y':
					s = '\\d{2,4}';
					break;
				case 'M':
				case 'L':
					s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
					break;
				case 'D':
					s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p2+'[1-9][0-9]|'+p3+'[1-9]';
					break;
				case 'd':
					s = '3[01]|[12]\\d|'+p2+'[1-9]';
					break;
				case 'w':
					s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
					break;
				case 'E':
				case 'e':
				case 'c':
					s = '.+?'; // match anything including spaces until the first pattern delimiter is found such as a comma or space
					break;
				case 'h': //hour (1-12)
					s = '1[0-2]|'+p2+'[1-9]';
					break;
				case 'k': //hour (0-11)
					s = '1[01]|'+p2+'\\d';
					break;
				case 'H': //hour (0-23)
					s = '1\\d|2[0-3]|'+p2+'\\d';
					break;
				case 'K': //hour (1-24)
					s = '1\\d|2[0-4]|'+p2+'[1-9]';
					break;
				case 'm':
				case 's':
					s = '[0-5]\\d';
					break;
				case 'S':
					s = '\\d{'+l+'}';
					break;
				case 'a':
					var am = options.am || bundle['dayPeriods-format-wide-am'],
						pm = options.pm || bundle['dayPeriods-format-wide-pm'];
						s = am + '|' + pm;
					if(!options.strict){
						if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
						if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
						if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
					}
					s = s.replace(/\./g, "\\.");
					break;
				default:
				// case 'v':
				// case 'z':
				// case 'Z':
					s = ".*";
	//				console.log("parse of date format, pattern=" + pattern);
			}
	
			if(tokens){ tokens.push(match); }
	
			return "(" + s + ")"; // add capture
		}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
	}
	
	var _customFormats = [];
	var _cachedGregorianBundles = {};
	exports.addCustomFormats = function(/*String*/ packageName, /*String*/ bundleName){
		// summary:
		//		Add a reference to a bundle containing localized custom formats to be
		//		used by date/time formatting and parsing routines.
		//
		// description:
		//		The user may add custom localized formats where the bundle has properties following the
		//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
		//		The pattern string should match the format used by the CLDR.
		//		See dojo/date/locale.format() for details.
		//		The resources must be loaded by dojo.requireLocalization() prior to use
	
		_customFormats.push({pkg:packageName,name:bundleName});
		_cachedGregorianBundles = {};
	};
	
	exports._getGregorianBundle = function(/*String*/ locale){
		if(_cachedGregorianBundles[locale]){
			return _cachedGregorianBundles[locale];
		}
		var gregorian = {};
		array.forEach(_customFormats, function(desc){
			var bundle = i18n.getLocalization(desc.pkg, desc.name, locale);
			gregorian = lang.mixin(gregorian, bundle);
		}, this);
		return _cachedGregorianBundles[locale] = gregorian; /*Object*/
	};
	
	exports.addCustomFormats(module.id.replace(/\/date\/locale$/, ".cldr"),"gregorian");
	
	exports.getNames = function(/*String*/ item, /*String*/ type, /*String?*/ context, /*String?*/ locale){
		// summary:
		//		Used to get localized strings from dojo.cldr for day or month names.
		//
		// item:
		//	'months' || 'days'
		// type:
		//	'wide' || 'abbr' || 'narrow' (e.g. "Monday", "Mon", or "M" respectively, in English)
		// context:
		//	'standAlone' || 'format' (default)
		// locale:
		//	override locale used to find the names
	
		var label,
			lookup = exports._getGregorianBundle(locale),
			props = [item, context, type];
		if(context == 'standAlone'){
			var key = props.join('-');
			label = lookup[key];
			// Fall back to 'format' flavor of name
			if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
		}
		props[1] = 'format';
	
		// return by copy so changes won't be made accidentally to the in-memory model
		return (label || lookup[props.join('-')]).concat(); /*Array*/
	};
	
	exports.isWeekend = function(/*Date?*/ dateObject, /*String?*/ locale){
		// summary:
		//	Determines if the date falls on a weekend, according to local custom.
	
		var weekend = supplemental.getWeekend(locale),
			day = (dateObject || new Date()).getDay();
		if(weekend.end < weekend.start){
			weekend.end += 7;
			if(day < weekend.start){ day += 7; }
		}
		return day >= weekend.start && day <= weekend.end; // Boolean
	};
	
	// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?
	
	exports._getDayOfYear = function(/*Date*/ dateObject){
		// summary:
		//		gets the day of the year as represented by dateObject
		return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
	};
	
	exports._getWeekOfYear = function(/*Date*/ dateObject, /*Number*/ firstDayOfWeek){
		if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday
	
		var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
			adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
			week = Math.floor((exports._getDayOfYear(dateObject) + adj - 1) / 7);
	
		// if year starts on the specified day, start counting weeks at 1
		if(firstDayOfYear == firstDayOfWeek){ week++; }
	
		return week; // Number
	};
	
	return exports;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_RESULT__ = function(has, lang){
	// module:
	//		dojo/date
	
	var date = {
		// summary:
		//		Date manipulation utilities
	};
	
	date.getDaysInMonth = function(/*Date*/dateObject){
		// summary:
		//		Returns the number of days in the month used by dateObject
		var month = dateObject.getMonth();
		var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		if(month == 1 && date.isLeapYear(dateObject)){ return 29; } // Number
		return days[month]; // Number
	};
	
	date.isLeapYear = function(/*Date*/dateObject){
		// summary:
		//		Determines if the year of the dateObject is a leap year
		// description:
		//		Leap years are years with an additional day YYYY-02-29, where the
		//		year number is a multiple of four with the following exception: If
		//		a year is a multiple of 100, then it is only a leap year if it is
		//		also a multiple of 400. For example, 1900 was not a leap year, but
		//		2000 is one.
	
		var year = dateObject.getFullYear();
		return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
	};
	
	// FIXME: This is not localized
	date.getTimezoneName = function(/*Date*/dateObject){
		// summary:
		//		Get the user's time zone as provided by the browser
		// dateObject:
		//		Needed because the timezone may vary with time (daylight savings)
		// description:
		//		Try to get time zone info from toString or toLocaleString method of
		//		the Date object -- UTC offset is not a time zone.  See
		//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
		//		inconsistent across browsers.
	
		var str = dateObject.toString(); // Start looking in toString
		var tz = ''; // The result -- return empty string if nothing found
		var match;
	
		// First look for something in parentheses -- fast lookup, no regex
		var pos = str.indexOf('(');
		if(pos > -1){
			tz = str.substring(++pos, str.indexOf(')'));
		}else{
			// If at first you don't succeed ...
			// If IE knows about the TZ, it appears before the year
			// Capital letters or slash before a 4-digit year
			// at the end of string
			var pat = /([A-Z\/]+) \d{4}$/;
			if((match = str.match(pat))){
				tz = match[1];
			}else{
			// Some browsers (e.g. Safari) glue the TZ on the end
			// of toLocaleString instead of putting it in toString
				str = dateObject.toLocaleString();
				// Capital letters or slash -- end of string,
				// after space
				pat = / ([A-Z\/]+)$/;
				if((match = str.match(pat))){
					tz = match[1];
				}
			}
		}
	
		// Make sure it doesn't somehow end up return AM or PM
		return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
	};
	
	// Utility methods to do arithmetic calculations with Dates
	
	date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
		// summary:
		//		Compare two date objects by date, time, or both.
		// description:
		//		Returns 0 if equal, positive if a > b, else negative.
		// date1:
		//		Date object
		// date2:
		//		Date object.  If not specified, the current Date is used.
		// portion:
		//		A string indicating the "date" or "time" portion of a Date object.
		//		Compares both "date" and "time" by default.  One of the following:
		//		"date", "time", "datetime"
	
		// Extra step required in copy for IE - see #3112
		date1 = new Date(+date1);
		date2 = new Date(+(date2 || new Date()));
	
		if(portion == "date"){
			// Ignore times and compare dates.
			date1.setHours(0, 0, 0, 0);
			date2.setHours(0, 0, 0, 0);
		}else if(portion == "time"){
			// Ignore dates and compare times.
			date1.setFullYear(0, 0, 0);
			date2.setFullYear(0, 0, 0);
		}
	
		if(date1 > date2){ return 1; } // int
		if(date1 < date2){ return -1; } // int
		return 0; // int
	};
	
	date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
		// summary:
		//		Add to a Date in intervals of different size, from milliseconds to years
		// date: Date
		//		Date object to start with
		// interval:
		//		A string representing the interval.  One of the following:
		//		"year", "month", "day", "hour", "minute", "second",
		//		"millisecond", "quarter", "week", "weekday"
		// amount:
		//		How much to add to the date.
	
		var sum = new Date(+date); // convert to Number before copying to accommodate IE (#3112)
		var fixOvershoot = false;
		var property = "Date";
	
		switch(interval){
			case "day":
				break;
			case "weekday":
				//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo/cldr/supplemental
	
				// Divide the increment time span into weekspans plus leftover days
				// e.g., 8 days is one 5-day weekspan / and two leftover days
				// Can't have zero leftover days, so numbers divisible by 5 get
				// a days value of 5, and the remaining days make up the number of weeks
				var days, weeks;
				var mod = amount % 5;
				if(!mod){
					days = (amount > 0) ? 5 : -5;
					weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
				}else{
					days = mod;
					weeks = parseInt(amount/5);
				}
				// Get weekday value for orig date param
				var strt = date.getDay();
				// Orig date is Sat / positive incrementer
				// Jump over Sun
				var adj = 0;
				if(strt == 6 && amount > 0){
					adj = 1;
				}else if(strt == 0 && amount < 0){
				// Orig date is Sun / negative incrementer
				// Jump back over Sat
					adj = -1;
				}
				// Get weekday val for the new date
				var trgt = strt + days;
				// New date is on Sat or Sun
				if(trgt == 0 || trgt == 6){
					adj = (amount > 0) ? 2 : -2;
				}
				// Increment by number of weeks plus leftover days plus
				// weekend adjustments
				amount = (7 * weeks) + days + adj;
				break;
			case "year":
				property = "FullYear";
				// Keep increment/decrement from 2/29 out of March
				fixOvershoot = true;
				break;
			case "week":
				amount *= 7;
				break;
			case "quarter":
				// Naive quarter is just three months
				amount *= 3;
				// fallthrough...
			case "month":
				// Reset to last day of month if you overshoot
				fixOvershoot = true;
				property = "Month";
				break;
	//		case "hour":
	//		case "minute":
	//		case "second":
	//		case "millisecond":
			default:
				property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
		}
	
		if(property){
			sum["set"+property](sum["get"+property]()+amount);
		}
	
		if(fixOvershoot && (sum.getDate() < date.getDate())){
			sum.setDate(0);
		}
	
		return sum; // Date
	};
	
	date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
		// summary:
		//		Get the difference in a specific unit of time (e.g., number of
		//		months, weeks, days, etc.) between two dates, rounded to the
		//		nearest integer.
		// date1:
		//		Date object
		// date2:
		//		Date object.  If not specified, the current Date is used.
		// interval:
		//		A string representing the interval.  One of the following:
		//		"year", "month", "day", "hour", "minute", "second",
		//		"millisecond", "quarter", "week", "weekday"
		//
		//		Defaults to "day".
	
		date2 = date2 || new Date();
		interval = interval || "day";
		var yearDiff = date2.getFullYear() - date1.getFullYear();
		var delta = 1; // Integer return value
	
		switch(interval){
			case "quarter":
				var m1 = date1.getMonth();
				var m2 = date2.getMonth();
				// Figure out which quarter the months are in
				var q1 = Math.floor(m1/3) + 1;
				var q2 = Math.floor(m2/3) + 1;
				// Add quarters for any year difference between the dates
				q2 += (yearDiff * 4);
				delta = q2 - q1;
				break;
			case "weekday":
				var days = Math.round(date.difference(date1, date2, "day"));
				var weeks = parseInt(date.difference(date1, date2, "week"));
				var mod = days % 7;
	
				// Even number of weeks
				if(mod == 0){
					days = weeks*5;
				}else{
					// Weeks plus spare change (< 7 days)
					var adj = 0;
					var aDay = date1.getDay();
					var bDay = date2.getDay();
	
					weeks = parseInt(days/7);
					mod = days % 7;
					// Mark the date advanced by the number of
					// round weeks (may be zero)
					var dtMark = new Date(date1);
					dtMark.setDate(dtMark.getDate()+(weeks*7));
					var dayMark = dtMark.getDay();
	
					// Spare change days -- 6 or less
					if(days > 0){
						switch(true){
							// Range starts on Sat
							case aDay == 6:
								adj = -1;
								break;
							// Range starts on Sun
							case aDay == 0:
								adj = 0;
								break;
							// Range ends on Sat
							case bDay == 6:
								adj = -1;
								break;
							// Range ends on Sun
							case bDay == 0:
								adj = -2;
								break;
							// Range contains weekend
							case (dayMark + mod) > 5:
								adj = -2;
						}
					}else if(days < 0){
						switch(true){
							// Range starts on Sat
							case aDay == 6:
								adj = 0;
								break;
							// Range starts on Sun
							case aDay == 0:
								adj = 1;
								break;
							// Range ends on Sat
							case bDay == 6:
								adj = 2;
								break;
							// Range ends on Sun
							case bDay == 0:
								adj = 1;
								break;
							// Range contains weekend
							case (dayMark + mod) < 0:
								adj = 2;
						}
					}
					days += adj;
					days -= (weeks*2);
				}
				delta = days;
				break;
			case "year":
				delta = yearDiff;
				break;
			case "month":
				delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
				break;
			case "week":
				// Truncate instead of rounding
				// Don't use Math.floor -- value may be negative
				delta = parseInt(date.difference(date1, date2, "day")/7);
				break;
			case "day":
				delta /= 24;
				// fallthrough
			case "hour":
				delta /= 60;
				// fallthrough
			case "minute":
				delta /= 60;
				// fallthrough
			case "second":
				delta /= 1000;
				// fallthrough
			case "millisecond":
				delta *= date2.getTime() - date1.getTime();
		}
	
		// Round for fractional values and DST leaps
		return Math.round(delta); // Number (integer)
	};
	
	// Don't use setObject() because it may overwrite dojo/date/stamp (if that has already been loaded)
	has("extend-dojo") && lang.mixin(lang.getObject("dojo.date", true), date);
	
	return date;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(121)], __WEBPACK_AMD_DEFINE_RESULT__ = function(lang, i18n){
	
	// module:
	//		dojo/cldr/supplemental
	
	
	var supplemental = {
		// summary:
		//		TODOC
	};
	lang.setObject("dojo.cldr.supplemental", supplemental);
	
	supplemental.getFirstDayOfWeek = function(/*String?*/locale){
		// summary:
		//		Returns a zero-based index for first day of the week
		// description:
		//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
		//		e.g. Sunday (returns 0), or Monday (returns 1)
	
		// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
		var firstDay = {/*default is 1=Monday*/
			bd:5,mv:5,
			ae:6,af:6,bh:6,dj:6,dz:6,eg:6,iq:6,ir:6,jo:6,kw:6,
			ly:6,ma:6,om:6,qa:6,sa:6,sd:6,sy:6,ye:6,
			ag:0,ar:0,as:0,au:0,br:0,bs:0,bt:0,bw:0,by:0,bz:0,ca:0,cn:0,
			co:0,dm:0,'do':0,et:0,gt:0,gu:0,hk:0,hn:0,id:0,ie:0,il:0,'in':0,
			jm:0,jp:0,ke:0,kh:0,kr:0,la:0,mh:0,mm:0,mo:0,mt:0,mx:0,mz:0,
			ni:0,np:0,nz:0,pa:0,pe:0,ph:0,pk:0,pr:0,py:0,sg:0,sv:0,th:0,
			tn:0,tt:0,tw:0,um:0,us:0,ve:0,vi:0,ws:0,za:0,zw:0
		};
	
		var country = supplemental._region(locale);
		var dow = firstDay[country];
		return (dow === undefined) ? 1 : dow; /*Number*/
	};
	
	supplemental._region = function(/*String?*/locale){
		locale = i18n.normalizeLocale(locale);
		var tags = locale.split('-');
		var region = tags[1];
		if(!region){
			// IE often gives language only (#2269)
			// Arbitrary mappings of language-only locales to a country:
			region = {
				aa:"et", ab:"ge", af:"za", ak:"gh", am:"et", ar:"eg", as:"in", av:"ru", ay:"bo", az:"az", ba:"ru",
				be:"by", bg:"bg", bi:"vu", bm:"ml", bn:"bd", bo:"cn", br:"fr", bs:"ba", ca:"es", ce:"ru", ch:"gu",
				co:"fr", cr:"ca", cs:"cz", cv:"ru", cy:"gb", da:"dk", de:"de", dv:"mv", dz:"bt", ee:"gh", el:"gr",
				en:"us", es:"es", et:"ee", eu:"es", fa:"ir", ff:"sn", fi:"fi", fj:"fj", fo:"fo", fr:"fr", fy:"nl",
				ga:"ie", gd:"gb", gl:"es", gn:"py", gu:"in", gv:"gb", ha:"ng", he:"il", hi:"in", ho:"pg", hr:"hr",
				ht:"ht", hu:"hu", hy:"am", ia:"fr", id:"id", ig:"ng", ii:"cn", ik:"us", "in":"id", is:"is", it:"it",
				iu:"ca", iw:"il", ja:"jp", ji:"ua", jv:"id", jw:"id", ka:"ge", kg:"cd", ki:"ke", kj:"na", kk:"kz",
				kl:"gl", km:"kh", kn:"in", ko:"kr", ks:"in", ku:"tr", kv:"ru", kw:"gb", ky:"kg", la:"va", lb:"lu",
				lg:"ug", li:"nl", ln:"cd", lo:"la", lt:"lt", lu:"cd", lv:"lv", mg:"mg", mh:"mh", mi:"nz", mk:"mk",
				ml:"in", mn:"mn", mo:"ro", mr:"in", ms:"my", mt:"mt", my:"mm", na:"nr", nb:"no", nd:"zw", ne:"np",
				ng:"na", nl:"nl", nn:"no", no:"no", nr:"za", nv:"us", ny:"mw", oc:"fr", om:"et", or:"in", os:"ge",
				pa:"in", pl:"pl", ps:"af", pt:"br", qu:"pe", rm:"ch", rn:"bi", ro:"ro", ru:"ru", rw:"rw", sa:"in",
				sd:"in", se:"no", sg:"cf", si:"lk", sk:"sk", sl:"si", sm:"ws", sn:"zw", so:"so", sq:"al", sr:"rs",
				ss:"za", st:"za", su:"id", sv:"se", sw:"tz", ta:"in", te:"in", tg:"tj", th:"th", ti:"et", tk:"tm",
				tl:"ph", tn:"za", to:"to", tr:"tr", ts:"za", tt:"ru", ty:"pf", ug:"cn", uk:"ua", ur:"pk", uz:"uz",
				ve:"za", vi:"vn", wa:"be", wo:"sn", xh:"za", yi:"il", yo:"ng", za:"cn", zh:"cn", zu:"za",
				ace:"id", ady:"ru", agq:"cm", alt:"ru", amo:"ng", asa:"tz", ast:"es", awa:"in", bal:"pk",
				ban:"id", bas:"cm", bax:"cm", bbc:"id", bem:"zm", bez:"tz", bfq:"in", bft:"pk", bfy:"in",
				bhb:"in", bho:"in", bik:"ph", bin:"ng", bjj:"in", bku:"ph", bqv:"ci", bra:"in", brx:"in",
				bss:"cm", btv:"pk", bua:"ru", buc:"yt", bug:"id", bya:"id", byn:"er", cch:"ng", ccp:"in",
				ceb:"ph", cgg:"ug", chk:"fm", chm:"ru", chp:"ca", chr:"us", cja:"kh", cjm:"vn", ckb:"iq",
				crk:"ca", csb:"pl", dar:"ru", dav:"ke", den:"ca", dgr:"ca", dje:"ne", doi:"in", dsb:"de",
				dua:"cm", dyo:"sn", dyu:"bf", ebu:"ke", efi:"ng", ewo:"cm", fan:"gq", fil:"ph", fon:"bj",
				fur:"it", gaa:"gh", gag:"md", gbm:"in", gcr:"gf", gez:"et", gil:"ki", gon:"in", gor:"id",
				grt:"in", gsw:"ch", guz:"ke", gwi:"ca", haw:"us", hil:"ph", hne:"in", hnn:"ph", hoc:"in",
				hoj:"in", ibb:"ng", ilo:"ph", inh:"ru", jgo:"cm", jmc:"tz", kaa:"uz", kab:"dz", kaj:"ng",
				kam:"ke", kbd:"ru", kcg:"ng", kde:"tz", kdt:"th", kea:"cv", ken:"cm", kfo:"ci", kfr:"in",
				kha:"in", khb:"cn", khq:"ml", kht:"in", kkj:"cm", kln:"ke", kmb:"ao", koi:"ru", kok:"in",
				kos:"fm", kpe:"lr", krc:"ru", kri:"sl", krl:"ru", kru:"in", ksb:"tz", ksf:"cm", ksh:"de",
				kum:"ru", lag:"tz", lah:"pk", lbe:"ru", lcp:"cn", lep:"in", lez:"ru", lif:"np", lis:"cn",
				lki:"ir", lmn:"in", lol:"cd", lua:"cd", luo:"ke", luy:"ke", lwl:"th", mad:"id", mag:"in",
				mai:"in", mak:"id", man:"gn", mas:"ke", mdf:"ru", mdh:"ph", mdr:"id", men:"sl", mer:"ke",
				mfe:"mu", mgh:"mz", mgo:"cm", min:"id", mni:"in", mnk:"gm", mnw:"mm", mos:"bf", mua:"cm",
				mwr:"in", myv:"ru", nap:"it", naq:"na", nds:"de", "new":"np", niu:"nu", nmg:"cm", nnh:"cm",
				nod:"th", nso:"za", nus:"sd", nym:"tz", nyn:"ug", pag:"ph", pam:"ph", pap:"bq", pau:"pw",
				pon:"fm", prd:"ir", raj:"in", rcf:"re", rej:"id", rjs:"np", rkt:"in", rof:"tz", rwk:"tz",
				saf:"gh", sah:"ru", saq:"ke", sas:"id", sat:"in", saz:"in", sbp:"tz", scn:"it", sco:"gb",
				sdh:"ir", seh:"mz", ses:"ml", shi:"ma", shn:"mm", sid:"et", sma:"se", smj:"se", smn:"fi",
				sms:"fi", snk:"ml", srn:"sr", srr:"sn", ssy:"er", suk:"tz", sus:"gn", swb:"yt", swc:"cd",
				syl:"bd", syr:"sy", tbw:"ph", tcy:"in", tdd:"cn", tem:"sl", teo:"ug", tet:"tl", tig:"er",
				tiv:"ng", tkl:"tk", tmh:"ne", tpi:"pg", trv:"tw", tsg:"ph", tts:"th", tum:"mw", tvl:"tv",
				twq:"ne", tyv:"ru", tzm:"ma", udm:"ru", uli:"fm", umb:"ao", unr:"in", unx:"in", vai:"lr",
				vun:"tz", wae:"ch", wal:"et", war:"ph", xog:"ug", xsr:"np", yao:"mz", yap:"fm", yav:"cm", zza:"tr"
			}[tags[0]];
		}else if(region.length == 4){
			// The ISO 3166 country code is usually in the second position, unless a
			// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
			region = tags[2];
		}
		return region;
	};
	
	supplemental.getWeekend = function(/*String?*/locale){
		// summary:
		//		Returns a hash containing the start and end days of the weekend
		// description:
		//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
		//		or by default in the user's locale.
		//		e.g. {start:6, end:0}
	
		// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
		var weekendStart = {/*default is 6=Saturday*/
				'in':0,
				af:4,dz:4,ir:4,om:4,sa:4,ye:4,
				ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
			},
	
			weekendEnd = {/*default is 0=Sunday*/
				af:5,dz:5,ir:5,om:5,sa:5,ye:5,
				ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
			},
	
			country = supplemental._region(locale),
			start = weekendStart[country],
			end = weekendEnd[country];
	
		if(start === undefined){start=6;}
		if(end === undefined){end=0;}
		return {start:start, end:end}; /*Object {start,end}*/
	};
	
	return supplemental;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6),__webpack_require__(165),__webpack_require__(166),__webpack_require__(167)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire,lang_en,lang_ru,lang_fr){return dojoWebpackLoaderRequire.register("dojo/cldr/nls/gregorian", (function(){return {"root":{"dateFormatItem-Ehm":"E h:mm a","days-standAlone-short":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"months-format-narrow":["1","2","3","4","5","6","7","8","9","10","11","12"],"field-second-relative+0":"now","quarters-standAlone-narrow":["1","2","3","4"],"field-weekday":"Day of the Week","dateFormatItem-yQQQ":"y QQQ","dateFormatItem-yMEd":"y-MM-dd, E","field-wed-relative+0":"this Wednesday","field-wed-relative+1":"next Wednesday","dateFormatItem-GyMMMEd":"G y MMM d, E","dateFormatItem-MMMEd":"MMM d, E","eraNarrow":["BCE","CE"],"field-tue-relative+-1":"last Tuesday","days-format-short":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"dateTimeFormats-appendItem-Day-Of-Week":"{0} {1}","dateFormat-long":"y MMMM d","field-fri-relative+-1":"last Friday","field-wed-relative+-1":"last Wednesday","months-format-wide":["M01","M02","M03","M04","M05","M06","M07","M08","M09","M10","M11","M12"],"dateTimeFormat-medium":"{1} {0}","dayPeriods-format-wide-pm":"PM","dateFormat-full":"y MMMM d, EEEE","field-thu-relative+-1":"last Thursday","dateFormatItem-Md":"MM-dd","dayPeriods-format-abbr-am":"AM","dateTimeFormats-appendItem-Second":"{0} ({2}: {1})","dayPeriods-format-wide-noon":"noon","dateFormatItem-yMd":"y-MM-dd","field-era":"Era","dateFormatItem-yM":"y-MM","months-standAlone-wide":["M01","M02","M03","M04","M05","M06","M07","M08","M09","M10","M11","M12"],"timeFormat-short":"HH:mm","quarters-format-wide":["Q1","Q2","Q3","Q4"],"dateFormatItem-yQQQQ":"y QQQQ","timeFormat-long":"HH:mm:ss z","field-year":"Year","dateFormatItem-yMMM":"y MMM","dateTimeFormats-appendItem-Era":"{1} {0}","field-hour":"Hour","months-format-abbr":["M01","M02","M03","M04","M05","M06","M07","M08","M09","M10","M11","M12"],"field-sat-relative+0":"this Saturday","field-sat-relative+1":"next Saturday","timeFormat-full":"HH:mm:ss zzzz","dateTimeFormats-appendItem-Week":"{0} ({2}: {1})","field-day-relative+0":"today","field-thu-relative+0":"this Thursday","field-day-relative+1":"tomorrow","field-thu-relative+1":"next Thursday","dateFormatItem-GyMMMd":"G y MMM d","dateFormatItem-H":"HH","months-standAlone-abbr":["M01","M02","M03","M04","M05","M06","M07","M08","M09","M10","M11","M12"],"quarters-format-abbr":["Q1","Q2","Q3","Q4"],"quarters-standAlone-wide":["Q1","Q2","Q3","Q4"],"dateFormatItem-Gy":"G y","dateFormatItem-M":"L","days-standAlone-wide":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"dayPeriods-format-abbr-noon":"noon","timeFormat-medium":"HH:mm:ss","field-sun-relative+0":"this Sunday","dateFormatItem-Hm":"HH:mm","field-sun-relative+1":"next Sunday","quarters-standAlone-abbr":["Q1","Q2","Q3","Q4"],"eraAbbr":["BCE","CE"],"field-minute":"Minute","field-dayperiod":"Dayperiod","days-standAlone-abbr":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"dateFormatItem-d":"d","dateFormatItem-ms":"mm:ss","quarters-format-narrow":["1","2","3","4"],"field-day-relative+-1":"yesterday","dateTimeFormat-long":"{1} {0}","dayPeriods-format-narrow-am":"a","dateFormatItem-h":"h a","dateFormatItem-MMMd":"MMM d","dateFormatItem-MEd":"MM-dd, E","dateTimeFormat-full":"{1} {0}","field-fri-relative+0":"this Friday","field-fri-relative+1":"next Friday","field-day":"Day","days-format-wide":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"field-zone":"Zone","months-standAlone-narrow":["1","2","3","4","5","6","7","8","9","10","11","12"],"dateFormatItem-y":"y","dateTimeFormats-appendItem-Day":"{0} ({2}: {1})","field-year-relative+-1":"last year","field-month-relative+-1":"last month","dateTimeFormats-appendItem-Year":"{1} {0}","dateFormatItem-hm":"h:mm a","dateTimeFormats-appendItem-Hour":"{0} ({2}: {1})","dayPeriods-format-abbr-pm":"PM","days-format-abbr":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"eraNames":["BCE","CE"],"dateFormatItem-yMMMd":"y MMM d","days-format-narrow":["S","M","T","W","T","F","S"],"field-month":"Month","days-standAlone-narrow":["S","M","T","W","T","F","S"],"dateFormatItem-MMM":"LLL","field-tue-relative+0":"this Tuesday","dateTimeFormats-appendItem-Quarter":"{0} ({2}: {1})","field-tue-relative+1":"next Tuesday","dayPeriods-format-wide-am":"AM","dateTimeFormats-appendItem-Month":"{0} ({2}: {1})","dateTimeFormats-appendItem-Minute":"{0} ({2}: {1})","dateFormatItem-EHm":"E HH:mm","field-mon-relative+0":"this Monday","field-mon-relative+1":"next Monday","dateFormat-short":"y-MM-dd","dateFormatItem-EHms":"E HH:mm:ss","dateFormatItem-Ehms":"E h:mm:ss a","dayPeriods-format-narrow-noon":"n","field-second":"Second","field-sat-relative+-1":"last Saturday","dateFormatItem-yMMMEd":"y MMM d, E","field-sun-relative+-1":"last Sunday","field-month-relative+0":"this month","field-month-relative+1":"next month","dateTimeFormats-appendItem-Timezone":"{0} {1}","dateFormatItem-Ed":"d, E","field-week":"Week","dateFormat-medium":"y MMM d","field-week-relative+-1":"last week","field-year-relative+0":"this year","field-year-relative+1":"next year","dayPeriods-format-narrow-pm":"p","dateTimeFormat-short":"{1} {0}","dateFormatItem-Hms":"HH:mm:ss","dateFormatItem-hms":"h:mm:ss a","dateFormatItem-GyMMM":"G y MMM","field-mon-relative+-1":"last Monday","field-week-relative+0":"this week","field-week-relative+1":"next week"},"en":true,"ru":true,"fr":true};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dojo/cldr/nls/en/gregorian", (function(){return {
		"dateFormatItem-Ehm": "E h:mm a",
		"days-standAlone-short": [
			"Su",
			"Mo",
			"Tu",
			"We",
			"Th",
			"Fr",
			"Sa"
		],
		"months-format-narrow": [
			"J",
			"F",
			"M",
			"A",
			"M",
			"J",
			"J",
			"A",
			"S",
			"O",
			"N",
			"D"
		],
		"field-second-relative+0": "now",
		"quarters-standAlone-narrow": [
			"1",
			"2",
			"3",
			"4"
		],
		"field-weekday": "Day of the Week",
		"dateFormatItem-yQQQ": "QQQ y",
		"dateFormatItem-yMEd": "E, M/d/y",
		"field-wed-relative+0": "this Wednesday",
		"field-wed-relative+1": "next Wednesday",
		"dateFormatItem-GyMMMEd": "E, MMM d, y G",
		"dateFormatItem-MMMEd": "E, MMM d",
		"eraNarrow": [
			"B",
			"A"
		],
		"field-tue-relative+-1": "last Tuesday",
		"days-format-short": [
			"Su",
			"Mo",
			"Tu",
			"We",
			"Th",
			"Fr",
			"Sa"
		],
		"dateTimeFormats-appendItem-Day-Of-Week": "{0} {1}",
		"dateFormat-long": "MMMM d, y",
		"field-fri-relative+-1": "last Friday",
		"field-wed-relative+-1": "last Wednesday",
		"months-format-wide": [
			"January",
			"February",
			"March",
			"April",
			"May",
			"June",
			"July",
			"August",
			"September",
			"October",
			"November",
			"December"
		],
		"dateTimeFormat-medium": "{1}, {0}",
		"dayPeriods-format-wide-pm": "PM",
		"dateFormat-full": "EEEE, MMMM d, y",
		"field-thu-relative+-1": "last Thursday",
		"dateFormatItem-Md": "M/d",
		"dateTimeFormats-appendItem-Second": "{0} ({2}: {1})",
		"dayPeriods-format-wide-noon": "noon",
		"dateFormatItem-yMd": "M/d/y",
		"field-era": "Era",
		"dateFormatItem-yM": "M/y",
		"months-standAlone-wide": [
			"January",
			"February",
			"March",
			"April",
			"May",
			"June",
			"July",
			"August",
			"September",
			"October",
			"November",
			"December"
		],
		"timeFormat-short": "h:mm a",
		"quarters-format-wide": [
			"1st quarter",
			"2nd quarter",
			"3rd quarter",
			"4th quarter"
		],
		"dateFormatItem-yQQQQ": "QQQQ y",
		"timeFormat-long": "h:mm:ss a z",
		"field-year": "Year",
		"dateFormatItem-yMMM": "MMM y",
		"dateTimeFormats-appendItem-Era": "{0} {1}",
		"field-hour": "Hour",
		"months-format-abbr": [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		],
		"field-sat-relative+0": "this Saturday",
		"field-sat-relative+1": "next Saturday",
		"timeFormat-full": "h:mm:ss a zzzz",
		"dateTimeFormats-appendItem-Week": "{0} ({2}: {1})",
		"field-day-relative+0": "today",
		"field-thu-relative+0": "this Thursday",
		"field-day-relative+1": "tomorrow",
		"field-thu-relative+1": "next Thursday",
		"dateFormatItem-GyMMMd": "MMM d, y G",
		"dateFormatItem-H": "HH",
		"months-standAlone-abbr": [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		],
		"quarters-format-abbr": [
			"Q1",
			"Q2",
			"Q3",
			"Q4"
		],
		"quarters-standAlone-wide": [
			"1st quarter",
			"2nd quarter",
			"3rd quarter",
			"4th quarter"
		],
		"dateFormatItem-Gy": "y G",
		"dateFormatItem-M": "L",
		"days-standAlone-wide": [
			"Sunday",
			"Monday",
			"Tuesday",
			"Wednesday",
			"Thursday",
			"Friday",
			"Saturday"
		],
		"timeFormat-medium": "h:mm:ss a",
		"field-sun-relative+0": "this Sunday",
		"dateFormatItem-Hm": "HH:mm",
		"field-sun-relative+1": "next Sunday",
		"eraAbbr": [
			"BC",
			"AD"
		],
		"field-minute": "Minute",
		"field-dayperiod": "AM/PM",
		"dateFormatItem-d": "d",
		"dateFormatItem-ms": "mm:ss",
		"field-day-relative+-1": "yesterday",
		"dateFormatItem-h": "h a",
		"dateTimeFormat-long": "{1} 'at' {0}",
		"dayPeriods-format-narrow-am": "a",
		"dateFormatItem-MMMd": "MMM d",
		"dateFormatItem-MEd": "E, M/d",
		"dateTimeFormat-full": "{1} 'at' {0}",
		"field-fri-relative+0": "this Friday",
		"field-fri-relative+1": "next Friday",
		"field-day": "Day",
		"days-format-wide": [
			"Sunday",
			"Monday",
			"Tuesday",
			"Wednesday",
			"Thursday",
			"Friday",
			"Saturday"
		],
		"field-zone": "Time Zone",
		"dateTimeFormats-appendItem-Day": "{0} ({2}: {1})",
		"dateFormatItem-y": "y",
		"months-standAlone-narrow": [
			"J",
			"F",
			"M",
			"A",
			"M",
			"J",
			"J",
			"A",
			"S",
			"O",
			"N",
			"D"
		],
		"field-year-relative+-1": "last year",
		"field-month-relative+-1": "last month",
		"dateFormatItem-hm": "h:mm a",
		"dateTimeFormats-appendItem-Year": "{0} {1}",
		"dateTimeFormats-appendItem-Hour": "{0} ({2}: {1})",
		"days-format-abbr": [
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		],
		"dateFormatItem-yMMMd": "MMM d, y",
		"eraNames": [
			"Before Christ",
			"Anno Domini"
		],
		"days-standAlone-narrow": [
			"S",
			"M",
			"T",
			"W",
			"T",
			"F",
			"S"
		],
		"dateFormatItem-MMM": "LLL",
		"field-month": "Month",
		"field-tue-relative+0": "this Tuesday",
		"dateTimeFormats-appendItem-Quarter": "{0} ({2}: {1})",
		"field-tue-relative+1": "next Tuesday",
		"dayPeriods-format-wide-am": "AM",
		"dateTimeFormats-appendItem-Month": "{0} ({2}: {1})",
		"dateTimeFormats-appendItem-Minute": "{0} ({2}: {1})",
		"dateFormatItem-EHm": "E HH:mm",
		"field-mon-relative+0": "this Monday",
		"field-mon-relative+1": "next Monday",
		"dateFormat-short": "M/d/yy",
		"dateFormatItem-EHms": "E HH:mm:ss",
		"dateFormatItem-Ehms": "E h:mm:ss a",
		"dayPeriods-format-narrow-noon": "n",
		"field-second": "Second",
		"field-sat-relative+-1": "last Saturday",
		"dateFormatItem-yMMMEd": "E, MMM d, y",
		"field-sun-relative+-1": "last Sunday",
		"field-month-relative+0": "this month",
		"field-month-relative+1": "next month",
		"dateFormatItem-Ed": "d E",
		"dateTimeFormats-appendItem-Timezone": "{0} {1}",
		"field-week": "Week",
		"dateFormat-medium": "MMM d, y",
		"field-year-relative+0": "this year",
		"field-week-relative+-1": "last week",
		"field-year-relative+1": "next year",
		"dayPeriods-format-narrow-pm": "p",
		"dateTimeFormat-short": "{1}, {0}",
		"dateFormatItem-Hms": "HH:mm:ss",
		"dateFormatItem-hms": "h:mm:ss a",
		"dateFormatItem-GyMMM": "MMM y G",
		"field-mon-relative+-1": "last Monday",
		"field-week-relative+0": "this week",
		"field-week-relative+1": "next week"
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dojo/cldr/nls/ru/gregorian", (function(){return {
		"dateFormatItem-Ehm": "E h:mm a",
		"days-standAlone-short": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"months-format-narrow": [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"field-second-relative+0": "",
		"quarters-standAlone-narrow": [
			"1",
			"2",
			"3",
			"4"
		],
		"field-weekday": " ",
		"dateFormatItem-yQQQ": "QQQ y ''.",
		"dateFormatItem-yMEd": "ccc, d.MM.y ''.",
		"field-wed-relative+0": "  ",
		"dateFormatItem-GyMMMEd": "E, d MMM y G",
		"dateFormatItem-MMMEd": "ccc, d MMM",
		"field-wed-relative+1": "  ",
		"eraNarrow": [
			" ..",
			".."
		],
		"dateFormatItem-yMM": "MM.y",
		"field-tue-relative+-1": "  ",
		"days-format-short": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"dateFormat-long": "d MMMM y ''.",
		"field-fri-relative+-1": "  ",
		"field-wed-relative+-1": "  ",
		"months-format-wide": [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"dateTimeFormat-medium": "{1}, {0}",
		"dayPeriods-format-wide-pm": "PM",
		"dateFormat-full": "EEEE, d MMMM y ''.",
		"field-thu-relative+-1": "  ",
		"dateFormatItem-Md": "dd.MM",
		"dayPeriods-format-abbr-am": "AM",
		"dateFormatItem-yMd": "dd.MM.y",
		"dateFormatItem-yM": "MM.y",
		"field-era": "",
		"months-standAlone-wide": [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"timeFormat-short": "H:mm",
		"quarters-format-wide": [
			"1- ",
			"2- ",
			"3- ",
			"4- "
		],
		"timeFormat-long": "H:mm:ss z",
		"dateFormatItem-yMMM": "LLL y",
		"dateFormatItem-yQQQQ": "QQQQ y ''.",
		"field-year": "",
		"dateFormatItem-MMdd": "dd.MM",
		"field-hour": "",
		"months-format-abbr": [
			".",
			".",
			"",
			".",
			"",
			"",
			"",
			".",
			".",
			".",
			".",
			"."
		],
		"field-sat-relative+0": "  ",
		"field-sat-relative+1": "  ",
		"timeFormat-full": "H:mm:ss zzzz",
		"dateFormatItem-E": "ccc",
		"field-day-relative+0": "",
		"field-day-relative+1": "",
		"field-thu-relative+0": "  ",
		"dateFormatItem-GyMMMd": "d MMM y ''. G",
		"field-day-relative+2": "",
		"field-thu-relative+1": "  ",
		"dateFormatItem-H": "H",
		"months-standAlone-abbr": [
			".",
			".",
			"",
			".",
			"",
			"",
			"",
			".",
			".",
			".",
			".",
			"."
		],
		"quarters-format-abbr": [
			"1- .",
			"2- .",
			"3- .",
			"4- ."
		],
		"quarters-standAlone-wide": [
			"1- ",
			"2- ",
			"3- ",
			"4- "
		],
		"dateFormatItem-Gy": "y G",
		"dateFormatItem-M": "L",
		"days-standAlone-wide": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"dateFormatItem-yLLLL": "LLLL y",
		"timeFormat-medium": "H:mm:ss",
		"field-sun-relative+0": "  ",
		"dateFormatItem-Hm": "H:mm",
		"quarters-standAlone-abbr": [
			"1- .",
			"2- .",
			"3- .",
			"4- ."
		],
		"field-sun-relative+1": "  ",
		"eraAbbr": [
			" . .",
			". ."
		],
		"field-minute": "",
		"field-dayperiod": "/",
		"days-standAlone-abbr": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"dateFormatItem-d": "d",
		"dateFormatItem-ms": "mm:ss",
		"quarters-format-narrow": [
			"1",
			"2",
			"3",
			"4"
		],
		"field-day-relative+-1": "",
		"dateFormatItem-h": "h a",
		"dateTimeFormat-long": "{1}, {0}",
		"dayPeriods-format-narrow-am": "AM",
		"field-day-relative+-2": "",
		"dateFormatItem-MMMd": "d MMM",
		"dateFormatItem-MEd": "E, dd.MM",
		"dateTimeFormat-full": "{1}, {0}",
		"field-fri-relative+0": "  ",
		"dateFormatItem-yMMMM": "LLLL y",
		"field-fri-relative+1": "  ",
		"field-day": "",
		"days-format-wide": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"field-zone": " ",
		"dateFormatItem-y": "y",
		"months-standAlone-narrow": [
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"field-year-relative+-1": "  ",
		"field-month-relative+-1": "  ",
		"dateFormatItem-hm": "h:mm a",
		"dayPeriods-format-abbr-pm": "PM",
		"days-format-abbr": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"eraNames": [
			" ..",
			".."
		],
		"dateFormatItem-yMMMd": "d MMM y ''.",
		"days-format-narrow": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"days-standAlone-narrow": [
			"",
			"",
			"",
			"",
			"",
			"",
			""
		],
		"dateFormatItem-MMM": "LLL",
		"field-month": "",
		"field-tue-relative+0": "  ",
		"field-tue-relative+1": "  ",
		"dayPeriods-format-wide-am": "AM",
		"dateFormatItem-EHm": "E HH:mm",
		"field-mon-relative+0": "  ",
		"field-mon-relative+1": "  ",
		"dateFormat-short": "dd.MM.yy",
		"dateFormatItem-EHms": "E HH:mm:ss",
		"dateFormatItem-Ehms": "E h:mm:ss a",
		"field-second": "",
		"field-sat-relative+-1": "  ",
		"dateFormatItem-yMMMEd": "E, d MMM y",
		"field-sun-relative+-1": "  ",
		"field-month-relative+0": "  ",
		"field-month-relative+1": "  ",
		"dateFormatItem-Ed": "ccc, d",
		"dateTimeFormats-appendItem-Timezone": "{0} {1}",
		"field-week": "",
		"dateFormat-medium": "d MMM y ''.",
		"field-year-relative+0": "  ",
		"field-week-relative+-1": "  ",
		"field-year-relative+1": "  ",
		"dayPeriods-format-narrow-pm": "PM",
		"dateTimeFormat-short": "{1}, {0}",
		"dateFormatItem-Hms": "H:mm:ss",
		"dateFormatItem-hms": "h:mm:ss a",
		"dateFormatItem-GyMMM": "LLL y G",
		"field-mon-relative+-1": "  ",
		"field-week-relative+0": "  ",
		"field-week-relative+1": "  "
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dojo/cldr/nls/fr/gregorian", (function(){return {
		"dateFormatItem-Ehm": "E h:mm a",
		"days-standAlone-short": [
			"dim.",
			"lun.",
			"mar.",
			"mer.",
			"jeu.",
			"ven.",
			"sam."
		],
		"months-format-narrow": [
			"J",
			"F",
			"M",
			"A",
			"M",
			"J",
			"J",
			"A",
			"S",
			"O",
			"N",
			"D"
		],
		"field-second-relative+0": "maintenant",
		"quarters-standAlone-narrow": [
			"1",
			"2",
			"3",
			"4"
		],
		"field-weekday": "jour de la semaine",
		"dateFormatItem-yQQQ": "QQQ y",
		"dateFormatItem-yMEd": "E d/M/y",
		"field-wed-relative+0": "ce mercredi",
		"dateFormatItem-GyMMMEd": "E d MMM y G",
		"dateFormatItem-MMMEd": "E d MMM",
		"field-wed-relative+1": "mercredi prochain",
		"eraNarrow": [
			"av. J.-C.",
			"ap. J.-C."
		],
		"field-tue-relative+-1": "mardi dernier",
		"dayPeriods-format-wide-morning": "matin",
		"days-format-short": [
			"di",
			"lu",
			"ma",
			"me",
			"je",
			"ve",
			"sa"
		],
		"dateFormat-long": "d MMMM y",
		"field-fri-relative+-1": "vendredi dernier",
		"field-wed-relative+-1": "mercredi dernier",
		"months-format-wide": [
			"janvier",
			"fvrier",
			"mars",
			"avril",
			"mai",
			"juin",
			"juillet",
			"aot",
			"septembre",
			"octobre",
			"novembre",
			"dcembre"
		],
		"dateTimeFormat-medium": "{1} {0}",
		"dayPeriods-format-wide-pm": "PM",
		"dateFormat-full": "EEEE d MMMM y",
		"field-thu-relative+-1": "jeudi dernier",
		"dateFormatItem-Md": "d/M",
		"dayPeriods-format-abbr-am": "AM",
		"dayPeriods-format-wide-noon": "midi",
		"dateFormatItem-yMd": "d/M/y",
		"dateFormatItem-yM": "M/y",
		"field-era": "re",
		"months-standAlone-wide": [
			"janvier",
			"fvrier",
			"mars",
			"avril",
			"mai",
			"juin",
			"juillet",
			"aot",
			"septembre",
			"octobre",
			"novembre",
			"dcembre"
		],
		"timeFormat-short": "HH:mm",
		"quarters-format-wide": [
			"1er trimestre",
			"2e trimestre",
			"3e trimestre",
			"4e trimestre"
		],
		"timeFormat-long": "HH:mm:ss z",
		"dateFormatItem-yMMM": "MMM y",
		"dateFormatItem-yQQQQ": "QQQQ y",
		"field-year": "anne",
		"field-hour": "heure",
		"months-format-abbr": [
			"janv.",
			"fvr.",
			"mars",
			"avr.",
			"mai",
			"juin",
			"juil.",
			"aot",
			"sept.",
			"oct.",
			"nov.",
			"dc."
		],
		"field-sat-relative+0": "ce samedi",
		"field-sat-relative+1": "samedi prochain",
		"timeFormat-full": "HH:mm:ss zzzz",
		"dayPeriods-format-narrow-morning": "matin",
		"field-day-relative+0": "aujourdhui",
		"field-day-relative+1": "demain",
		"field-thu-relative+0": "ce jeudi",
		"dateFormatItem-GyMMMd": "d MMM y G",
		"field-day-relative+2": "aprs-demain",
		"field-thu-relative+1": "jeudi prochain",
		"dateFormatItem-H": "HH 'h'",
		"months-standAlone-abbr": [
			"janv.",
			"fvr.",
			"mars",
			"avr.",
			"mai",
			"juin",
			"juil.",
			"aot",
			"sept.",
			"oct.",
			"nov.",
			"dc."
		],
		"quarters-format-abbr": [
			"T1",
			"T2",
			"T3",
			"T4"
		],
		"quarters-standAlone-wide": [
			"1er trimestre",
			"2e trimestre",
			"3e trimestre",
			"4e trimestre"
		],
		"dateFormatItem-Gy": "y G",
		"dateFormatItem-M": "L",
		"days-standAlone-wide": [
			"dimanche",
			"lundi",
			"mardi",
			"mercredi",
			"jeudi",
			"vendredi",
			"samedi"
		],
		"timeFormat-medium": "HH:mm:ss",
		"field-sun-relative+0": "ce dimanche",
		"dateFormatItem-Hm": "HH:mm",
		"quarters-standAlone-abbr": [
			"T1",
			"T2",
			"T3",
			"T4"
		],
		"field-sun-relative+1": "dimanche prochain",
		"eraAbbr": [
			"av. J.-C.",
			"ap. J.-C."
		],
		"field-minute": "minute",
		"field-dayperiod": "cadran",
		"days-standAlone-abbr": [
			"dim.",
			"lun.",
			"mar.",
			"mer.",
			"jeu.",
			"ven.",
			"sam."
		],
		"dayPeriods-format-wide-night": "soir",
		"dateFormatItem-d": "d",
		"dateFormatItem-ms": "mm:ss",
		"quarters-format-narrow": [
			"1",
			"2",
			"3",
			"4"
		],
		"field-day-relative+-1": "hier",
		"dateFormatItem-h": "h a",
		"dateTimeFormat-long": "{1} {0}",
		"field-day-relative+-2": "avant-hier",
		"dateFormatItem-MMMd": "d MMM",
		"dateFormatItem-MEd": "E d/M",
		"dateTimeFormat-full": "{1} {0}",
		"field-fri-relative+0": "ce vendredi",
		"dateFormatItem-yMMMM": "MMMM y",
		"field-fri-relative+1": "vendredi prochain",
		"field-day": "jour",
		"days-format-wide": [
			"dimanche",
			"lundi",
			"mardi",
			"mercredi",
			"jeudi",
			"vendredi",
			"samedi"
		],
		"field-zone": "fuseau horaire",
		"dateFormatItem-y": "y",
		"months-standAlone-narrow": [
			"J",
			"F",
			"M",
			"A",
			"M",
			"J",
			"J",
			"A",
			"S",
			"O",
			"N",
			"D"
		],
		"field-year-relative+-1": "lanne dernire",
		"dayPeriods-format-narrow-night": "soir",
		"field-month-relative+-1": "le mois dernier",
		"dateFormatItem-hm": "h:mm a",
		"dayPeriods-format-abbr-pm": "PM",
		"days-format-abbr": [
			"dim.",
			"lun.",
			"mar.",
			"mer.",
			"jeu.",
			"ven.",
			"sam."
		],
		"eraNames": [
			"avant Jsus-Christ",
			"aprs Jsus-Christ"
		],
		"dateFormatItem-yMMMd": "d MMM y",
		"days-format-narrow": [
			"D",
			"L",
			"M",
			"M",
			"J",
			"V",
			"S"
		],
		"days-standAlone-narrow": [
			"D",
			"L",
			"M",
			"M",
			"J",
			"V",
			"S"
		],
		"dateFormatItem-MMM": "LLL",
		"field-month": "mois",
		"field-tue-relative+0": "ce mardi",
		"field-tue-relative+1": "mardi prochain",
		"dayPeriods-format-wide-am": "AM",
		"dateFormatItem-EHm": "E HH:mm",
		"field-mon-relative+0": "ce lundi",
		"field-mon-relative+1": "lundi prochain",
		"dateFormat-short": "dd/MM/y",
		"dayPeriods-format-wide-afternoon": "aprs-midi",
		"dateFormatItem-EHms": "E HH:mm:ss",
		"dateFormatItem-Ehms": "E h:mm:ss a",
		"dayPeriods-format-narrow-noon": "midi",
		"field-second": "seconde",
		"field-sat-relative+-1": "samedi dernier",
		"dateFormatItem-yMMMEd": "E d MMM y",
		"field-sun-relative+-1": "dimanche dernier",
		"field-month-relative+0": "ce mois-ci",
		"field-month-relative+1": "le mois prochain",
		"dateFormatItem-Ed": "E d",
		"dateTimeFormats-appendItem-Timezone": "{0} {1}",
		"field-week": "semaine",
		"dateFormat-medium": "d MMM y",
		"field-year-relative+0": "cette anne",
		"field-week-relative+-1": "la semaine dernire",
		"field-year-relative+1": "lanne prochaine",
		"dayPeriods-format-narrow-pm": "p",
		"dateTimeFormat-short": "{1} {0}",
		"dateFormatItem-Hms": "HH:mm:ss",
		"dateFormatItem-hms": "h:mm:ss a",
		"dateFormatItem-GyMMM": "MMM y G",
		"field-mon-relative+-1": "lundi dernier",
		"field-week-relative+0": "cette semaine",
		"field-week-relative+1": "la semaine prochaine"
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(163), 
		__webpack_require__(162), 
		__webpack_require__(161),
		__webpack_require__(87), 
		__webpack_require__(13), 
		__webpack_require__(27), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(9), 
		__webpack_require__(79), 
		__webpack_require__(69),
		__webpack_require__(76),
		__webpack_require__(169),__webpack_require__(6),
		__webpack_require__(82),	
		__webpack_require__(99)    
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, cldrSupplemental, date, locale, stamp, dom, domClass, lang, on, has, string, _WidgetBase, _TemplatedMixin, template,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/CalendarLite", (function(){
	
	
		// module:
		//		dijit/CalendarLite
	
		var CalendarLite = declare("dijit.CalendarLite", [_WidgetBase, _TemplatedMixin], {
			// summary:
			//		Lightweight version of Calendar widget aimed towards mobile use
			//
			// description:
			//		A simple GUI for choosing a date in the context of a monthly calendar.
			//		This widget can't be used in a form because it doesn't serialize the date to an
			//		`<input>` field.  For a form element, use dijit/form/DateTextBox instead.
			//
			//		Note that the parser takes all dates attributes passed in the
			//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
			//		so that they are serializable and locale-independent.
			//
			//		Also note that this widget isn't keyboard accessible; use dijit.Calendar for that
			// example:
			//	|	var calendar = new dijit.CalendarLite({}, dojo.byId("calendarNode"));
			//
			// example:
			//	|	<div data-dojo-type="dijit/CalendarLite"></div>
	
			// Template for main calendar
			templateString: template,
	
			// Template for cell for a day of the week (ex: M)
			dowTemplateString: '<th class="dijitReset dijitCalendarDayLabelTemplate" role="columnheader" scope="col"><span class="dijitCalendarDayLabel">${d}</span></th>',
	
			// Templates for a single date (ex: 13), and for a row for a week (ex: 20 21 22 23 24 25 26)
			dateTemplateString: '<td class="dijitReset" role="gridcell" data-dojo-attach-point="dateCells"><span class="dijitCalendarDateLabel" data-dojo-attach-point="dateLabels"></span></td>',
			weekTemplateString: '<tr class="dijitReset dijitCalendarWeekTemplate" role="row">${d}${d}${d}${d}${d}${d}${d}</tr>',
	
			// value: Date
			//		The currently selected Date, initially set to invalid date to indicate no selection.
			value: new Date(""),
			// TODO: for 2.0 make this a string (ISO format) rather than a Date
	
			// datePackage: String
			//		JavaScript namespace to find calendar routines.	 If unspecified, uses Gregorian calendar routines
			//		at dojo/date and dojo/date/locale.
			datePackage: "",
			//		TODO: for 2.0, replace datePackage with dateModule and dateLocalModule attributes specifying MIDs,
			//		or alternately just get rid of this completely and tell user to use module ID remapping
			//		via require
	
			// dayWidth: String
			//		How to represent the days of the week in the calendar header. See locale
			dayWidth: "narrow",
	
			// tabIndex: String
			//		Order fields are traversed when user hits the tab key
			tabIndex: "0",
	
			// dayOffset: Integer
			//		(Optional) The first day of week override. By default the first day of week is determined
			//		for the current locale (extracted from the CLDR).
			//		Special value -1 (default value), means use locale dependent value.
			dayOffset: -1,
	
			// currentFocus: Date
			//		Date object containing the currently focused date, or the date which would be focused
			//		if the calendar itself was focused.   Also indicates which year and month to display,
			//		i.e. the current "page" the calendar is on.
			currentFocus: new Date(),
	
			// Put the summary to the node with role=grid
			_setSummaryAttr: "gridNode",
	
			baseClass: "dijitCalendar dijitCalendarLite",
	
			_isValidDate: function(/*Date*/ value){
				// summary:
				//		Runs various tests on the value, checking that it's a valid date, rather
				//		than blank or NaN.
				// tags:
				//		private
				return value && !isNaN(value) && typeof value == "object" &&
					value.toString() != this.constructor.prototype.value.toString();
			},
	
			_getValueAttr: function(){
				// summary:
				//		Support get('value')
	
				// this.value is set to 1AM, but return midnight, local time for back-compat
				var storedVal = this._get("value");
				if(storedVal && !isNaN(storedVal)){
					var value = new this.dateClassObj(storedVal);
					value.setHours(0, 0, 0, 0);
	
					// If daylight savings pushes midnight to the previous date, fix the Date
					// object to point at 1am so it will represent the correct day. See #9366
					if(value.getDate() < storedVal.getDate()){
						value = this.dateModule.add(value, "hour", 1);
					}
					return value;
				}else{
					return null;
				}
			},
	
			_setValueAttr: function(/*Date|Number*/ value, /*Boolean*/ priorityChange){
				// summary:
				//		Support set("value", ...)
				// description:
				//		Set the current date and update the UI.  If the date is disabled, the value will
				//		not change, but the display will change to the corresponding month.
				// value:
				//		Either a Date or the number of seconds since 1970.
				// tags:
				//		protected
				if(typeof value == "string"){
					value = stamp.fromISOString(value);
				}
				value = this._patchDate(value);
	
				if(this._isValidDate(value) && !this.isDisabledDate(value, this.lang)){
					this._set("value", value);
	
					// Set focus cell to the new value.   Arguably this should only happen when there isn't a current
					// focus point.   This will also repopulate the grid to new month/year if necessary.
					this.set("currentFocus", value);
	
					// Mark the selected date
					this._markSelectedDates([value]);
	
					if(this._created && (priorityChange || typeof priorityChange == "undefined")){
						this.onChange(this.get('value'));
					}
				}else{
					// clear value, and mark all dates as unselected
					this._set("value", null);
					this._markSelectedDates([]);
				}
			},
	
			_patchDate: function(/*Date|Number*/ value){
				// summary:
				//		Convert Number into Date, or copy Date object.   Then, round to nearest day,
				//		setting to 1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
				if(value){
					value = new this.dateClassObj(value);
					value.setHours(1, 0, 0, 0);
				}
				return value;
			},
	
			_setText: function(node, text){
				// summary:
				//		This just sets the content of node to the specified text.
				//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
				// tags:
				//		private
				while(node.firstChild){
					node.removeChild(node.firstChild);
				}
				node.appendChild(node.ownerDocument.createTextNode(text));
			},
	
			_populateGrid: function(){
				// summary:
				//		Fills in the calendar grid with each day (1-31).
				//		Call this on creation, when moving to a new month.
				// tags:
				//		private
	
				var month = new this.dateClassObj(this.currentFocus);
				month.setDate(1);
				month = this._patchDate(month);	// needed if currentFocus is start or end of DST, see #17033
	
				var firstDay = month.getDay(),
					daysInMonth = this.dateModule.getDaysInMonth(month),
					daysInPreviousMonth = this.dateModule.getDaysInMonth(this.dateModule.add(month, "month", -1)),
					today = new this.dateClassObj(),
					dayOffset = this.dayOffset >= 0 ? this.dayOffset : cldrSupplemental.getFirstDayOfWeek(this.lang);
				if(dayOffset > firstDay){
					dayOffset -= 7;
				}
	
				// If they didn't provide a summary, change the default summary to match with the new month
				if(!this.summary){
					var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month)
					this.gridNode.setAttribute("summary", monthNames[month.getMonth()]);
				}
	
				// Mapping from date (as specified by number returned from Date.valueOf()) to corresponding <td>
				this._date2cell = {};
	
				// Iterate through dates in the calendar and fill in date numbers and style info
				array.forEach(this.dateCells, function(template, idx){
					var i = idx + dayOffset;
					var date = new this.dateClassObj(month),
						number, clazz = "dijitCalendar", adj = 0;
	
					if(i < firstDay){
						number = daysInPreviousMonth - firstDay + i + 1;
						adj = -1;
						clazz += "Previous";
					}else if(i >= (firstDay + daysInMonth)){
						number = i - firstDay - daysInMonth + 1;
						adj = 1;
						clazz += "Next";
					}else{
						number = i - firstDay + 1;
						clazz += "Current";
					}
	
					if(adj){
						date = this.dateModule.add(date, "month", adj);
					}
					date.setDate(number);
	
					if(!this.dateModule.compare(date, today, "date")){
						clazz = "dijitCalendarCurrentDate " + clazz;
					}
	
					if(this.isDisabledDate(date, this.lang)){
						clazz = "dijitCalendarDisabledDate " + clazz;
						template.setAttribute("aria-disabled", "true");
					}else{
						clazz = "dijitCalendarEnabledDate " + clazz;
						template.removeAttribute("aria-disabled");
						template.setAttribute("aria-selected", "false");
					}
	
					var clazz2 = this.getClassForDate(date, this.lang);
					if(clazz2){
						clazz = clazz2 + " " + clazz;
					}
	
					template.className = clazz + "Month dijitCalendarDateTemplate";
	
					// Each cell has an associated integer value representing it's date
					var dateVal = date.valueOf();
					this._date2cell[dateVal] = template;
					template.dijitDateValue = dateVal;
	
					// Set Date string (ex: "13").
					this._setText(this.dateLabels[idx], date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate());
				}, this);
			},
	
			_populateControls: function(){
				// summary:
				//		Fill in localized month, and prev/current/next years
				// tags:
				//		protected
	
				var month = new this.dateClassObj(this.currentFocus);
				month.setDate(1);
	
				// set name of this month
				this.monthWidget.set("month", month);
	
				var y = month.getFullYear() - 1;
				var d = new this.dateClassObj();
				array.forEach(["previous", "current", "next"], function(name){
					d.setFullYear(y++);
					this._setText(this[name + "YearLabelNode"],
						this.dateLocaleModule.format(d, {selector: 'year', locale: this.lang}));
				}, this);
			},
	
			goToToday: function(){
				// summary:
				//		Sets calendar's value to today's date
				this.set('value', new this.dateClassObj());
			},
	
			constructor: function(params /*===== , srcNodeRef =====*/){
				// summary:
				//		Create the widget.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String?
				//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
	
				this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
				this.dateClassObj = this.dateModule.Date || Date;
				this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage + ".locale", false) : locale;
			},
	
			_createMonthWidget: function(){
				// summary:
				//		Creates the drop down button that displays the current month and lets user pick a new one
	
				return CalendarLite._MonthWidget({
					id: this.id + "_mddb",
					lang: this.lang,
					dateLocaleModule: this.dateLocaleModule
				}, this.monthNode);
			},
	
			buildRendering: function(){
				// Markup for days of the week (referenced from template)
				var d = this.dowTemplateString,
					dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang),
					dayOffset = this.dayOffset >= 0 ? this.dayOffset : cldrSupplemental.getFirstDayOfWeek(this.lang);
				this.dayCellsHtml = string.substitute([d, d, d, d, d, d, d].join(""), {d: ""}, function(){
					return dayNames[dayOffset++ % 7];
				});
	
				// Markup for dates of the month (referenced from template), but without numbers filled in
				var r = string.substitute(this.weekTemplateString, {d: this.dateTemplateString});
				this.dateRowsHtml = [r, r, r, r, r, r].join("");
	
				// Instantiate from template.
				// dateCells and dateLabels arrays filled when _Templated parses my template.
				this.dateCells = [];
				this.dateLabels = [];
				this.inherited(arguments);
	
				dom.setSelectable(this.domNode, false);
	
				var dateObj = new this.dateClassObj(this.currentFocus);
	
				this.monthWidget = this._createMonthWidget();
	
				this.set('currentFocus', dateObj, false);	// draw the grid to the month specified by currentFocus
			},
	
			postCreate: function(){
				this.inherited(arguments);
				this._connectControls();
			},
	
			_connectControls: function(){
				// summary:
				//		Set up connects for increment/decrement of months/years
				// tags:
				//		protected
	
				var connect = lang.hitch(this, function(nodeProp, part, amount){
					this[nodeProp].dojoClick = true;
					return on(this[nodeProp], "click", lang.hitch(this, function(){
						this._setCurrentFocusAttr(this.dateModule.add(this.currentFocus, part, amount));
					}));
				});
	
				this.own(
					connect("incrementMonth", "month", 1),
					connect("decrementMonth", "month", -1),
					connect("nextYearLabelNode", "year", 1),
					connect("previousYearLabelNode", "year", -1)
				);
			},
	
			_setCurrentFocusAttr: function(/*Date*/ date, /*Boolean*/ forceFocus){
				// summary:
				//		If the calendar currently has focus, then focuses specified date,
				//		changing the currently displayed month/year if necessary.
				//		If the calendar doesn't have focus, updates currently
				//		displayed month/year, and sets the cell that will get focus
				//		when Calendar is focused.
				// forceFocus:
				//		If true, will focus() the cell even if calendar itself doesn't have focus
	
				var oldFocus = this.currentFocus,
					oldCell = this._getNodeByDate(oldFocus);
				date = this._patchDate(date);
	
				this._set("currentFocus", date);
	
				// If the focus is on a different month than the current calendar month, switch the displayed month.
				// Also will populate the grid initially, on Calendar creation.
				if(!this._date2cell || this.dateModule.difference(oldFocus, date, "month") != 0){
					this._populateGrid();
					this._populateControls();
					this._markSelectedDates([this.value]);
				}
	
				// set tabIndex=0 on new cell, and focus it (but only if Calendar itself is focused)
				var newCell = this._getNodeByDate(date);
				newCell.setAttribute("tabIndex", this.tabIndex);
				if(this.focused || forceFocus){
					newCell.focus();
				}
	
				// set tabIndex=-1 on old focusable cell
				if(oldCell && oldCell != newCell){
					if(has("webkit")){    // see #11064 about webkit bug
						oldCell.setAttribute("tabIndex", "-1");
					}else{
						oldCell.removeAttribute("tabIndex");
					}
				}
			},
	
			focus: function(){
				// summary:
				//		Focus the calendar by focusing one of the calendar cells
				this._setCurrentFocusAttr(this.currentFocus, true);
			},
	
			_onDayClick: function(/*Event*/ evt){
				// summary:
				//		Handler for day clicks, selects the date if appropriate
				// tags:
				//		protected
				evt.stopPropagation();
				evt.preventDefault();
				for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode){
					;
				}
				if(node && !domClass.contains(node, "dijitCalendarDisabledDate")){
					this.set('value', node.dijitDateValue);
				}
			},
	
			_getNodeByDate: function(/*Date*/ value){
				// summary:
				//		Returns the cell corresponding to the date, or null if the date is not within the currently
				//		displayed month.
				value = this._patchDate(value);
				return value && this._date2cell ? this._date2cell[value.valueOf()] : null;
			},
	
			_markSelectedDates: function(/*Date[]*/ dates){
				// summary:
				//		Marks the specified cells as selected, and clears cells previously marked as selected.
				//		For CalendarLite at most one cell is selected at any point, but this allows an array
				//		for easy subclassing.
	
				// Function to mark a cell as selected or unselected
				function mark(/*Boolean*/ selected, /*DomNode*/ cell){
					domClass.toggle(cell, "dijitCalendarSelectedDate", selected);
					cell.setAttribute("aria-selected", selected ? "true" : "false");
				}
	
				// Clear previously selected cells.
				array.forEach(this._selectedCells || [], lang.partial(mark, false));
	
				// Mark newly selected cells.  Ignore dates outside the currently displayed month.
				this._selectedCells = array.filter(array.map(dates, this._getNodeByDate, this), function(n){
					return n;
				});
				array.forEach(this._selectedCells, lang.partial(mark, true));
			},
	
			onChange: function(/*Date*/ /*===== date =====*/){
				// summary:
				//		Called only when the selected date has changed
			},
	
			isDisabledDate: function(/*===== dateObject, locale =====*/){
				// summary:
				//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
				// dateObject: Date
				// locale: String?
				// tags:
				//		extension
				/*=====
				 return false; // Boolean
				 =====*/
			},
	
			getClassForDate: function(/*===== dateObject, locale =====*/){
				// summary:
				//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
				//		for example to indicate a holiday in specified locale.
				// dateObject: Date
				// locale: String?
				// tags:
				//		extension
	
				/*=====
				 return ""; // String
				 =====*/
			}
		});
	
		CalendarLite._MonthWidget = declare("dijit.CalendarLite._MonthWidget", _WidgetBase, {
			// summary:
			//		Displays name of current month padded to the width of the month
			//		w/the longest name, so that changing months doesn't change width.
			//
			//		Create as:
			// |	new Calendar._MonthWidget({
			// |			lang: ...,
			// |			dateLocaleModule: ...
			// |		})
	
			_setMonthAttr: function(month){
				// summary:
				//		Set the current month to display as a label
				var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month),
					spacer =
						(has("ie") == 6 ? "" : "<div class='dijitSpacer'>" +
							array.map(monthNames,function(s){
								return "<div>" + s + "</div>";
							}).join("") + "</div>");
	
				// Set name of current month and also fill in spacer element with all the month names
				// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
				// the center <TH> overlaps the right <TH> (due to a browser bug).
				this.domNode.innerHTML =
					spacer +
						"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +
						monthNames[month.getMonth()] + "</div>";
			}
		});
	
		return CalendarLite;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<div class=\"dijitCalendarContainer dijitInline\" role=\"presentation\" aria-labelledby=\"${id}_mddb ${id}_year\">\r\n\t<div class=\"dijitReset dijitCalendarMonthContainer\" role=\"presentation\">\r\n\t\t<div class='dijitReset dijitCalendarArrow dijitCalendarDecrementArrow' data-dojo-attach-point=\"decrementMonth\">\r\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"/>\r\n\t\t\t<span data-dojo-attach-point=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\r\n\t\t</div>\r\n\t\t<div class='dijitReset dijitCalendarArrow dijitCalendarIncrementArrow' data-dojo-attach-point=\"incrementMonth\">\r\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"/>\r\n\t\t\t<span data-dojo-attach-point=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\r\n\t\t</div>\r\n\t\t<div data-dojo-attach-point=\"monthNode\" class=\"dijitInline\"></div>\r\n\t</div>\r\n\t<table cellspacing=\"0\" cellpadding=\"0\" role=\"grid\" data-dojo-attach-point=\"gridNode\">\r\n\t\t<thead>\r\n\t\t\t<tr role=\"row\">\r\n\t\t\t\t${!dayCellsHtml}\r\n\t\t\t</tr>\r\n\t\t</thead>\r\n\t\t<tbody data-dojo-attach-point=\"dateRowsNode\" data-dojo-attach-event=\"ondijitclick: _onDayClick\" class=\"dijitReset dijitCalendarBodyContainer\">\r\n\t\t\t\t${!dateRowsHtml}\r\n\t\t</tbody>\r\n\t</table>\r\n\t<div class=\"dijitReset dijitCalendarYearContainer\" role=\"presentation\">\r\n\t\t<div class=\"dijitCalendarYearLabel\">\r\n\t\t\t<span data-dojo-attach-point=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\" role=\"button\"></span>\r\n\t\t\t<span data-dojo-attach-point=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" role=\"button\" id=\"${id}_year\"></span>\r\n\t\t\t<span data-dojo-attach-point=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\" role=\"button\"></span>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(2),
		__webpack_require__(8), 
		__webpack_require__(34), 
		__webpack_require__(74), 
		__webpack_require__(127), 
		__webpack_require__(114),
		__webpack_require__(103),
		__webpack_require__(146),
		__webpack_require__(171),__webpack_require__(6),
		__webpack_require__(82)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, kernel, lang, query, registry, popup, Button, _Container, _HasDropDown, template,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/DropDownButton", (function(){
	
		// module:
		//		dijit/form/DropDownButton
	
		return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {
			// summary:
			//		A button with a drop down
			//
			// example:
			// |	<button data-dojo-type="dijit/form/DropDownButton">
			// |		Hello world
			// |		<div data-dojo-type="dijit/Menu">...</div>
			// |	</button>
			//
			// example:
			// |	var button1 = new DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
			// |	win.body().appendChild(button1);
			//
	
			baseClass: "dijitDropDownButton",
	
			templateString: template,
	
			_fillContent: function(){
				// Overrides _TemplatedMixin#_fillContent().
				// My inner HTML possibly contains both the button label and/or a drop down widget, like
				// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
	
				var source = this.srcNodeRef;
				var dest = this.containerNode;
				if(source && dest){
					while(source.hasChildNodes()){
						var child = source.firstChild;
						if(child.hasAttribute && (child.hasAttribute("data-dojo-type") || child.hasAttribute("dojoType") ||
								child.hasAttribute("data-" + kernel._scopeName + "-type") ||
								child.hasAttribute(kernel._scopeName + "Type"))){
							// The parser hasn't gotten to this node yet, so save it in a wrapper <div>
							// and then grab the instantiated widget in startup().
							this.dropDownContainer = this.ownerDocument.createElement("div");
							this.dropDownContainer.appendChild(child);
						}else{
							dest.appendChild(child);
						}
					}
				}
			},
	
			startup: function(){
				if(this._started){
					return;
				}
	
				// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
				// make it invisible, and store a reference to pass to the popup code.
				if(!this.dropDown && this.dropDownContainer){
					this.dropDown = registry.byNode(this.dropDownContainer.firstChild);
					delete this.dropDownContainer;
				}
				if(this.dropDown){
					popup.hide(this.dropDown);
				}
	
				this.inherited(arguments);
			},
	
			isLoaded: function(){
				// Returns whether or not we are loaded - if our dropdown has an href,
				// then we want to check that.
				var dropDown = this.dropDown;
				return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
			},
	
			loadDropDown: function(/*Function*/ callback){
				// Default implementation assumes that drop down already exists,
				// but hasn't loaded it's data (ex: ContentPane w/href).
				// App must override if the drop down is lazy-created.
				var dropDown = this.dropDown;
				var handler = dropDown.on("load", lang.hitch(this, function(){
					handler.remove();
					callback();
				}));
				dropDown.refresh();		// tell it to load
			},
	
			isFocusable: function(){
				// Overridden so that focus is handled by the _HasDropDown mixin, not by
				// the _FormWidget mixin.
				return this.inherited(arguments) && !this._mouseDown;
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 171 */
/***/ function(module, exports) {

	module.exports = "<span class=\"dijit dijitReset dijitInline\"\r\n\t><span class='dijitReset dijitInline dijitButtonNode'\r\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" data-dojo-attach-point=\"_buttonNode\"\r\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\r\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode,_popupStateNode\"\r\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\r\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\r\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\r\n\t\t\t></span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\r\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\r\n\t\t\t\tid=\"${id}_label\"\r\n\t\t\t></span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\r\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\r\n\t\t></span\r\n\t></span\r\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\r\n\t\tdata-dojo-attach-event=\"onclick:_onClick\" data-dojo-attach-point=\"valueNode\" aria-hidden=\"true\"\r\n/></span>\r\n"

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(162), 
		__webpack_require__(161), 
		__webpack_require__(87), 
		__webpack_require__(1), 
		__webpack_require__(8), 
		__webpack_require__(173),
		__webpack_require__(146),
		__webpack_require__(183),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(date, locale, stamp, declare, lang, RangeBoundTextBox, _HasDropDown, template,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_DateTimeTextBox", (function(){
	
		// module:
		//		dijit/form/_DateTimeTextBox
	
		new Date("X"); // workaround for #11279, new Date("") == NaN
	
		var _DateTimeTextBox = declare("dijit.form._DateTimeTextBox", [RangeBoundTextBox, _HasDropDown], {
			// summary:
			//		Base class for validating, serializable, range-bound date or time text box.
	
			templateString: template,
	
			// hasDownArrow: [const] Boolean
			//		Set this textbox to display a down arrow button, to open the drop down list.
			hasDownArrow: true,
	
			// Set classes like dijitDownArrowButtonHover depending on mouse action over button node
			cssStateNodes: {
				"_buttonNode": "dijitDownArrowButton"
			},
	
			/*=====
			// constraints: _DateTimeTextBox.__Constraints
			//		Despite the name, this parameter specifies both constraints on the input
			//		(including starting/ending dates/times allowed) as well as
			//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
			//		or short (ex: 12/25/2005) format.  See `dijit/form/_DateTimeTextBox.__Constraints` for details.
			constraints: {},
			======*/
	
			// The constraints without the min/max properties. Used by the compare() method
			_unboundedConstraints: {},
	
			// Override ValidationTextBox.pattern.... we use a reg-ex generating function rather
			// than a straight regexp to deal with locale  (plus formatting options too?)
			pattern: locale.regexp,
	
			// datePackage: String
			//		JavaScript namespace to find calendar routines.	 If unspecified, uses Gregorian calendar routines
			//		at dojo/date and dojo/date/locale.
			datePackage: "",
			//		TODO: for 2.0, replace datePackage with dateModule and dateLocalModule attributes specifying MIDs,
			//		or alternately just get rid of this completely and tell user to use module ID remapping
			//		via require
	
			postMixInProperties: function(){
				this.inherited(arguments);
				this._set("type", "text"); // in case type="date"|"time" was specified which messes up parse/format
			},
	
			// Override _FormWidget.compare() to work for dates/times
			compare: function(/*Date*/ val1, /*Date*/ val2){
				var isInvalid1 = this._isInvalidDate(val1);
				var isInvalid2 = this._isInvalidDate(val2);
				if (isInvalid1 || isInvalid2){
					return (isInvalid1 && isInvalid2) ? 0 : (!isInvalid1 ? 1 : -1);
				}
				// Format and parse the values before comparing them to make sure that only the parts of the
				// date that will make the "round trip" get compared.
				var fval1 = this.format(val1, this._unboundedConstraints),
					fval2 = this.format(val2, this._unboundedConstraints),
					pval1 = this.parse(fval1, this._unboundedConstraints),
					pval2 = this.parse(fval2, this._unboundedConstraints);
	
				return fval1 == fval2 ? 0 : date.compare(pval1, pval2, this._selector);
			},
	
			// flag to _HasDropDown to make drop down Calendar width == <input> width
			autoWidth: true,
	
			format: function(/*Date*/ value, /*locale.__FormatOptions*/ constraints){
				// summary:
				//		Formats the value as a Date, according to specified locale (second argument)
				// tags:
				//		protected
				if(!value){ return ''; }
				return this.dateLocaleModule.format(value, constraints);
			},
	
			"parse": function(/*String*/ value, /*locale.__FormatOptions*/ constraints){
				// summary:
				//		Parses as string as a Date, according to constraints
				// tags:
				//		protected
	
				return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
			},
	
			// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
			serialize: function(/*anything*/ val, /*Object?*/ options){
				if(val.toGregorian){
					val = val.toGregorian();
				}
				return stamp.toISOString(val, options);
			},
	
			// dropDownDefaultValue: Date
			//		The default value to focus in the popupClass widget when the textbox value is empty.
			dropDownDefaultValue : new Date(),
	
			// value: Date
			//		The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
			//		When passed to the parser in markup, must be specified according to `dojo/date/stamp.fromISOString()`
			value: new Date(""),	// value.toString()="NaN"
	
			_blankValue: null,	// used by filter() when the textbox is blank
	
			// popupClass: [protected extension] String
			//		Name of the popup widget class used to select a date/time.
			//		Subclasses should specify this.
			popupClass: "", // default is no popup = text only
	
	
			// _selector: [protected extension] String
			//		Specifies constraints.selector passed to dojo.date functions, should be either
			//		"date" or "time".
			//		Subclass must specify this.
			_selector: "",
	
			constructor: function(params /*===== , srcNodeRef =====*/){
				// summary:
				//		Create the widget.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String?
				//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
	
				params = params || {};
				this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
				this.dateClassObj = this.dateModule.Date || Date;
				if(!(this.dateClassObj instanceof Date)){
					this.value = new this.dateClassObj(this.value);
				}
				this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage+".locale", false) : locale;
				this._set('pattern', this.dateLocaleModule.regexp);
				this._invalidDate = this.constructor.prototype.value.toString();
			},
	
			buildRendering: function(){
				this.inherited(arguments);
	
				if(!this.hasDownArrow){
					this._buttonNode.style.display = "none";
				}
	
				// If hasDownArrow is false, we basically just want to treat the whole widget as the
				// button.
				if(!this.hasDownArrow){
					this._buttonNode = this.domNode;
					this.baseClass += " dijitComboBoxOpenOnClick";
				}
			},
	
			_setConstraintsAttr: function(/*Object*/ constraints){
				constraints.selector = this._selector;
				constraints.fullYear = true; // see #5465 - always format with 4-digit years
				var fromISO = stamp.fromISOString;
				if(typeof constraints.min == "string"){
					constraints.min = fromISO(constraints.min);
					if(!(this.dateClassObj instanceof Date)){
						constraints.min = new this.dateClassObj(constraints.min);
					}
				}
				if(typeof constraints.max == "string"){
					constraints.max = fromISO(constraints.max);
					if(!(this.dateClassObj instanceof Date)){
						constraints.max = new this.dateClassObj(constraints.max);
					}
				}
				this.inherited(arguments);
				this._unboundedConstraints = lang.mixin({}, this.constraints, {min: null, max: null});
			},
	
			_isInvalidDate: function(/*Date*/ value){
				// summary:
				//		Runs various tests on the value, checking for invalid conditions
				// tags:
				//		private
				return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
			},
	
			_setValueAttr: function(/*Date|String*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
				// summary:
				//		Sets the date on this textbox. Note: value can be a JavaScript Date literal or a string to be parsed.
				if(value !== undefined){
					if(typeof value == "string"){
						value = stamp.fromISOString(value);
					}
					if(this._isInvalidDate(value)){
						value = null;
					}
					if(value instanceof Date && !(this.dateClassObj instanceof Date)){
						value = new this.dateClassObj(value);
					}
				}
				this.inherited(arguments, [value, priorityChange, formattedValue]);
				if(this.value instanceof Date){
					this.filterString = "";
				}
	
				// Set the dropdown's value to match, unless we are being updated due to the user navigating the TimeTextBox
				// dropdown via up/down arrow keys.
				if(priorityChange !== false && this.dropDown){
					this.dropDown.set('value', value, false);
				}
			},
	
			_set: function(attr, value){
				// Avoid spurious watch() notifications when value is changed to new Date object w/the same value
				if(attr == "value"){
					if(value instanceof Date && !(this.dateClassObj instanceof Date)){
						value = new this.dateClassObj(value);
					}
					var oldValue = this._get("value");
					if(oldValue instanceof this.dateClassObj && this.compare(value, oldValue) == 0){
						return;
					}
				}
				this.inherited(arguments);
			},
	
			_setDropDownDefaultValueAttr: function(/*Date*/ val){
				if(this._isInvalidDate(val)){
					// convert null setting into today's date, since there needs to be *some* default at all times.
					 val = new this.dateClassObj();
				}
				this._set("dropDownDefaultValue", val);
			},
	
			openDropDown: function(/*Function*/ callback){
				// rebuild drop down every time, so that constraints get copied (#6002)
				if(this.dropDown){
					this.dropDown.destroy();
				}
				var PopupProto = lang.isString(this.popupClass) ? lang.getObject(this.popupClass, false) : this.popupClass,
					textBox = this,
					value = this.get("value");
				this.dropDown = new PopupProto({
					onChange: function(value){
						// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
						textBox.set('value', value, true);
					},
					id: this.id + "_popup",
					dir: textBox.dir,
					lang: textBox.lang,
					value: value,
					textDir: textBox.textDir,
					currentFocus: !this._isInvalidDate(value) ? value : this.dropDownDefaultValue,
					constraints: textBox.constraints,
					filterString: textBox.filterString, // for TimeTextBox, to filter times shown
					datePackage: textBox.datePackage,
					isDisabledDate: function(/*Date*/ date){
						// summary:
						//		disables dates outside of the min/max of the _DateTimeTextBox
						return !textBox.rangeCheck(date, textBox.constraints);
					}
				});
	
				this.inherited(arguments);
			},
	
			_getDisplayedValueAttr: function(){
				return this.textbox.value;
			},
	
			_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
				this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
			}
		});
	
	
		/*=====
		 _DateTimeTextBox.__Constraints = declare([RangeBoundTextBox.__Constraints, locale.__FormatOptions], {
			 // summary:
			 //		Specifies both the rules on valid/invalid values (first/last date/time allowed),
			 //		and also formatting options for how the date/time is displayed.
			 // example:
			 //		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
			 //	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
		 });
		 =====*/
	
		return _DateTimeTextBox;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(121), 
		__webpack_require__(174),__webpack_require__(6),
		__webpack_require__(180)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, i18n, MappedTextBox,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/RangeBoundTextBox", (function(){
	
		// module:
		//		dijit/form/RangeBoundTextBox
	
	
		var RangeBoundTextBox = declare("dijit.form.RangeBoundTextBox", MappedTextBox, {
			// summary:
			//		Base class for textbox form widgets which defines a range of valid values.
	
			// rangeMessage: String
			//		The message to display if value is out-of-range
			rangeMessage: "",
	
			/*=====
			// constraints: RangeBoundTextBox.__Constraints
			constraints: {},
			======*/
	
			rangeCheck: function(/*Number*/ primitive, /*dijit/form/RangeBoundTextBox.__Constraints*/ constraints){
				// summary:
				//		Overridable function used to validate the range of the numeric input value.
				// tags:
				//		protected
				return	("min" in constraints? (this.compare(primitive,constraints.min) >= 0) : true) &&
					("max" in constraints? (this.compare(primitive,constraints.max) <= 0) : true); // Boolean
			},
	
			isInRange: function(/*Boolean*/ /*===== isFocused =====*/){
				// summary:
				//		Tests if the value is in the min/max range specified in constraints
				// tags:
				//		protected
				return this.rangeCheck(this.get('value'), this.constraints);
			},
	
			_isDefinitelyOutOfRange: function(){
				// summary:
				//		Returns true if the value is out of range and will remain
				//		out of range even if the user types more characters
				var val = this.get('value');
				if(val == null){ return false; } // not yet valid enough to compare to
				var outOfRange = false;
				if("min" in this.constraints){
					var min = this.constraints.min;
					outOfRange = this.compare(val, ((typeof min == "number") && min >= 0 && val != 0) ? 0 : min) < 0;
				}
				if(!outOfRange && ("max" in this.constraints)){
					var max = this.constraints.max;
					outOfRange = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0) > 0;
				}
				return outOfRange;
			},
	
			_isValidSubset: function(){
				// summary:
				//		Overrides `dijit/form/ValidationTextBox._isValidSubset()`.
				//		Returns true if the input is syntactically valid, and either within
				//		range or could be made in range by more typing.
				return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
			},
	
			isValid: function(/*Boolean*/ isFocused){
				// Overrides dijit/form/ValidationTextBox.isValid() to check that the value is also in range.
				return this.inherited(arguments) &&
					((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused)); // Boolean
			},
	
			getErrorMessage: function(/*Boolean*/ isFocused){
				// Overrides dijit/form/ValidationTextBox.getErrorMessage() to print "out of range" message if appropriate
				var v = this.get('value');
				if(v != null /* and !undefined */ && v !== '' && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)){ // don't check isInRange w/o a real value
					return this.rangeMessage; // String
				}
				return this.inherited(arguments);
			},
	
			postMixInProperties: function(){
				this.inherited(arguments);
				if(!this.rangeMessage){
					this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
					this.rangeMessage = this.messages.rangeMessage;
				}
			}
		});
		/*=====
		RangeBoundTextBox.__Constraints = declare(null, {
			// min: Number
			//		Minimum signed value.  Default is -Infinity
			// max: Number
			//		Maximum signed value.  Default is +Infinity
		});
		=====*/
		return RangeBoundTextBox;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(9), 
		__webpack_require__(11), 
		__webpack_require__(175),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, has, domConstruct, ValidationTextBox,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/MappedTextBox", (function(){
	
		// module:
		//		dijit/form/MappedTextBox
	
		return declare("dijit.form.MappedTextBox", ValidationTextBox, {
			// summary:
			//		A dijit/form/ValidationTextBox subclass which provides a base class for widgets that have
			//		a visible formatted display value, and a serializable
			//		value in a hidden input field which is actually sent to the server.
			// description:
			//		The visible display may
			//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
			//		input field which uses the `name` attribute declared by the original widget.  That value sent
			//		to the server is defined by the dijit/form/MappedTextBox.serialize() method and is typically
			//		locale-neutral.
			// tags:
			//		protected
	
			postMixInProperties: function(){
				this.inherited(arguments);
	
				// We want the name attribute to go to the hidden <input>, not the displayed <input>,
				// so override _FormWidget.postMixInProperties() setting of nameAttrSetting for IE.
				this.nameAttrSetting = "";
			},
	
			// Remap name attribute to be mapped to hidden node created in buildRendering(), rather than this.focusNode
			_setNameAttr: "valueNode",
	
			serialize: function(val /*=====, options =====*/){
				// summary:
				//		Overridable function used to convert the get('value') result to a canonical
				//		(non-localized) string.  For example, will print dates in ISO format, and
				//		numbers the same way as they are represented in javascript.
				// val: anything
				// options: Object?
				// tags:
				//		protected extension
				return val.toString ? val.toString() : ""; // String
			},
	
			toString: function(){
				// summary:
				//		Returns widget as a printable string using the widget's value
				// tags:
				//		protected
				var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
				return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
			},
	
			validate: function(){
				// Overrides `dijit/form/TextBox.validate`
				this.valueNode.value = this.toString();
				return this.inherited(arguments);
			},
	
			buildRendering: function(){
				// Overrides `dijit/_TemplatedMixin/buildRendering`
	
				this.inherited(arguments);
	
				// Create a hidden <input> node with the serialized value used for submit
				// (as opposed to the displayed value).
				// Passing in name as markup rather than relying on _setNameAttr custom setter above
				// to make query(input[name=...]) work on IE. (see #8660).
				// But not doing that for Windows 8 Store apps because it causes a security exception (see #16452).
				this.valueNode = domConstruct.place("<input type='hidden'" +
					((this.name && !has("msapp")) ? ' name="' + this.name.replace(/"/g, "&quot;") + '"' : "") + "/>",
					this.textbox, "after");
			},
	
			reset: function(){
				// Overrides `dijit/form/ValidationTextBox.reset` to
				// reset the hidden textbox value to ''
				this.valueNode.value = '';
				this.inherited(arguments);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(2), 
		__webpack_require__(8),
		__webpack_require__(121), 
		__webpack_require__(154),
		__webpack_require__(176),
		__webpack_require__(179),__webpack_require__(6),
		__webpack_require__(180)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, kernel, lang, i18n, TextBox, Tooltip, template,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/ValidationTextBox", (function(){
	
		// module:
		//		dijit/form/ValidationTextBox
	
	
		var ValidationTextBox = declare("dijit.form.ValidationTextBox", TextBox, {
			// summary:
			//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
	
			templateString: template,
	
			// required: Boolean
			//		User is required to enter data into this field.
			required: false,
	
			// promptMessage: String
			//		If defined, display this hint string immediately on focus to the textbox, if empty.
			//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
			//		Think of this like a tooltip that tells the user what to do, not an error message
			//		that tells the user what they've done wrong.
			//
			//		Message disappears when user starts typing.
			promptMessage: "",
	
			// invalidMessage: String
			//		The message to display if value is invalid.
			//		The translated string value is read from the message file by default.
			//		Set to "" to use the promptMessage instead.
			invalidMessage: "$_unset_$",
	
			// missingMessage: String
			//		The message to display if value is empty and the field is required.
			//		The translated string value is read from the message file by default.
			//		Set to "" to use the invalidMessage instead.
			missingMessage: "$_unset_$",
	
			// message: String
			//		Currently error/prompt message.
			//		When using the default tooltip implementation, this will only be
			//		displayed when the field is focused.
			message: "",
	
			// constraints: ValidationTextBox.__Constraints
			//		Despite the name, this parameter specifies both constraints on the input as well as
			//		formatting options.  See `dijit/form/ValidationTextBox.__Constraints` for details.
			constraints:{},
	
			// pattern: [extension protected] String|Function(constraints) returning a string.
			//		This defines the regular expression used to validate the input.
			//		Do not add leading ^ or $ characters since the widget adds these.
			//		A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
			//		set('pattern', String|Function).
			pattern: ".*",
	
			// regExp: Deprecated [extension protected] String.  Use "pattern" instead.
			regExp: "",
	
			regExpGen: function(/*__Constraints*/ /*===== constraints =====*/){
				// summary:
				//		Deprecated.  Use set('pattern', Function) instead.
			},
	
			// state: [readonly] String
			//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
			state: "",
	
			// tooltipPosition: String[]
			//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
			tooltipPosition: [],
	
			_deprecateRegExp: function(attr, value){
				if(value != ValidationTextBox.prototype[attr]){
					kernel.deprecated("ValidationTextBox id="+this.id+", set('" + attr + "', ...) is deprecated.  Use set('pattern', ...) instead.", "", "2.0");
					this.set('pattern', value);
				}
			},
			_setRegExpGenAttr: function(/*Function*/ newFcn){
				this._deprecateRegExp("regExpGen", newFcn);
				this._set("regExpGen", this._computeRegexp); // backward compat with this.regExpGen(this.constraints)
			},
			_setRegExpAttr: function(/*String*/ value){
				this._deprecateRegExp("regExp", value);
			},
	
			_setValueAttr: function(){
				// summary:
				//		Hook so set('value', ...) works.
				this.inherited(arguments);
				this._refreshState();
			},
	
			validator: function(/*anything*/ value, /*__Constraints*/ constraints){
				// summary:
				//		Overridable function used to validate the text input against the regular expression.
				// tags:
				//		protected
				return (new RegExp("^(?:" + this._computeRegexp(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
					(!this.required || !this._isEmpty(value)) &&
					(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
			},
	
			_isValidSubset: function(){
				// summary:
				//		Returns true if the value is either already valid or could be made valid by appending characters.
				//		This is used for validation while the user [may be] still typing.
				return this.textbox.value.search(this._partialre) == 0;
			},
	
			isValid: function(/*Boolean*/ /*===== isFocused =====*/){
				// summary:
				//		Tests if value is valid.
				//		Can override with your own routine in a subclass.
				// tags:
				//		protected
				return this.validator(this.textbox.value, this.get('constraints'));
			},
	
			_isEmpty: function(value){
				// summary:
				//		Checks for whitespace
				return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
			},
	
			getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
				// summary:
				//		Return an error message to show if appropriate
				// tags:
				//		protected
				var invalid = this.invalidMessage == "$_unset_$" ? this.messages.invalidMessage :
					!this.invalidMessage ? this.promptMessage : this.invalidMessage;
				var missing = this.missingMessage == "$_unset_$" ? this.messages.missingMessage :
					!this.missingMessage ? invalid : this.missingMessage;
				return (this.required && this._isEmpty(this.textbox.value)) ? missing : invalid; // String
			},
	
			getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
				// summary:
				//		Return a hint message to show when widget is first focused
				// tags:
				//		protected
				return this.promptMessage; // String
			},
	
			_maskValidSubsetError: true,
			validate: function(/*Boolean*/ isFocused){
				// summary:
				//		Called by oninit, onblur, and onkeypress.
				// description:
				//		Show missing or invalid messages if appropriate, and highlight textbox field.
				// tags:
				//		protected
				var message = "";
				var isValid = this.disabled || this.isValid(isFocused);
				if(isValid){ this._maskValidSubsetError = true; }
				var isEmpty = this._isEmpty(this.textbox.value);
				var isValidSubset = !isValid && isFocused && this._isValidSubset();
				this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && (this._maskValidSubsetError || (isValidSubset && !this._hasBeenBlurred && isFocused))) ? "Incomplete" : "Error"));
				this.focusNode.setAttribute("aria-invalid", this.state == "Error" ? "true" : "false");
	
				if(this.state == "Error"){
					this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
					message = this.getErrorMessage(isFocused);
				}else if(this.state == "Incomplete"){
					message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
					this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
				}else if(isEmpty){
					message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
				}
				this.set("message", message);
	
				return isValid;
			},
	
			displayMessage: function(/*String*/ message){
				// summary:
				//		Overridable method to display validation errors/hints.
				//		By default uses a tooltip.
				// tags:
				//		extension
				if(message && this.focused){
					Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
				}else{
					Tooltip.hide(this.domNode);
				}
			},
	
			_refreshState: function(){
				// Overrides TextBox._refreshState()
				if(this._created){ // should instead be this._started but that would require all programmatic ValidationTextBox instantiations to call startup()
					this.validate(this.focused);
				}
				this.inherited(arguments);
			},
	
			//////////// INITIALIZATION METHODS ///////////////////////////////////////
	
			constructor: function(params /*===== , srcNodeRef =====*/){
				// summary:
				//		Create the widget.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String?
				//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.
	
				this.constraints = lang.clone(this.constraints);
				this.baseClass += ' dijitValidationTextBox';
			},
	
			startup: function(){
				this.inherited(arguments);
				this._refreshState(); // after all _set* methods have run
			},
	
			_setConstraintsAttr: function(/*__Constraints*/ constraints){
				if(!constraints.locale && this.lang){
					constraints.locale = this.lang;
				}
				this._set("constraints", constraints);
				this._refreshState();
			},
	
			_setPatternAttr: function(/*String|Function*/ pattern){
				this._set("pattern", pattern); // don't set on INPUT to avoid native HTML5 validation
				this._refreshState();
			},
	
			_computeRegexp: function(/*__Constraints*/ constraints){
				// summary:
				//		Hook to get the current regExp and to compute the partial validation RE.
	
				var p = this.pattern;
				if(typeof p == "function"){
					p = p.call(this, constraints);
				}
				if(p != this._lastRegExp){
					var partialre = "";
					this._lastRegExp = p;
					// parse the regexp and produce a new regexp that matches valid subsets
					// if the regexp is .* then there's no use in matching subsets since everything is valid
					if(p != ".*"){
						p.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
						function(re){
							switch(re.charAt(0)){
								case '{':
								case '+':
								case '?':
								case '*':
								case '^':
								case '$':
								case '|':
								case '(':
									partialre += re;
									break;
								case ")":
									partialre += "|$)";
									break;
								 default:
									partialre += "(?:"+re+"|$)";
									break;
							}
						});
					}
					try{ // this is needed for now since the above regexp parsing needs more test verification
						"".search(partialre);
					}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
						partialre = this.pattern;
						console.warn('RegExp error in ' + this.declaredClass + ': ' + this.pattern);
					} // should never be here unless the original RE is bad or the parsing is bad
					this._partialre = "^(?:" + partialre + ")$";
				}
				return p;
			},
	
			postMixInProperties: function(){
				this.inherited(arguments);
				this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
				this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
			},
	
			_setDisabledAttr: function(/*Boolean*/ value){
				this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
				this._refreshState();
			},
	
			_setRequiredAttr: function(/*Boolean*/ value){
				this._set("required", value);
				this.focusNode.setAttribute("aria-required", value);
				this._refreshState();
			},
	
			_setMessageAttr: function(/*String*/ message){
				this._set("message", message);
				this.displayMessage(message);
			},
	
			reset:function(){
				// Overrides dijit/form/TextBox.reset() by also
				// hiding errors about partial matches
				this._maskValidSubsetError = true;
				this.inherited(arguments);
			},
	
			_onBlur: function(){
				// the message still exists but for back-compat, and to erase the tooltip
				// (if the message is being displayed as a tooltip), call displayMessage('')
				this.displayMessage('');
	
				this.inherited(arguments);
			},
	
			destroy: function(){
				Tooltip.hide(this.domNode);	// in case tooltip show when ValidationTextBox (or enclosing Dialog) destroyed
				this.inherited(arguments);
			}
		});
	
		/*=====
		 ValidationTextBox.__Constraints = {
			 // locale: String
			 //		locale used for validation, picks up value from this widget's lang attribute
			 // _flags_: anything
			 //		various flags passed to pattern function
		 };
		 =====*/
	
		return ValidationTextBox;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(142), 
		__webpack_require__(13), 
		__webpack_require__(27), 
		__webpack_require__(23), 
		__webpack_require__(15), 
		__webpack_require__(8), 
		__webpack_require__(24),
		__webpack_require__(18),
		__webpack_require__(9), 
		__webpack_require__(177),	
		__webpack_require__(128),
		__webpack_require__(96),
		__webpack_require__(76),
		__webpack_require__(129),
		__webpack_require__(178),
		__webpack_require__(75),__webpack_require__(6)		
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has,
				manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/Tooltip", (function(){
	
		// module:
		//		dijit/Tooltip
	
	
		// TODO: Tooltip should really share more positioning code with TooltipDialog, like:
		//		- the orient() method
		//		- the connector positioning code in show()
		//		- the dijitTooltip[Dialog] class
		//
		// The problem is that Tooltip's implementation supplies it's own <iframe> and interacts directly
		// with dijit/place, rather than going through dijit/popup like TooltipDialog and other popups (ex: Menu).
	
		var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
			// summary:
			//		Internal widget that holds the actual tooltip markup,
			//		which occurs once per page.
			//		Called by Tooltip widgets which are just containers to hold
			//		the markup
			// tags:
			//		protected
	
			// duration: Integer
			//		Milliseconds to fade in/fade out
			duration: manager.defaultDuration,
	
			templateString: template,
	
			postCreate: function(){
				this.ownerDocumentBody.appendChild(this.domNode);
	
				this.bgIframe = new BackgroundIframe(this.domNode);
	
				// Setup fade-in and fade-out functions.
				this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
				this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
			},
	
			show: function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
				// summary:
				//		Display tooltip w/specified contents to right of specified node
				//		(To left if there's no space on the right, or if rtl == true)
				// innerHTML: String
				//		Contents of the tooltip
				// aroundNode: DomNode|dijit/place.__Rectangle
				//		Specifies that tooltip should be next to this node / area
				// position: String[]?
				//		List of positions to try to position tooltip (ex: ["right", "above"])
				// rtl: Boolean?
				//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
				//		means "rtl"; specifies GUI direction, not text direction.
				// textDir: String?
				//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
				// onMouseEnter: Function?
				//		Callback function for mouse enter on tooltip
				// onMouseLeave: Function?
				//		Callback function for mouse leave on tooltip
	
				if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
					return;
				}
	
				if(this.fadeOut.status() == "playing"){
					// previous tooltip is being hidden; wait until the hide completes then show new one
					this._onDeck=arguments;
					return;
				}
				this.containerNode.innerHTML=innerHTML;
	
				if(textDir){
					this.set("textDir", textDir);
				}
	
				this.containerNode.align = rtl? "right" : "left"; //fix the text alignment
	
				var pos = place.around(this.domNode, aroundNode,
					position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));
	
				// Position the tooltip connector for middle alignment.
				// This could not have been done in orient() since the tooltip wasn't positioned at that time.
				var aroundNodeCoords = pos.aroundNodePos;
				if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
					this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
					this.connectorNode.style.left = "";
				}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
					this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
				}else{
					// Not *-centered, but just above/below/after/before
					this.connectorNode.style.left = "";
					this.connectorNode.style.top = "";
				}
	
				// show it
				domStyle.set(this.domNode, "opacity", 0);
				this.fadeIn.play();
				this.isShowingNow = true;
				this.aroundNode = aroundNode;
	
				this.onMouseEnter = onMouseEnter || noop;
				this.onMouseLeave = onMouseLeave || noop;
			},
	
			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
				// summary:
				//		Private function to set CSS for tooltip node based on which position it's in.
				//		This is called by the dijit popup code.   It will also reduce the tooltip's
				//		width to whatever width is available
				// tags:
				//		protected
	
				this.connectorNode.style.top = ""; //reset to default
	
				var heightAvailable = spaceAvailable.h,
					widthAvailable = spaceAvailable.w;
	
				node.className = "dijitTooltip " +
					{
						"MR-ML": "dijitTooltipRight",
						"ML-MR": "dijitTooltipLeft",
						"TM-BM": "dijitTooltipAbove",
						"BM-TM": "dijitTooltipBelow",
						"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
						"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
						"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
						"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
						"BR-BL": "dijitTooltipRight",
						"BL-BR": "dijitTooltipLeft"
					}[aroundCorner + "-" + tooltipCorner];
	
				// reset width; it may have been set by orient() on a previous tooltip show()
				this.domNode.style.width = "auto";
	
				// Reduce tooltip's width to the amount of width available, so that it doesn't overflow screen.
				// Note that sometimes widthAvailable is negative, but we guard against setting style.width to a
				// negative number since that causes an exception on IE.
				var size = domGeometry.position(this.domNode);
				if(has("ie") || has("trident")){
					// workaround strange IE bug where setting width to offsetWidth causes words to wrap
					size.w += 2;
				}
	
				var width = Math.min((Math.max(widthAvailable,1)), size.w);
	
				domGeometry.setMarginBox(this.domNode, {w: width});
	
				// Reposition the tooltip connector.
				if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
					var bb = domGeometry.position(node);
					var tooltipConnectorHeight = this.connectorNode.offsetHeight;
					if(bb.h > heightAvailable){
						// The tooltip starts at the top of the page and will extend past the aroundNode
						var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
						this.connectorNode.style.top = aroundNodePlacement + "px";
						this.connectorNode.style.bottom = "";
					}else{
						// Align center of connector with center of aroundNode, except don't let bottom
						// of connector extend below bottom of tooltip content, or top of connector
						// extend past top of tooltip content
						this.connectorNode.style.bottom = Math.min(
							Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
							bb.h - tooltipConnectorHeight) + "px";
						this.connectorNode.style.top = "";
					}
				}else{
					// reset the tooltip back to the defaults
					this.connectorNode.style.top = "";
					this.connectorNode.style.bottom = "";
				}
	
				return Math.max(0, size.w - widthAvailable);
			},
	
			_onShow: function(){
				// summary:
				//		Called at end of fade-in operation
				// tags:
				//		protected
				if(has("ie")){
					// the arrow won't show up on a node w/an opacity filter
					this.domNode.style.filter="";
				}
			},
	
			hide: function(aroundNode){
				// summary:
				//		Hide the tooltip
	
				if(this._onDeck && this._onDeck[1] == aroundNode){
					// this hide request is for a show() that hasn't even started yet;
					// just cancel the pending show()
					this._onDeck=null;
				}else if(this.aroundNode === aroundNode){
					// this hide request is for the currently displayed tooltip
					this.fadeIn.stop();
					this.isShowingNow = false;
					this.aroundNode = null;
					this.fadeOut.play();
				}else{
					// just ignore the call, it's for a tooltip that has already been erased
				}
	
				this.onMouseEnter = this.onMouseLeave = noop;
			},
	
			_onHide: function(){
				// summary:
				//		Called at end of fade-out operation
				// tags:
				//		protected
	
				this.domNode.style.cssText="";	// to position offscreen again
				this.containerNode.innerHTML="";
				if(this._onDeck){
					// a show request has been queued up; do it now
					this.show.apply(this, this._onDeck);
					this._onDeck=null;
				}
			}
		});
	
		if(has("dojo-bidi")){
			MasterTooltip.extend({
				_setAutoTextDir: function(/*Object*/node){
					// summary:
					//		Resolve "auto" text direction for children nodes
					// tags:
					//		private
	
					this.applyTextDir(node);
					array.forEach(node.children, function(child){ this._setAutoTextDir(child); }, this);
				},
	
				_setTextDirAttr: function(/*String*/ textDir){
					// summary:
					//		Setter for textDir.
					// description:
					//		Users shouldn't call this function; they should be calling
					//		set('textDir', value)
					// tags:
					//		private
	
					this._set("textDir", textDir);
	
					if (textDir == "auto"){
						this._setAutoTextDir(this.containerNode);
					}else{
						this.containerNode.dir = this.textDir;
					}
				}
			});
		}
	
		dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
			// summary:
			//		Static method to display tooltip w/specified contents in specified position.
			//		See description of dijit/Tooltip.defaultPosition for details on position parameter.
			//		If position is not specified then dijit/Tooltip.defaultPosition is used.
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: place.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
			// onMouseEnter: Function?
			//		Callback function for mouse over on tooltip
			// onMouseLeave: Function?
			//		Callback function for mouse leave on tooltip
	
			// After/before don't work, but for back-compat convert them to the working after-centered, before-centered.
			// Possibly remove this in 2.0.   Alternately, get before/after to work.
			if(position){
				position = array.map(position, function(val){
					return {after: "after-centered", before: "before-centered"}[val] || val;
				});
			}
	
			if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
			return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave);
		};
	
		dijit.hideTooltip = function(aroundNode){
			// summary:
			//		Static method to hide the tooltip displayed via showTooltip()
			return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
		};
	
		// Possible states for a tooltip, see Tooltip.state property for definitions
		var DORMANT = "DORMANT",
			SHOW_TIMER = "SHOW TIMER",
			SHOWING = "SHOWING",
			HIDE_TIMER = "HIDE TIMER";
	
		function noop(){}
	
		var Tooltip = declare("dijit.Tooltip", _Widget, {
			// summary:
			//		Pops up a tooltip (a help message) when you hover over a node.
			//		Also provides static show() and hide() methods that can be used without instantiating a dijit/Tooltip.
	
			// label: String
			//		HTML to display in the tooltip.
			//		Specified as innerHTML when creating the widget from markup.
			label: "",
	
			// showDelay: Integer
			//		Number of milliseconds to wait after hovering over/focusing on the object, before
			//		the tooltip is displayed.
			showDelay: 400,
	
			// hideDelay: Integer
			//		Number of milliseconds to wait after unhovering the object, before
			//		the tooltip is hidden.  Note that blurring an object hides the tooltip immediately.
			hideDelay: 400,
	
			// connectId: String|String[]|DomNode|DomNode[]
			//		Id of domNode(s) to attach the tooltip to.
			//		When user hovers over specified dom node(s), the tooltip will appear.
			connectId: [],
	
			// position: String[]
			//		See description of `dijit/Tooltip.defaultPosition` for details on position parameter.
			position: [],
	
			// selector: String?
			//		CSS expression to apply this Tooltip to descendants of connectIds, rather than to
			//		the nodes specified by connectIds themselves.    Useful for applying a Tooltip to
			//		a range of rows in a table, tree, etc.   Use in conjunction with getContent() parameter.
			//		Ex: connectId: myTable, selector: "tr", getContent: function(node){ return ...; }
			//
			//		The application must require() an appropriate level of dojo/query to handle the selector.
			selector: "",
	
			// TODO: in 2.0 remove support for multiple connectIds.   selector gives the same effect.
			// So, change connectId to a "", remove addTarget()/removeTarget(), etc.
	
			_setConnectIdAttr: function(/*String|String[]|DomNode|DomNode[]*/ newId){
				// summary:
				//		Connect to specified node(s)
	
				// Remove connections to old nodes (if there are any)
				array.forEach(this._connections || [], function(nested){
					array.forEach(nested, function(handle){ handle.remove(); });
				}, this);
	
				// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
				this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
						function(id){ return dom.byId(id, this.ownerDocument); }, this);
	
				// Make connections
				this._connections = array.map(this._connectIds, function(id){
					var node = dom.byId(id, this.ownerDocument),
						selector = this.selector,
						delegatedEvent = selector ?
							function(eventType){ return on.selector(selector, eventType); } :
							function(eventType){ return eventType; },
						self = this;
					return [
						on(node, delegatedEvent(mouse.enter), function(){
							self._onHover(this);
						}),
						on(node, delegatedEvent("focusin"), function(){
							self._onHover(this);
						}),
						on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")),
						on(node, delegatedEvent("focusout"), lang.hitch(self, "set", "state", DORMANT))
					];
				}, this);
	
				this._set("connectId", newId);
			},
	
			addTarget: function(/*DomNode|String*/ node){
				// summary:
				//		Attach tooltip to specified node if it's not already connected
	
				// TODO: remove in 2.0 and just use set("connectId", ...) interface
	
				var id = node.id || node;
				if(array.indexOf(this._connectIds, id) == -1){
					this.set("connectId", this._connectIds.concat(id));
				}
			},
	
			removeTarget: function(/*DomNode|String*/ node){
				// summary:
				//		Detach tooltip from specified node
	
				// TODO: remove in 2.0 and just use set("connectId", ...) interface
	
				var id = node.id || node,	// map from DOMNode back to plain id string
					idx = array.indexOf(this._connectIds, id);
				if(idx >= 0){
					// remove id (modifies original this._connectIds but that's OK in this case)
					this._connectIds.splice(idx, 1);
					this.set("connectId", this._connectIds);
				}
			},
	
			buildRendering: function(){
				this.inherited(arguments);
				domClass.add(this.domNode,"dijitTooltipData");
			},
	
			startup: function(){
				this.inherited(arguments);
	
				// If this tooltip was created in a template, or for some other reason the specified connectId[s]
				// didn't exist during the widget's initialization, then connect now.
				var ids = this.connectId;
				array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
			},
	
			getContent: function(/*DomNode*/ node){
				// summary:
				//		User overridable function that return the text to display in the tooltip.
				// tags:
				//		extension
				return this.label || this.domNode.innerHTML;
			},
	
			// state: [private readonly] String
			//		One of:
			//
			//		- DORMANT: tooltip not SHOWING
			//		- SHOW TIMER: tooltip not SHOWING but timer set to show it
			//		- SHOWING: tooltip displayed
			//		- HIDE TIMER: tooltip displayed, but timer set to hide it
			state: DORMANT,
			_setStateAttr: function(val){
				if(this.state == val ||
					(val == SHOW_TIMER && this.state == SHOWING) ||
					(val == HIDE_TIMER && this.state == DORMANT)){
					return;
				}
	
				if(this._hideTimer){
					this._hideTimer.remove();
					delete this._hideTimer;
				}
				if(this._showTimer){
					this._showTimer.remove();
					delete this._showTimer;
				}
	
				switch(val){
					case DORMANT:
						if(this._connectNode){
							Tooltip.hide(this._connectNode);
							delete this._connectNode;
							this.onHide();
						}
						break;
					case SHOW_TIMER:	 // set timer to show tooltip
						// should only get here from a DORMANT state, i.e. tooltip can't be already SHOWING
						if(this.state != SHOWING){
							this._showTimer = this.defer(function(){ this.set("state", SHOWING); }, this.showDelay);
						}
						break;
					case SHOWING:		// show tooltip and clear timers
						var content = this.getContent(this._connectNode);
						if(!content){
							this.set("state", DORMANT);
							return;
						}
	
						// Show tooltip and setup callbacks for mouseenter/mouseleave of tooltip itself
						Tooltip.show(content, this._connectNode, this.position, !this.isLeftToRight(), this.textDir,
							lang.hitch(this, "set", "state", SHOWING), lang.hitch(this, "set", "state", HIDE_TIMER));
	
						this.onShow(this._connectNode, this.position);
						break;
					case HIDE_TIMER:	// set timer set to hide tooltip
						this._hideTimer = this.defer(function(){ this.set("state", DORMANT); }, this.hideDelay);
						break;
				}
	
				this._set("state", val);
			},
	
			_onHover: function(/*DomNode*/ target){
				// summary:
				//		Despite the name of this method, it actually handles both hover and focus
				//		events on the target node, setting a timer to show the tooltip.
				// tags:
				//		private
	
				if(this._connectNode && target != this._connectNode){
					// Tooltip is displaying for another node
					this.set("state", DORMANT);
				}
				this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
	
				this.set("state", SHOW_TIMER);	// no-op if show-timer already set, or if already showing
			},
	
			_onUnHover: function(/*DomNode*/ target){
				// summary:
				//		Handles mouseleave event on the target node, hiding the tooltip.
				// tags:
				//		private
	
				this.set("state", HIDE_TIMER);		// no-op if already dormant, or if hide-timer already set
			},
	
			// open() and close() aren't used anymore, except from the _BidiSupport/misc/Tooltip test.
			// Should probably remove for 2.0, but leaving for now.
			open: function(/*DomNode*/ target){
				// summary:
				//		Display the tooltip; usually not called directly.
				// tags:
				//		private
	
				this.set("state", DORMANT);
				this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
				this.set("state", SHOWING);
			},
	
			close: function(){
				// summary:
				//		Hide the tooltip or cancel timer for show of tooltip
				// tags:
				//		private
	
				this.set("state", DORMANT);
			},
	
			onShow: function(/*===== target, position =====*/){
				// summary:
				//		Called when the tooltip is shown
				// tags:
				//		callback
			},
	
			onHide: function(){
				// summary:
				//		Called when the tooltip is hidden
				// tags:
				//		callback
			},
	
			destroy: function(){
				this.set("state", DORMANT);
	
				// Remove connections manually since they aren't registered to be removed by _WidgetBase
				array.forEach(this._connections || [], function(nested){
					array.forEach(nested, function(handle){ handle.remove(); });
				}, this);
	
				this.inherited(arguments);
			}
		});
	
		Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
		Tooltip.show = dijit.showTooltip;		// export function through module return value
		Tooltip.hide = dijit.hideTooltip;		// export function through module return value
	
		Tooltip.defaultPosition = ["after-centered", "before-centered"];
	
		/*=====
		lang.mixin(Tooltip, {
			 // defaultPosition: String[]
			 //		This variable controls the position of tooltips, if the position is not specified to
			 //		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
			 //		possible for `dijit/place.around()`.   The recommended values are:
			 //
			 //		- before-centered: centers tooltip to the left of the anchor node/widget, or to the right
			 //		  in the case of RTL scripts like Hebrew and Arabic
			 //		- after-centered: centers tooltip to the right of the anchor node/widget, or to the left
			 //		  in the case of RTL scripts like Hebrew and Arabic
			 //		- above-centered: tooltip is centered above anchor node
			 //		- below-centered: tooltip is centered above anchor node
			 //
			 //		The list is positions is tried, in order, until a position is found where the tooltip fits
			 //		within the viewport.
			 //
			 //		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
			 //		the screen so that there's no room above the target node.   Nodes with drop downs, like
			 //		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
			 //		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
			 //		is only room below (or above) the target node, but not both.
		 });
		=====*/
		return Tooltip;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28),
		__webpack_require__(7), 
		__webpack_require__(8),
		__webpack_require__(74),
		__webpack_require__(75),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, config, lang, registry, dijit,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/_base/manager", (function(){
	
		// module:
		//		dijit/_base/manager
	
		var exports = {
			// summary:
			//		Deprecated.  Shim to methods on registry, plus a few other declarations.
			//		New code should access dijit/registry directly when possible.
		};
	
		array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
			exports[name] = registry[name];
		});
	
		 lang.mixin(exports, {
			 // defaultDuration: Integer
			 //		The default fx.animation speed (in ms) to use for all Dijit
			 //		transitional fx.animations, unless otherwise specified
			 //		on a per-instance basis. Defaults to 200, overrided by
			 //		`djConfig.defaultDuration`
			 defaultDuration: config["defaultDuration"] || 200
		 });
	
		lang.mixin(dijit, exports);
	
		/*===== return exports; =====*/
		return dijit;	// for back compat :-(
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = "<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\" data-dojo-attach-event=\"mouseenter:onMouseEnter,mouseleave:onMouseLeave\"\r\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\r\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\r\n></div>\r\n"

/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = "<div class=\"dijit dijitReset dijitInline dijitLeft\"\r\n\tid=\"widget_${id}\" role=\"presentation\"\r\n\t><div class='dijitReset dijitValidationContainer'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t/></div\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\r\n\t\t\t${!nameAttrSetting} type='${type}'\r\n\t/></div\r\n></div>\r\n"

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6),__webpack_require__(181),__webpack_require__(182)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire,lang_ru,lang_fr){return dojoWebpackLoaderRequire.register("dijit/form/nls/validate", (function(){return {"root":{"invalidMessage":"The value entered is not valid.","missingMessage":"This value is required.","rangeMessage":"This value is out of range."},"ru":true,"fr":true};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/nls/ru/validate", (function(){return {
		invalidMessage: "  .",
		missingMessage: "  .",
		rangeMessage: "   ."
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/nls/fr/validate", (function(){return {
		invalidMessage: "La valeur indique n'est pas correcte.",
		missingMessage: "Cette valeur est requise.",
		rangeMessage: "Cette valeur n'est pas comprise dans la plage autorise."
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = "<div class=\"dijit dijitReset dijitInline dijitLeft\"\r\n\tid=\"widget_${id}\"\r\n\trole=\"combobox\"\r\n\taria-haspopup=\"true\"\r\n\tdata-dojo-attach-point=\"_popupStateNode\"\r\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\r\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\r\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\r\n\t\t\t${_buttonInputDisabled}\r\n\t/></div\r\n\t><div class='dijitReset dijitValidationContainer'\r\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\r\n\t/></div\r\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\r\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"${type}\" autocomplete=\"off\"\r\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\r\n\t/></div\r\n></div>\r\n"

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(8), 
		__webpack_require__(53),
		__webpack_require__(174),
		__webpack_require__(185),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, lang, when, MappedTextBox, ComboBoxMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/FilteringSelect", (function(){
	
		// module:
		//		dijit/form/FilteringSelect
	
		return declare("dijit.form.FilteringSelect", [MappedTextBox, ComboBoxMixin], {
			// summary:
			//		An enhanced version of the HTML SELECT tag, populated dynamically
			//
			// description:
			//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
			//		very nicely with very large data sets because it can load and page data as needed.
			//		It also resembles ComboBox, but does not allow values outside of the provided ones.
			//		If OPTION tags are used as the data provider via markup, then the
			//		OPTION tag's child text node is used as the displayed value when selected
			//		while the OPTION tag's value attribute is used as the widget value on form submit.
			//		To set the default value when using OPTION tags, specify the selected
			//		attribute on 1 of the child OPTION tags.
			//
			//		Similar features:
			//
			//		- There is a drop down list of possible values.
			//		- You can only enter a value from the drop down list.  (You can't
			//			enter an arbitrary value.)
			//		- The value submitted with the form is the hidden value (ex: CA),
			//			not the displayed value a.k.a. label (ex: California)
			//
			//		Enhancements over plain HTML version:
			//
			//		- If you type in some text then it will filter down the list of
			//			possible values in the drop down list.
			//		- List can be specified either as a static list or via a javascript
			//			function (that can get the list from a server)
	
			// required: Boolean
			//		True (default) if user is required to enter a value into this field.
			required: true,
	
			_lastDisplayedValue: "",
	
			_isValidSubset: function(){
				return this._opened;
			},
	
			isValid: function(){
				// Overrides ValidationTextBox.isValid()
				return !!this.item || (!this.required && this.get('displayedValue') == ""); // #5974
			},
	
			_refreshState: function(){
				if(!this.searchTimer){ // state will be refreshed after results are returned
					this.inherited(arguments);
				}
			},
	
			_callbackSetLabel: function(
							/*Array*/ result,
							/*Object*/ query,
							/*Object*/ options,
							/*Boolean?*/ priorityChange){
				// summary:
				//		Callback from dojo.store after lookup of user entered value finishes
	
				// setValue does a synchronous lookup,
				// so it calls _callbackSetLabel directly,
				// and so does not pass dataObject
				// still need to test against _lastQuery in case it came too late
				if((query && query[this.searchAttr] !== this._lastQuery) || (!query && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
					return;
				}
				if(!result.length){
					//#3268: don't modify display value on bad input
					//#3285: change CSS to indicate error
					this.set("value", '', priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
				}else{
					this.set('item', result[0], priorityChange);
				}
			},
	
			_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
				// Callback when a data store query completes.
				// Overrides ComboBox._openResultList()
	
				// #3285: tap into search callback to see if user's query resembles a match
				if(query[this.searchAttr] !== this._lastQuery){
					return;
				}
				this.inherited(arguments);
	
				if(this.item === undefined){ // item == undefined for keyboard search
					// If the search returned no items that means that the user typed
					// in something invalid (and they can't make it valid by typing more characters),
					// so flag the FilteringSelect as being in an invalid state
					this.validate(true);
				}
			},
	
			_getValueAttr: function(){
				// summary:
				//		Hook for get('value') to work.
	
				// don't get the textbox value but rather the previously set hidden value.
				// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
				return this.valueNode.value;
			},
	
			_getValueField: function(){
				// Overrides ComboBox._getValueField()
				return "value";
			},
	
			_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
				// summary:
				//		Hook so set('value', value) works.
				// description:
				//		Sets the value of the select.
				//		Also sets the label to the corresponding value by reverse lookup.
				if(!this._onChangeActive){ priorityChange = null; }
	
				if(item === undefined){
					if(value === null || value === ''){
						value = '';
						if(!lang.isString(displayedValue)){
							this._setDisplayedValueAttr(displayedValue||'', priorityChange);
							return;
						}
					}
	
					var self = this;
					this._lastQuery = value;
					when(this.store.get(value), function(item){
						self._callbackSetLabel(item? [item] : [], undefined, undefined, priorityChange);
					});
				}else{
					this.valueNode.value = value;
					this.inherited(arguments, [value, priorityChange, displayedValue, item]);
				}
			},
	
			_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
				// summary:
				//		Set the displayed valued in the input box, and the hidden value
				//		that gets submitted, based on a dojo.data store item.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('item', value)
				// tags:
				//		private
				this.inherited(arguments);
				this._lastDisplayedValue = this.textbox.value;
			},
	
			_getDisplayQueryString: function(/*String*/ text){
				return text.replace(/([\\\*\?])/g, "\\$1");
			},
	
			_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
				// summary:
				//		Hook so set('displayedValue', label) works.
				// description:
				//		Sets textbox to display label. Also performs reverse lookup
				//		to set the hidden value.  label should corresponding to item.searchAttr.
	
				if(label == null){ label = ''; }
	
				// This is called at initialization along with every custom setter.
				// Usually (or always?) the call can be ignored.   If it needs to be
				// processed then at least make sure that the XHR request doesn't trigger an onChange()
				// event, even if it returns after creation has finished
				if(!this._created){
					if(!("displayedValue" in this.params)){
						return;
					}
					priorityChange = false;
				}
	
				// Do a reverse lookup to map the specified displayedValue to the hidden value.
				// Note that if there's a custom labelFunc() this code
				if(this.store){
					this.closeDropDown();
					var query = lang.clone(this.query); // #6196: populate query with user-specifics
	
					// Generate query
					var qs = this._getDisplayQueryString(label), q;
					if(this.store._oldAPI){
						// remove this branch for 2.0
						q = qs;
					}else{
						// Query on searchAttr is a regex for benefit of dojo/store/Memory,
						// but with a toString() method to help dojo/store/JsonRest.
						// Search string like "Co*" converted to regex like /^Co.*$/i.
						q = this._patternToRegExp(qs);
						q.toString = function(){ return qs; };
					}
					this._lastQuery = query[this.searchAttr] = q;
	
					// If the label is not valid, the callback will never set it,
					// so the last valid value will get the warning textbox.   Set the
					// textbox value now so that the impending warning will make
					// sense to the user
					this.textbox.value = label;
					this._lastDisplayedValue = label;
					this._set("displayedValue", label);	// for watch("displayedValue") notification
					var _this = this;
					var options = {
						queryOptions: {
							ignoreCase: this.ignoreCase,
							deep: true
						}
					};
					lang.mixin(options, this.fetchProperties);
					this._fetchHandle = this.store.query(query, options);
					when(this._fetchHandle, function(result){
						_this._fetchHandle = null;
						_this._callbackSetLabel(result || [], query, options, priorityChange);
					}, function(err){
						_this._fetchHandle = null;
						if(!_this._cancelingQuery){	// don't treat canceled query as an error
							console.error('dijit.form.FilteringSelect: ' + err.toString());
						}
					});
				}
			},
	
			undo: function(){
				this.set('displayedValue', this._lastDisplayedValue);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(46),
		__webpack_require__(2), 
		__webpack_require__(8), 
		__webpack_require__(189),
		__webpack_require__(186),
		__webpack_require__(192),
		__webpack_require__(146),
		__webpack_require__(183),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, Deferred, kernel, lang, QueryResults, _AutoCompleterMixin, _ComboBoxMenu, _HasDropDown, template,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/ComboBoxMixin", (function(){
	
	
		// module:
		//		dijit/form/ComboBoxMixin
	
		return declare("dijit.form.ComboBoxMixin", [_HasDropDown, _AutoCompleterMixin], {
			// summary:
			//		Provides main functionality of ComboBox widget
	
			// dropDownClass: [protected extension] Function String
			//		Dropdown widget class used to select a date/time.
			//		Subclasses should specify this.
			dropDownClass: _ComboBoxMenu,
	
			// hasDownArrow: Boolean
			//		Set this textbox to have a down arrow button, to display the drop down list.
			//		Defaults to true.
			hasDownArrow: true,
	
			templateString: template,
	
			baseClass: "dijitTextBox dijitComboBox",
	
			/*=====
			// store: [const] dojo/store/api/Store|dojo/data/api/Read
			//		Reference to data provider object used by this ComboBox.
			//
			//		Should be dojo/store/api/Store, but dojo/data/api/Read supported
			//		for backwards compatibility.
			store: null,
			=====*/
	
			// Set classes like dijitDownArrowButtonHover depending on
			// mouse action over button node
			cssStateNodes: {
				"_buttonNode": "dijitDownArrowButton"
			},
	
			_setHasDownArrowAttr: function(/*Boolean*/ val){
				this._set("hasDownArrow", val);
				this._buttonNode.style.display = val ? "" : "none";
			},
	
			_showResultList: function(){
				// hide the tooltip
				this.displayMessage("");
				this.inherited(arguments);
			},
	
			_setStoreAttr: function(store){
				// For backwards-compatibility, accept dojo.data store in addition to dojo/store/api/Store.  Remove in 2.0.
				if(!store.get){
					lang.mixin(store, {
						_oldAPI: true,
						get: function(id){
							// summary:
							//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
							//		Like dojo/store/DataStore.get() except returns native item.
							var deferred = new Deferred();
							this.fetchItemByIdentity({
								identity: id,
								onItem: function(object){
									deferred.resolve(object);
								},
								onError: function(error){
									deferred.reject(error);
								}
							});
							return deferred.promise;
						},
						query: function(query, options){
							// summary:
							//		Queries the store for objects.   Like dojo/store/DataStore.query()
							//		except returned Deferred contains array of native items.
							var deferred = new Deferred(function(){ fetchHandle.abort && fetchHandle.abort(); });
							deferred.total = new Deferred();
							var fetchHandle = this.fetch(lang.mixin({
								query: query,
								onBegin: function(count){
									deferred.total.resolve(count);
								},
								onComplete: function(results){
									deferred.resolve(results);
								},
								onError: function(error){
									deferred.reject(error);
								}
							}, options));
							return QueryResults(deferred);
						}
					});
				}
				this._set("store", store);
			},
	
			postMixInProperties: function(){
				// Since _setValueAttr() depends on this.store, _setStoreAttr() needs to execute first.
				// Unfortunately, without special code, it ends up executing second.
				var store = this.params.store || this.store;
				if(store){
					this._setStoreAttr(store);
				}
	
				this.inherited(arguments);
	
				// User may try to access this.store.getValue() etc.  in a custom labelFunc() function.
				// It's not available with the new data store for handling inline <option> tags, so add it.
				if(!this.params.store && this.store && !this.store._oldAPI){
					var clazz = this.declaredClass;
					lang.mixin(this.store, {
						getValue: function(item, attr){
							kernel.deprecated(clazz + ".store.getValue(item, attr) is deprecated for builtin store.  Use item.attr directly", "", "2.0");
							return item[attr];
						},
						getLabel: function(item){
							kernel.deprecated(clazz + ".store.getLabel(item) is deprecated for builtin store.  Use item.label directly", "", "2.0");
							return item.name;
						},
						fetch: function(args){
							kernel.deprecated(clazz + ".store.fetch() is deprecated for builtin store.", "Use store.query()", "2.0");
							var shim = ["dojo/data/ObjectStore"];	// indirection so it doesn't get rolled into a build
							 throw new Error('DojoWebpackLoader: dynamic loading is not supported') ;
						}
					});
				}
			},
	
			buildRendering: function(){
				this.inherited(arguments);
	
				this.focusNode.setAttribute("aria-autocomplete", this.autoComplete ? "both" : "list");
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(19),
		__webpack_require__(1), 
		__webpack_require__(14), 
		__webpack_require__(26),
		__webpack_require__(8), 
		__webpack_require__(34), 
		__webpack_require__(95), 
		__webpack_require__(9), 
		__webpack_require__(187),
		__webpack_require__(157), 
		__webpack_require__(191),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(aspect, declare, domAttr, keys, lang, query, regexp, has, DataList, _TextBoxMixin, SearchMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_AutoCompleterMixin", (function(){
	
		// module:
		//		dijit/form/_AutoCompleterMixin
	
		var AutoCompleterMixin = declare("dijit.form._AutoCompleterMixin", SearchMixin, {
			// summary:
			//		A mixin that implements the base functionality for `dijit/form/ComboBox`/`dijit/form/FilteringSelect`
			// description:
			//		All widgets that mix in dijit/form/_AutoCompleterMixin must extend `dijit/form/_FormValueWidget`.
			// tags:
			//		protected
	
			// item: Object
			//		This is the item returned by the dojo/store/api/Store implementation that
			//		provides the data for this ComboBox, it's the currently selected item.
			item: null,
	
			// autoComplete: Boolean
			//		If user types in a partial string, and then tab out of the `<input>` box,
			//		automatically copy the first entry displayed in the drop down list to
			//		the `<input>` field
			autoComplete: true,
	
			// highlightMatch: String
			//		One of: "first", "all" or "none".
			//
			//		If the ComboBox/FilteringSelect opens with the search results and the searched
			//		string can be found, it will be highlighted.  If set to "all"
			//		then will probably want to change `queryExpr` parameter to '*${0}*'
			//
			//		Highlighting is only performed when `labelType` is "text", so as to not
			//		interfere with any HTML markup an HTML label might contain.
			highlightMatch: "first",
	
			// labelAttr: String?
			//		The entries in the drop down list come from this attribute in the
			//		dojo.data items.
			//		If not specified, the searchAttr attribute is used instead.
			labelAttr: "",
	
			// labelType: String
			//		Specifies how to interpret the labelAttr in the data store items.
			//		Can be "html" or "text".
			labelType: "text",
	
			// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
			maxHeight: -1,
	
			// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
			_stopClickEvents: false,
	
			_getCaretPos: function(/*DomNode*/ element){
				// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
				var pos = 0;
				if(typeof(element.selectionStart) == "number"){
					// FIXME: this is totally borked on Moz < 1.3. Any recourse?
					pos = element.selectionStart;
				}else if(has("ie")){
					// in the case of a mouse click in a popup being handled,
					// then the document.selection is not the textarea, but the popup
					// var r = document.selection.createRange();
					// hack to get IE 6 to play nice. What a POS browser.
					var tr = element.ownerDocument.selection.createRange().duplicate();
					var ntr = element.createTextRange();
					tr.move("character", 0);
					ntr.move("character", 0);
					try{
						// If control doesn't have focus, you get an exception.
						// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
						// There appears to be no workaround for this - googled for quite a while.
						ntr.setEndPoint("EndToEnd", tr);
						pos = String(ntr.text).replace(/\r/g, "").length;
					}catch(e){
						// If focus has shifted, 0 is fine for caret pos.
					}
				}
				return pos;
			},
	
			_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
				location = parseInt(location);
				_TextBoxMixin.selectInputText(element, location, location);
			},
	
			_setDisabledAttr: function(/*Boolean*/ value){
				// Additional code to set disabled state of ComboBox node.
				// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
				this.inherited(arguments);
				this.domNode.setAttribute("aria-disabled", value ? "true" : "false");
			},
	
			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handles keyboard events
	
				if(evt.charCode >= 32){
					return;
				} // alphanumeric reserved for searching
	
				var key = evt.charCode || evt.keyCode;
	
				// except for cutting/pasting case - ctrl + x/v
				if(key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT){
					return; // throw out spurious events
				}
	
				var pw = this.dropDown;
				var highlighted = null;
				this._abortQuery();
	
				// _HasDropDown will do some of the work:
				//
				//	1. when drop down is not yet shown:
				//		- if user presses the down arrow key, call loadDropDown()
				//	2. when drop down is already displayed:
				//		- on ESC key, call closeDropDown()
				//		- otherwise, call dropDown.handleKey() to process the keystroke
				this.inherited(arguments);
	
				if(evt.altKey || evt.ctrlKey || evt.metaKey){
					return;
				} // don't process keys with modifiers  - but we want shift+TAB
	
				if(this._opened){
					highlighted = pw.getHighlightedOption();
				}
				switch(key){
					case keys.PAGE_DOWN:
					case keys.DOWN_ARROW:
					case keys.PAGE_UP:
					case keys.UP_ARROW:
						// Keystroke caused ComboBox_menu to move to a different item.
						// Copy new item to <input> box.
						if(this._opened){
							this._announceOption(highlighted);
						}
						evt.stopPropagation();
						evt.preventDefault();
						break;
	
					case keys.ENTER:
						// prevent submitting form if user presses enter. Also
						// prevent accepting the value if either Next or Previous
						// are selected
						if(highlighted){
							// only stop event on prev/next
							if(highlighted == pw.nextButton){
								this._nextSearch(1);
								// prevent submit
								evt.stopPropagation();
								evt.preventDefault();
								break;
							}else if(highlighted == pw.previousButton){
								this._nextSearch(-1);
								// prevent submit
								evt.stopPropagation();
								evt.preventDefault();
								break;
							}
							// prevent submit if ENTER was to choose an item
							evt.stopPropagation();
							evt.preventDefault();
						}else{
							// Update 'value' (ex: KY) according to currently displayed text
							this._setBlurValue(); // set value if needed
							this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
						}
					// fall through
	
					case keys.TAB:
						var newvalue = this.get('displayedValue');
						//	if the user had More Choices selected fall into the
						//	_onBlur handler
						if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
							break;
						}
						if(highlighted){
							this._selectOption(highlighted);
						}
					// fall through
	
					case keys.ESCAPE:
						if(this._opened){
							this._lastQuery = null; // in case results come back later
							this.closeDropDown();
						}
						break;
				}
			},
	
			_autoCompleteText: function(/*String*/ text){
				// summary:
				//		Fill in the textbox with the first item from the drop down
				//		list, and highlight the characters that were
				//		auto-completed. For example, if user typed "CA" and the
				//		drop down list appeared, the textbox would be changed to
				//		"California" and "ifornia" would be highlighted.
	
				var fn = this.focusNode;
	
				// IE7: clear selection so next highlight works all the time
				_TextBoxMixin.selectInputText(fn, fn.value.length);
				// does text autoComplete the value in the textbox?
				var caseFilter = this.ignoreCase ? 'toLowerCase' : 'substr';
				if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
					var cpos = this.autoComplete ? this._getCaretPos(fn) : fn.value.length;
					// only try to extend if we added the last character at the end of the input
					if((cpos + 1) > fn.value.length){
						// only add to input node as we would overwrite Capitalisation of chars
						// actually, that is ok
						fn.value = text;//.substr(cpos);
						// visually highlight the autocompleted characters
						_TextBoxMixin.selectInputText(fn, cpos);
					}
				}else{
					// text does not autoComplete; replace the whole value and highlight
					fn.value = text;
					_TextBoxMixin.selectInputText(fn);
				}
			},
	
			_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
				// summary:
				//		Callback when a search completes.
				// description:
				//		1. generates drop-down list and calls _showResultList() to display it
				//		2. if this result list is from user pressing "more choices"/"previous choices"
				//			then tell screen reader to announce new option
				var wasSelected = this.dropDown.getHighlightedOption();
				this.dropDown.clearResultList();
				if(!results.length && options.start == 0){ // if no results and not just the previous choices button
					this.closeDropDown();
					return;
				}
				this._nextSearch = this.dropDown.onPage = lang.hitch(this, function(direction){
					results.nextPage(direction !== -1);
					this.focus();
				});
	
				// Fill in the textbox with the first item from the drop down list,
				// and highlight the characters that were auto-completed. For
				// example, if user typed "CA" and the drop down list appeared, the
				// textbox would be changed to "California" and "ifornia" would be
				// highlighted.
	
				this.dropDown.createOptions(
					results,
					options,
					lang.hitch(this, "_getMenuLabelFromItem")
				);
	
				// show our list (only if we have content, else nothing)
				this._showResultList();
	
				// #4091:
				//		tell the screen reader that the paging callback finished by
				//		shouting the next choice
				if("direction" in options){
					if(options.direction){
						this.dropDown.highlightFirstOption();
					}else if(!options.direction){
						this.dropDown.highlightLastOption();
					}
					if(wasSelected){
						this._announceOption(this.dropDown.getHighlightedOption());
					}
				}else if(this.autoComplete && !this._prev_key_backspace
					// when the user clicks the arrow button to show the full list,
					// startSearch looks for "*".
					// it does not make sense to autocomplete
					// if they are just previewing the options available.
					&& !/^[*]+$/.test(query[this.searchAttr].toString())){
					this._announceOption(this.dropDown.containerNode.firstChild.nextSibling); // 1st real item
				}
			},
	
			_showResultList: function(){
				// summary:
				//		Display the drop down if not already displayed, or if it is displayed, then
				//		reposition it if necessary (reposition may be necessary if drop down's height changed).
				this.closeDropDown(true);
				this.openDropDown();
				this.domNode.setAttribute("aria-expanded", "true");
			},
	
			loadDropDown: function(/*Function*/ /*===== callback =====*/){
				// Overrides _HasDropDown.loadDropDown().
				// This is called when user has pressed button icon or pressed the down arrow key
				// to open the drop down.
				this._startSearchAll();
			},
	
			isLoaded: function(){
				// signal to _HasDropDown that it needs to call loadDropDown() to load the
				// drop down asynchronously before displaying it
				return false;
			},
	
			closeDropDown: function(){
				// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
				// This method is the callback when the user types ESC or clicking
				// the button icon while the drop down is open.  It's also called by other code.
				this._abortQuery();
				if(this._opened){
					this.inherited(arguments);
					this.domNode.setAttribute("aria-expanded", "false");
				}
			},
	
			_setBlurValue: function(){
				// if the user clicks away from the textbox OR tabs away, set the
				// value to the textbox value
				// #4617:
				//		if value is now more choices or previous choices, revert
				//		the value
				var newvalue = this.get('displayedValue');
				var pw = this.dropDown;
				if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
					this._setValueAttr(this._lastValueReported, true);
				}else if(typeof this.item == "undefined"){
					// Update 'value' (ex: KY) according to currently displayed text
					this.item = null;
					this.set('displayedValue', newvalue);
				}else{
					if(this.value != this._lastValueReported){
						this._handleOnChange(this.value, true);
					}
					this._refreshState();
				}
				// Remove aria-activedescendant since it may not be removed if they select with arrows then blur with mouse
				this.focusNode.removeAttribute("aria-activedescendant");
			},
	
			_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
				// summary:
				//		Set the displayed valued in the input box, and the hidden value
				//		that gets submitted, based on a dojo.data store item.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('item', value)
				// tags:
				//		private
				var value = '';
				if(item){
					if(!displayedValue){
						displayedValue = this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
							this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
					}
					value = this._getValueField() != this.searchAttr ? this.store.getIdentity(item) : displayedValue;
				}
				this.set('value', value, priorityChange, displayedValue, item);
			},
	
			_announceOption: function(/*Node*/ node){
				// summary:
				//		a11y code that puts the highlighted option in the textbox.
				//		This way screen readers will know what is happening in the
				//		menu.
	
				if(!node){
					return;
				}
				// pull the text value from the item attached to the DOM node
				var newValue;
				if(node == this.dropDown.nextButton ||
					node == this.dropDown.previousButton){
					newValue = node.innerHTML;
					this.item = undefined;
					this.value = '';
				}else{
					var item = this.dropDown.items[node.getAttribute("item")];
					newValue = (this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
						this.store.getValue(item, this.searchAttr) : item[this.searchAttr]).toString();
					this.set('item', item, false, newValue);
				}
				// get the text that the user manually entered (cut off autocompleted text)
				this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
				// set up ARIA activedescendant
				this.focusNode.setAttribute("aria-activedescendant", domAttr.get(node, "id"));
				// autocomplete the rest of the option to announce change
				this._autoCompleteText(newValue);
			},
	
			_selectOption: function(/*DomNode*/ target){
				// summary:
				//		Menu callback function, called when an item in the menu is selected.
				this.closeDropDown();
				if(target){
					this._announceOption(target);
				}
				this._setCaretPos(this.focusNode, this.focusNode.value.length);
				this._handleOnChange(this.value, true);
				// Remove aria-activedescendant since the drop down is no loner visible
				// after closeDropDown() but _announceOption() adds it back in
				this.focusNode.removeAttribute("aria-activedescendant");
			},
	
			_startSearchAll: function(){
				this._startSearch('');
			},
	
			_startSearchFromInput: function(){
				this.item = undefined; // undefined means item needs to be set
				this.inherited(arguments);
			},
	
			_startSearch: function(/*String*/ key){
				// summary:
				//		Starts a search for elements matching key (key=="" means to return all items),
				//		and calls _openResultList() when the search completes, to display the results.
				if(!this.dropDown){
					var popupId = this.id + "_popup",
						dropDownConstructor = lang.isString(this.dropDownClass) ?
							lang.getObject(this.dropDownClass, false) : this.dropDownClass;
					this.dropDown = new dropDownConstructor({
						onChange: lang.hitch(this, this._selectOption),
						id: popupId,
						dir: this.dir,
						textDir: this.textDir
					});
				}
				this._lastInput = key; // Store exactly what was entered by the user.
				this.inherited(arguments);
			},
	
			_getValueField: function(){
				// summary:
				//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
				//		Returns the attribute name in the item (in dijit/form/_ComboBoxDataStore) to use as the value.
				return this.searchAttr;
			},
	
			//////////// INITIALIZATION METHODS ///////////////////////////////////////
	
			postMixInProperties: function(){
				this.inherited(arguments);
				if(!this.store && this.srcNodeRef){
					var srcNodeRef = this.srcNodeRef;
					// if user didn't specify store, then assume there are option tags
					this.store = new DataList({}, srcNodeRef);
	
					// if there is no value set and there is an option list, set
					// the value to the first value to be consistent with native Select
					// Firefox and Safari set value
					// IE6 and Opera set selectedIndex, which is automatically set
					// by the selected attribute of an option tag
					// IE6 does not set value, Opera sets value = selectedIndex
					if(!("value" in this.params)){
						var item = (this.item = this.store.fetchSelectedItem());
						if(item){
							var valueField = this._getValueField();
							// remove getValue() for 2.0 (old dojo.data API)
							this.value = this.store._oldAPI ? this.store.getValue(item, valueField) : item[valueField];
						}
					}
				}
			},
	
			postCreate: function(){
				// summary:
				//		Subclasses must call this method from their postCreate() methods
				// tags:
				//		protected
	
				// find any associated label element and add to ComboBox node.
				var label = query('label[for="' + this.id + '"]');
				if(label.length){
					if(!label[0].id){
						label[0].id = this.id + "_label";
					}
					this.domNode.setAttribute("aria-labelledby", label[0].id);
	
				}
				this.inherited(arguments);
				aspect.after(this, "onSearch", lang.hitch(this, "_openResultList"), true);
			},
	
			_getMenuLabelFromItem: function(/*Item*/ item){
				var label = this.labelFunc(item, this.store),
					labelType = this.labelType;
				// If labelType is not "text" we don't want to screw any markup ot whatever.
				if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
					label = this.doHighlight(label, this._lastInput);
					labelType = "html";
				}
				return {html: labelType == "html", label: label};
			},
	
			doHighlight: function(/*String*/ label, /*String*/ find){
				// summary:
				//		Highlights the string entered by the user in the menu.  By default this
				//		highlights the first occurrence found. Override this method
				//		to implement your custom highlighting.
				// tags:
				//		protected
	
				var
				// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
					modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
					i = this.queryExpr.indexOf("${0}");
				find = regexp.escapeString(find); // escape regexp special chars
				//If < appears in label, and user presses t, we don't want to highlight the t in the escaped "&lt;"
				//first find out every occurrences of "find", wrap each occurrence in a pair of "\uFFFF" characters (which
				//should not appear in any string). then html escape the whole string, and replace '\uFFFF" with the
				//HTML highlight markup.
				return this._escapeHtml(label.replace(
					new RegExp((i == 0 ? "^" : "") + "(" + find + ")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
					'\uFFFF$1\uFFFF')).replace(
					/\uFFFF([^\uFFFF]+)\uFFFF/g, '<span class="dijitComboBoxHighlightMatch">$1</span>'
				); // returns String, (almost) valid HTML (entities encoded)
			},
	
			_escapeHtml: function(/*String*/ str){
				// TODO Should become dojo.html.entities(), when exists use instead
				// summary:
				//		Adds escape sequences for special characters in XML: `&<>"'`
				str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
					.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;"); //balance"
				return str; // string
			},
	
			reset: function(){
				// Overrides the _FormWidget.reset().
				// Additionally reset the .item (to clean up).
				this.item = null;
				this.inherited(arguments);
			},
	
			labelFunc: function(item, store){
				// summary:
				//		Computes the label to display based on the dojo.data store item.
				// item: Object
				//		The item from the store
				// store: dojo/store/api/Store
				//		The store.
				// returns:
				//		The label that the ComboBox should display
				// tags:
				//		private
	
				// Use toString() because XMLStore returns an XMLItem whereas this
				// method is expected to return a String (#9354).
				// Remove getValue() for 2.0 (old dojo.data API)
				return (store._oldAPI ? store.getValue(item, this.labelAttr || this.searchAttr) :
					item[this.labelAttr || this.searchAttr]).toString(); // String
			},
	
			_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
				// summary:
				//		Hook so set('value', value) works.
				// description:
				//		Sets the value of the select.
				this._set("item", item || null); // value not looked up in store
				if(value == null /* or undefined */){
					value = '';
				} // null translates to blank
				this.inherited(arguments);
			}
		});
	
		if(has("dojo-bidi")){
			AutoCompleterMixin.extend({
				_setTextDirAttr: function(/*String*/ textDir){
					// summary:
					//		Setter for textDir, needed for the dropDown's textDir update.
					// description:
					//		Users shouldn't call this function; they should be calling
					//		set('textDir', value)
					// tags:
					//		private
					this.inherited(arguments);
					// update the drop down also (_ComboBoxMenuMixin)
					if(this.dropDown){
						this.dropDown._set("textDir", textDir);
					}
				}
			});
		}
	
		return AutoCompleterMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(13), 
		__webpack_require__(8), 
		__webpack_require__(34), 
		__webpack_require__(188),
		__webpack_require__(74),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, dom, lang, query, MemoryStore, registry,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/DataList", (function(){
	
		// module:
		//		dijit/form/DataList
	
		function toItem(/*DOMNode*/ option){
			// summary:
			//		Convert `<option>` node to hash
			return {
				id: option.value,
				value: option.value,
				name: lang.trim(option.innerText || option.textContent || '')
			};
		}
	
		return declare("dijit.form.DataList", MemoryStore, {
			// summary:
			//		Inefficient but small data store specialized for inlined data via OPTION tags
			//
			// description:
			//		Provides a store for inlined data like:
			//
			//	|	<datalist>
			//	|		<option value="AL">Alabama</option>
			//	|		...
	
			constructor: function(params, srcNodeRef){
				// summary:
				//		Create the widget.
				// params: Object|null
				//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
				//		and functions, typically callbacks like onClick.
				//		The hash can contain any of the widget's properties, excluding read-only properties.
				// srcNodeRef: DOMNode|String
				//		Attach widget to this DOM node.
	
				// store pointer to original DOM tree
				this.domNode = dom.byId(srcNodeRef);
	
				lang.mixin(this, params);
				if(this.id){
					registry.add(this); // add to registry so it can be easily found by id
				}
				this.domNode.style.display = "none";
	
				this.inherited(arguments, [{
					data: query("option", this.domNode).map(toItem)
				}]);
			},
	
			destroy: function(){
				registry.remove(this.id);
			},
	
			fetchSelectedItem: function(){
				// summary:
				//		Get the option marked as selected, like `<option selected>`.
				//		Not part of dojo.data API.
				var option = query("> option[selected]", this.domNode)[0] || query("> option", this.domNode)[0];
				return option && toItem(option);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(189), __webpack_require__(190) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, QueryResults, SimpleQueryEngine /*=====, Store =====*/){
	
	// module:
	//		dojo/store/Memory
	
	// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
	var base = null;
	/*===== base = Store; =====*/
	
	return declare("dojo.store.Memory", base, {
		// summary:
		//		This is a basic in-memory object store. It implements dojo/store/api/Store.
		constructor: function(options){
			// summary:
			//		Creates a memory object store.
			// options: dojo/store/Memory
			//		This provides any configuration information that will be mixed into the store.
			//		This should generally include the data property to provide the starting set of data.
			for(var i in options){
				this[i] = options[i];
			}
			this.setData(this.data || []);
		},
		// data: Array
		//		The array of all the objects in the memory store
		data:null,
	
		// idProperty: String
		//		Indicates the property to use as the identity property. The values of this
		//		property should be unique.
		idProperty: "id",
	
		// index: Object
		//		An index of data indices into the data array by id
		index:null,
	
		// queryEngine: Function
		//		Defines the query engine to use for querying the data store
		queryEngine: SimpleQueryEngine,
		get: function(id){
			// summary:
			//		Retrieves an object by its identity
			// id: Number
			//		The identity to use to lookup the object
			// returns: Object
			//		The object in the store that matches the given id.
			return this.data[this.index[id]];
		},
		getIdentity: function(object){
			// summary:
			//		Returns an object's identity
			// object: Object
			//		The object to get the identity from
			// returns: Number
			return object[this.idProperty];
		},
		put: function(object, options){
			// summary:
			//		Stores an object
			// object: Object
			//		The object to store.
			// options: dojo/store/api/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an "id"
			//		property if a specific id is to be used.
			// returns: Number
			var data = this.data,
				index = this.index,
				idProperty = this.idProperty;
			var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
			if(id in index){
				// object exists
				if(options && options.overwrite === false){
					throw new Error("Object already exists");
				}
				// replace the entry in data
				data[index[id]] = object;
			}else{
				// add the new object
				index[id] = data.push(object) - 1;
			}
			return id;
		},
		add: function(object, options){
			// summary:
			//		Creates an object, throws an error if the object already exists
			// object: Object
			//		The object to store.
			// options: dojo/store/api/Store.PutDirectives?
			//		Additional metadata for storing the data.  Includes an "id"
			//		property if a specific id is to be used.
			// returns: Number
			(options = options || {}).overwrite = false;
			// call put with overwrite being false
			return this.put(object, options);
		},
		remove: function(id){
			// summary:
			//		Deletes an object by its identity
			// id: Number
			//		The identity to use to delete the object
			// returns: Boolean
			//		Returns true if an object was removed, falsy (undefined) if no object matched the id
			var index = this.index;
			var data = this.data;
			if(id in index){
				data.splice(index[id], 1);
				// now we have to reindex
				this.setData(data);
				return true;
			}
		},
		query: function(query, options){
			// summary:
			//		Queries the store for objects.
			// query: Object
			//		The query to use for retrieving objects from the store.
			// options: dojo/store/api/Store.QueryOptions?
			//		The optional arguments to apply to the resultset.
			// returns: dojo/store/api/Store.QueryResults
			//		The results of the query, extended with iterative methods.
			//
			// example:
			//		Given the following store:
			//
			// 	|	var store = new Memory({
			// 	|		data: [
			// 	|			{id: 1, name: "one", prime: false },
			//	|			{id: 2, name: "two", even: true, prime: true},
			//	|			{id: 3, name: "three", prime: true},
			//	|			{id: 4, name: "four", even: true, prime: false},
			//	|			{id: 5, name: "five", prime: true}
			//	|		]
			//	|	});
			//
			//	...find all items where "prime" is true:
			//
			//	|	var results = store.query({ prime: true });
			//
			//	...or find all items where "even" is true:
			//
			//	|	var results = store.query({ even: true });
			return QueryResults(this.queryEngine(query, options)(this.data));
		},
		setData: function(data){
			// summary:
			//		Sets the given data as the source for this store, and indexes it
			// data: Object[]
			//		An array of objects to use as the source of data.
			if(data.items){
				// just for convenience with the data format IFRS expects
				this.idProperty = data.identifier || this.idProperty;
				data = this.data = data.items;
			}else{
				this.data = data;
			}
			this.index = {};
			for(var i = 0, l = data.length; i < l; i++){
				this.index[data[i][this.idProperty]] = i;
			}
		}
	});
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(28), __webpack_require__(8), __webpack_require__(53)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, lang, when){
	
	// module:
	//		dojo/store/util/QueryResults
	
	var QueryResults = function(results){
		// summary:
		//		A function that wraps the results of a store query with additional
		//		methods.
		// description:
		//		QueryResults is a basic wrapper that allows for array-like iteration
		//		over any kind of returned data from a query.  While the simplest store
		//		will return a plain array of data, other stores may return deferreds or
		//		promises; this wrapper makes sure that *all* results can be treated
		//		the same.
		//
		//		Additional methods include `forEach`, `filter` and `map`.
		// results: Array|dojo/promise/Promise
		//		The result set as an array, or a promise for an array.
		// returns:
		//		An array-like object that can be used for iterating over.
		// example:
		//		Query a store and iterate over the results.
		//
		//	|	store.query({ prime: true }).forEach(function(item){
		//	|		//	do something
		//	|	});
	
		if(!results){
			return results;
		}
	
		var isPromise = !!results.then;
		// if it is a promise it may be frozen
		if(isPromise){
			results = lang.delegate(results);
		}
		function addIterativeMethod(method){
			// Always add the iterative methods so a QueryResults is
			// returned whether the environment is ES3 or ES5
			results[method] = function(){
				var args = arguments;
				var result = when(results, function(results){
					Array.prototype.unshift.call(args, results);
					return QueryResults(array[method].apply(array, args));
				});
				// forEach should only return the result of when()
				// when we're wrapping a promise
				if(method !== "forEach" || isPromise){
					return result;
				}
			};
		}
	
		addIterativeMethod("forEach");
		addIterativeMethod("filter");
		addIterativeMethod("map");
		if(results.total == null){
			results.total = when(results, function(results){
				return results.length;
			});
		}
		return results; // Object
	};
	
	lang.setObject("dojo.store.util.QueryResults", QueryResults);
	
	return QueryResults;
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(28) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(arrayUtil /*=====, Store =====*/){
	
	// module:
	//		dojo/store/util/SimpleQueryEngine
	
	return function(query, options){
		// summary:
		//		Simple query engine that matches using filter functions, named filter
		//		functions or objects by name-value on a query object hash
		//
		// description:
		//		The SimpleQueryEngine provides a way of getting a QueryResults through
		//		the use of a simple object hash as a filter.  The hash will be used to
		//		match properties on data objects with the corresponding value given. In
		//		other words, only exact matches will be returned.
		//
		//		This function can be used as a template for more complex query engines;
		//		for example, an engine can be created that accepts an object hash that
		//		contains filtering functions, or a string that gets evaluated, etc.
		//
		//		When creating a new dojo.store, simply set the store's queryEngine
		//		field as a reference to this function.
		//
		// query: Object
		//		An object hash with fields that may match fields of items in the store.
		//		Values in the hash will be compared by normal == operator, but regular expressions
		//		or any object that provides a test() method are also supported and can be
		//		used to match strings by more complex expressions
		//		(and then the regex's or object's test() method will be used to match values).
		//
		// options: dojo/store/api/Store.QueryOptions?
		//		An object that contains optional information such as sort, start, and count.
		//
		// returns: Function
		//		A function that caches the passed query under the field "matches".  See any
		//		of the "query" methods on dojo.stores.
		//
		// example:
		//		Define a store with a reference to this engine, and set up a query method.
		//
		//	|	var myStore = function(options){
		//	|		//	...more properties here
		//	|		this.queryEngine = SimpleQueryEngine;
		//	|		//	define our query method
		//	|		this.query = function(query, options){
		//	|			return QueryResults(this.queryEngine(query, options)(this.data));
		//	|		};
		//	|	};
	
		// create our matching query function
		switch(typeof query){
			default:
				throw new Error("Can not query with a " + typeof query);
			case "object": case "undefined":
				var queryObject = query;
				query = function(object){
					for(var key in queryObject){
						var required = queryObject[key];
						if(required && required.test){
							// an object can provide a test method, which makes it work with regex
							if(!required.test(object[key], object)){
								return false;
							}
						}else if(required != object[key]){
							return false;
						}
					}
					return true;
				};
				break;
			case "string":
				// named query
				if(!this[query]){
					throw new Error("No filter function " + query + " was found in store");
				}
				query = this[query];
				// fall through
			case "function":
				// fall through
		}
		function execute(array){
			// execute the whole query, first we filter
			var results = arrayUtil.filter(array, query);
			// next we sort
			var sortSet = options && options.sort;
			if(sortSet){
				results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
					for(var sort, i=0; sort = sortSet[i]; i++){
						var aValue = a[sort.attribute];
						var bValue = b[sort.attribute];
						// valueOf enables proper comparison of dates
						aValue = aValue != null ? aValue.valueOf() : aValue;
						bValue = bValue != null ? bValue.valueOf() : bValue;
						if (aValue != bValue){
							return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
						}
					}
					return 0;
				});
			}
			// now we paginate
			if(options && (options.start || options.count)){
				var total = results.length;
				results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
				results.total = total;
			}
			return results;
		}
		execute.matches = query;
		return execute;
	};
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(26), 
		__webpack_require__(8), 
		__webpack_require__(34), 
		__webpack_require__(79), 
		__webpack_require__(53),
		__webpack_require__(74),__webpack_require__(6)	
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, keys, lang, query, string, when, registry,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_SearchMixin", (function(){
	
		// module:
		//		dijit/form/_SearchMixin
	
	
		return declare("dijit.form._SearchMixin", null, {
			// summary:
			//		A mixin that implements the base functionality to search a store based upon user-entered text such as
			//		with `dijit/form/ComboBox` or `dijit/form/FilteringSelect`
			// tags:
			//		protected
	
			// pageSize: Integer
			//		Argument to data provider.
			//		Specifies maximum number of search results to return per query
			pageSize: Infinity,
	
			// store: [const] dojo/store/api/Store
			//		Reference to data provider object used by this ComboBox.
			//		The store must accept an object hash of properties for its query. See `query` and `queryExpr` for details.
			store: null,
	
			// fetchProperties: Object
			//		Mixin to the store's fetch.
			//		For example, to set the sort order of the ComboBox menu, pass:
			//	|	{ sort: [{attribute:"name",descending: true}] }
			//		To override the default queryOptions so that deep=false, do:
			//	|	{ queryOptions: {ignoreCase: true, deep: false} }
			fetchProperties:{},
	
			// query: Object
			//		A query that can be passed to `store` to initially filter the items.
			//		ComboBox overwrites any reference to the `searchAttr` and sets it to the `queryExpr` with the user's input substituted.
			query: {},
	
			// list: [const] String
			//		Alternate to specifying a store.  Id of a dijit/form/DataList widget.
			list: "",
			_setListAttr: function(list){
				// Avoid having list applied to the DOM node, since it has native meaning in modern browsers
				this._set("list", list);
			},
	
			// searchDelay: Integer
			//		Delay in milliseconds between when user types something and we start
			//		searching based on that value
			searchDelay: 200,
	
			// searchAttr: String
			//		Search for items in the data store where this attribute (in the item)
			//		matches what the user typed
			searchAttr: "name",
	
			// queryExpr: String
			//		This specifies what query is sent to the data store,
			//		based on what the user has typed.  Changing this expression will modify
			//		whether the results are only exact matches, a "starting with" match,
			//		etc.
			//		`${0}` will be substituted for the user text.
			//		`*` is used for wildcards.
			//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
			queryExpr: "${0}*",
	
			// ignoreCase: Boolean
			//		Set true if the query should ignore case when matching possible items
			ignoreCase: true,
	
			_patternToRegExp: function(pattern){
				// summary:
				//		Helper function to convert a simple pattern to a regular expression for matching.
				// description:
				//		Returns a regular expression object that conforms to the defined conversion rules.
				//		For example:
				//
				//		- ca*   -> /^ca.*$/
				//		- *ca*  -> /^.*ca.*$/
				//		- *c\*a*  -> /^.*c\*a.*$/
				//		- *c\*a?*  -> /^.*c\*a..*$/
				//
				//		and so on.
				// pattern: string
				//		A simple matching pattern to convert that follows basic rules:
				//
				//		- * Means match anything, so ca* means match anything starting with ca
				//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
				//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
				//
				//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
				//		represented by \\ to be treated as an ordinary \ character instead of an escape.
	
				return new RegExp("^" + pattern.replace(/(\\.)|(\*)|(\?)|\W/g, function(str, literal, star, question){
					return star ? ".*" : question ? "." : literal ? literal : "\\" + str;
				}) + "$", this.ignoreCase ? "mi" : "m");
			},
	
			_abortQuery: function(){
				// stop in-progress query
				if(this.searchTimer){
					this.searchTimer = this.searchTimer.remove();
				}
				if(this._queryDeferHandle){
					this._queryDeferHandle = this._queryDeferHandle.remove();
				}
				if(this._fetchHandle){
					if(this._fetchHandle.abort){
						this._cancelingQuery = true;
						this._fetchHandle.abort();
						this._cancelingQuery = false;
					}
					if(this._fetchHandle.cancel){
						this._cancelingQuery = true;
						this._fetchHandle.cancel();
						this._cancelingQuery = false;
					}
					this._fetchHandle = null;
				}
			},
	
			_processInput: function(/*Event*/ evt){
				// summary:
				//		Handles input (keyboard/paste) events
				if(this.disabled || this.readOnly){ return; }
				var key = evt.charOrCode;
	
				var doSearch = false;
				this._prev_key_backspace = false;
	
				switch(key){
					case keys.DELETE:
					case keys.BACKSPACE:
						this._prev_key_backspace = true;
						this._maskValidSubsetError = true;
						doSearch = true;
						break;
	
					default:
						// Non char keys (F1-F12 etc..) shouldn't start a search..
						// Ascii characters and IME input (Chinese, Japanese etc.) should.
						//IME input produces keycode == 229.
						doSearch = typeof key == 'string' || key == 229;
				}
				if(doSearch){
					// need to wait a tad before start search so that the event
					// bubbles through DOM and we have value visible
					if(!this.store){
						this.onSearch();
					}else{
						this.searchTimer = this.defer("_startSearchFromInput", 1);
					}
				}
			},
	
			onSearch: function(/*===== results, query, options =====*/){
				// summary:
				//		Callback when a search completes.
				//
				// results: Object
				//		An array of items from the originating _SearchMixin's store.
				//
				// query: Object
				//		A copy of the originating _SearchMixin's query property.
				//
				// options: Object
				//		The additional parameters sent to the originating _SearchMixin's store, including: start, count, queryOptions.
				//
				// tags:
				//		callback
			},
	
			_startSearchFromInput: function(){
				this._startSearch(this.focusNode.value);
			},
	
			_startSearch: function(/*String*/ text){
				// summary:
				//		Starts a search for elements matching text (text=="" means to return all items),
				//		and calls onSearch(...) when the search completes, to display the results.
	
				this._abortQuery();
				var
					_this = this,
					// Setup parameters to be passed to store.query().
					// Create a new query to prevent accidentally querying for a hidden
					// value from FilteringSelect's keyField
					query = lang.clone(this.query), // #5970
					options = {
						start: 0,
						count: this.pageSize,
						queryOptions: {		// remove for 2.0
							ignoreCase: this.ignoreCase,
							deep: true
						}
					},
					qs = string.substitute(this.queryExpr, [text.replace(/([\\\*\?])/g, "\\$1")]),
					q,
					startQuery = function(){
						var resPromise = _this._fetchHandle = _this.store.query(query, options);
						if(_this.disabled || _this.readOnly || (q !== _this._lastQuery)){
							return;
						} // avoid getting unwanted notify
						when(resPromise, function(res){
							_this._fetchHandle = null;
							if(!_this.disabled && !_this.readOnly && (q === _this._lastQuery)){ // avoid getting unwanted notify
								when(resPromise.total, function(total){
									res.total = total;
									var pageSize = _this.pageSize;
									if(isNaN(pageSize) || pageSize > res.total){ pageSize = res.total; }
									// Setup method to fetching the next page of results
									res.nextPage = function(direction){
										//	tell callback the direction of the paging so the screen
										//	reader knows which menu option to shout
										options.direction = direction = direction !== false;
										options.count = pageSize;
										if(direction){
											options.start += res.length;
											if(options.start >= res.total){
												options.count = 0;
											}
										}else{
											options.start -= pageSize;
											if(options.start < 0){
												options.count = Math.max(pageSize + options.start, 0);
												options.start = 0;
											}
										}
										if(options.count <= 0){
											res.length = 0;
											_this.onSearch(res, query, options);
										}else{
											startQuery();
										}
									};
									_this.onSearch(res, query, options);
								});
							}
						}, function(err){
							_this._fetchHandle = null;
							if(!_this._cancelingQuery){	// don't treat canceled query as an error
								console.error(_this.declaredClass + ' ' + err.toString());
							}
						});
					};
	
				lang.mixin(options, this.fetchProperties);
	
				// Generate query
				if(this.store._oldAPI){
					// remove this branch for 2.0
					q = qs;
				}else{
					// Query on searchAttr is a regex for benefit of dojo/store/Memory,
					// but with a toString() method to help dojo/store/JsonRest.
					// Search string like "Co*" converted to regex like /^Co.*$/i.
					q = this._patternToRegExp(qs);
					q.toString = function(){ return qs; };
				}
	
				// set _lastQuery, *then* start the timeout
				// otherwise, if the user types and the last query returns before the timeout,
				// _lastQuery won't be set and their input gets rewritten
				this._lastQuery = query[this.searchAttr] = q;
				this._queryDeferHandle = this.defer(startQuery, this.searchDelay);
			},
	
			//////////// INITIALIZATION METHODS ///////////////////////////////////////
	
			constructor: function(){
				this.query={};
				this.fetchProperties={};
			},
	
			postMixInProperties: function(){
				if(!this.store){
					var list = this.list;
					if(list){
						this.store = registry.byId(list);
					}
				}
				this.inherited(arguments);
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(27), 
		__webpack_require__(15), 
		__webpack_require__(26), 
		__webpack_require__(69),
		__webpack_require__(76),
		__webpack_require__(193),
		__webpack_require__(197),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, domClass, domStyle, keys,
				_WidgetBase, _TemplatedMixin, _ComboBoxMenuMixin, _ListMouseMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_ComboBoxMenu", (function(){
	
	
		// module:
		//		dijit/form/_ComboBoxMenu
	
		return declare("dijit.form._ComboBoxMenu",[_WidgetBase, _TemplatedMixin, _ListMouseMixin, _ComboBoxMenuMixin], {
			// summary:
			//		Focus-less menu for internal use in `dijit/form/ComboBox`
			//		Abstract methods that must be defined externally:
			//
			//		- onChange: item was explicitly chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
			//		- onPage: next(1) or previous(-1) button pressed
			// tags:
			//		private
	
			// TODO for 2.0 or earlier: stop putting stuff inside this.containerNode.   Switch to using this.domNode
			// or a different attach point.    See _TemplatedMixin::searchContainerNode.
			templateString: "<div class='dijitReset dijitMenu' data-dojo-attach-point='containerNode' style='overflow: auto; overflow-x: hidden;' role='listbox'>"
					+"<div class='dijitMenuItem dijitMenuPreviousButton' data-dojo-attach-point='previousButton' role='option'></div>"
					+"<div class='dijitMenuItem dijitMenuNextButton' data-dojo-attach-point='nextButton' role='option'></div>"
					+"</div>",
	
			baseClass: "dijitComboBoxMenu",
	
			postCreate: function(){
				this.inherited(arguments);
				if(!this.isLeftToRight()){
					domClass.add(this.previousButton, "dijitMenuItemRtl");
					domClass.add(this.nextButton, "dijitMenuItemRtl");
				}
				this.containerNode.setAttribute("role","listbox");
			},
	
			_createMenuItem: function(){
				// note: not using domConstruct.create() because need to specify document
				var item = this.ownerDocument.createElement("div");
				item.className = "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl");
				item.setAttribute("role", "option");
				return item;
			},
	
			onHover: function(/*DomNode*/ node){
				// summary:
				//		Add hover CSS
				domClass.add(node, "dijitMenuItemHover");
			},
	
			onUnhover: function(/*DomNode*/ node){
				// summary:
				//		Remove hover CSS
				domClass.remove(node, "dijitMenuItemHover");
			},
	
			onSelect: function(/*DomNode*/ node){
				// summary:
				//		Add selected CSS
				domClass.add(node, "dijitMenuItemSelected");
			},
	
			onDeselect: function(/*DomNode*/ node){
				// summary:
				//		Remove selected CSS
				domClass.remove(node, "dijitMenuItemSelected");
			},
	
			_page: function(/*Boolean*/ up){
				// summary:
				//		Handles page-up and page-down keypresses
	
				var scrollamount = 0;
				var oldscroll = this.domNode.scrollTop;
				var height = domStyle.get(this.domNode, "height");
				// if no item is highlighted, highlight the first option
				if(!this.getHighlightedOption()){
					this.selectNextNode();
				}
				while(scrollamount<height){
					var highlighted_option = this.getHighlightedOption();
					if(up){
						// stop at option 1
						if(!highlighted_option.previousSibling ||
							highlighted_option.previousSibling.style.display == "none"){
							break;
						}
						this.selectPreviousNode();
					}else{
						// stop at last option
						if(!highlighted_option.nextSibling ||
							highlighted_option.nextSibling.style.display == "none"){
							break;
						}
						this.selectNextNode();
					}
					// going backwards
					var newscroll = this.domNode.scrollTop;
					scrollamount += (newscroll-oldscroll)*(up ? -1:1);
					oldscroll = newscroll;
				}
			},
	
			handleKey: function(evt){
				// summary:
				//		Handle keystroke event forwarded from ComboBox, returning false if it's
				//		a keystroke I recognize and process, true otherwise.
				switch(evt.keyCode){
					case keys.DOWN_ARROW:
						this.selectNextNode();
						return false;
					case keys.PAGE_DOWN:
						this._page(false);
						return false;
					case keys.UP_ARROW:
						this.selectPreviousNode();
						return false;
					case keys.PAGE_UP:
						this._page(true);
						return false;
					default:
						return true;
				}
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(14), 
		__webpack_require__(4),
		__webpack_require__(121),__webpack_require__(6), 
		__webpack_require__(194)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, domAttr, has, i18n,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_ComboBoxMenuMixin", (function(){
	
		// module:
		//		dijit/form/_ComboBoxMenuMixin
	
		var ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
			// summary:
			//		Focus-less menu for internal use in `dijit/form/ComboBox`
			// tags:
			//		private
	
			// _messages: Object
			//		Holds "next" and "previous" text for paging buttons on drop down
			_messages: null,
	
			postMixInProperties: function(){
				this.inherited(arguments);
				this._messages = i18n.getLocalization("dijit.form", "ComboBox", this.lang);
			},
	
			buildRendering: function(){
				this.inherited(arguments);
	
				// fill in template with i18n messages
				this.previousButton.innerHTML = this._messages["previousMessage"];
				this.nextButton.innerHTML = this._messages["nextMessage"];
			},
	
			_setValueAttr: function(/*Object*/ value){
				this._set("value", value);
				this.onChange(value);
			},
	
			onClick: function(/*DomNode*/ node){
				if(node == this.previousButton){
					this._setSelectedAttr(null);
					this.onPage(-1);
				}else if(node == this.nextButton){
					this._setSelectedAttr(null);
					this.onPage(1);
				}else{
					this.onChange(node);
				}
			},
	
			// stubs
			onChange: function(/*Number*/ /*===== direction =====*/){
				// summary:
				//		Notifies ComboBox/FilteringSelect that user selected an option.
				// tags:
				//		callback
			},
	
			onPage: function(/*Number*/ /*===== direction =====*/){
				// summary:
				//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
				// tags:
				//		callback
			},
	
			onClose: function(){
				// summary:
				//		Callback from dijit.popup code to this widget, notifying it that it closed
				// tags:
				//		private
				this._setSelectedAttr(null);
			},
	
			_createOption: function(/*Object*/ item, labelFunc){
				// summary:
				//		Creates an option to appear on the popup menu subclassed by
				//		`dijit/form/FilteringSelect`.
	
				var menuitem = this._createMenuItem();
				var labelObject = labelFunc(item);
				if(labelObject.html){
					menuitem.innerHTML = labelObject.label;
				}else{
					menuitem.appendChild(
						menuitem.ownerDocument.createTextNode(labelObject.label)
					);
				}
				// #3250: in blank options, assign a normal height
				if(menuitem.innerHTML == ""){
					menuitem.innerHTML = "&#160;";	// &nbsp;
				}
	
				return menuitem;
			},
	
			createOptions: function(results, options, labelFunc){
				// summary:
				//		Fills in the items in the drop down list
				// results:
				//		Array of items
				// options:
				//		The options to the query function of the store
				//
				// labelFunc:
				//		Function to produce a label in the drop down list from a dojo.data item
	
				this.items = results;
	
				// display "Previous . . ." button
				this.previousButton.style.display = (options.start == 0) ? "none" : "";
				domAttr.set(this.previousButton, "id", this.id + "_prev");
				// create options using _createOption function defined by parent
				// ComboBox (or FilteringSelect) class
				// #2309:
				//		iterate over cache nondestructively
				array.forEach(results, function(item, i){
					var menuitem = this._createOption(item, labelFunc);
					menuitem.setAttribute("item", i);	// index to this.items; use indirection to avoid mem leak
					domAttr.set(menuitem, "id", this.id + i);
					this.nextButton.parentNode.insertBefore(menuitem, this.nextButton);
				}, this);
				// display "Next . . ." button
				var displayMore = false;
				// Try to determine if we should show 'more'...
				if(results.total && !results.total.then && results.total != -1){
					if((options.start + options.count) < results.total){
						displayMore = true;
					}else if((options.start + options.count) > results.total && options.count == results.length){
						// Weird return from a data store, where a start + count > maxOptions
						// implies maxOptions isn't really valid and we have to go into faking it.
						// And more or less assume more if count == results.length
						displayMore = true;
					}
				}else if(options.count == results.length){
					//Don't know the size, so we do the best we can based off count alone.
					//So, if we have an exact match to count, assume more.
					displayMore = true;
				}
	
				this.nextButton.style.display = displayMore ? "" : "none";
				domAttr.set(this.nextButton, "id", this.id + "_next");
			},
	
			clearResultList: function(){
				// summary:
				//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
				var container = this.containerNode;
				while(container.childNodes.length > 2){
					container.removeChild(container.childNodes[container.childNodes.length - 2]);
				}
				this._setSelectedAttr(null);
			},
	
			highlightFirstOption: function(){
				// summary:
				//		Highlight the first real item in the list (not Previous Choices).
				this.selectFirstNode();
			},
	
			highlightLastOption: function(){
				// summary:
				//		Highlight the last real item in the list (not More Choices).
				this.selectLastNode();
			},
	
			selectFirstNode: function(){
				this.inherited(arguments);
				if(this.getHighlightedOption() == this.previousButton){
					this.selectNextNode();
				}
			},
	
			selectLastNode: function(){
				this.inherited(arguments);
				if(this.getHighlightedOption() == this.nextButton){
					this.selectPreviousNode();
				}
			},
	
			getHighlightedOption: function(){
				return this.selected;
			}
		});
	
		if(has("dojo-bidi")){
			ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin", ComboBoxMenuMixin, {
				_createOption: function(){
					var menuitem = this.inherited(arguments);
	
					// update menuitem.dir if BidiSupport was required
					this.applyTextDir(menuitem);
	
					return menuitem;
				}
			});
		}
	
		return ComboBoxMenuMixin;
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6),__webpack_require__(195),__webpack_require__(196)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire,lang_ru,lang_fr){return dojoWebpackLoaderRequire.register("dijit/form/nls/ComboBox", (function(){return {"root":{"previousMessage":"Previous choices","nextMessage":"More choices"},"ru":true,"fr":true};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/nls/ru/ComboBox", (function(){return {
			previousMessage: " ",
			nextMessage: " "
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function(dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/nls/fr/ComboBox", (function(){return {
			previousMessage: "Choix prcdents",
			nextMessage: "Plus de choix"
	};})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(18),
		__webpack_require__(81),
		__webpack_require__(198),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, on, touch, _ListBase,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_ListMouseMixin", (function(){
	
		// module:
		//		dijit/form/_ListMouseMixin
	
		return declare("dijit.form._ListMouseMixin", _ListBase, {
			// summary:
			//		A mixin to handle mouse or touch events for a focus-less menu
			//		Abstract methods that must be defined externally:
			//
			//		- onClick: item was chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
			// tags:
			//		private
	
			postCreate: function(){
				this.inherited(arguments);
	
				// Add flag to use normalized click handling from dojo/touch
				this.domNode.dojoClick = true;
	
				this._listConnect("click", "_onClick");
				this._listConnect("mousedown", "_onMouseDown");
				this._listConnect("mouseup", "_onMouseUp");
				this._listConnect("mouseover", "_onMouseOver");
				this._listConnect("mouseout", "_onMouseOut");
			},
	
			_onClick: function(/*Event*/ evt, /*DomNode*/ target){
				this._setSelectedAttr(target, false);
				if(this._deferredClick){
					this._deferredClick.remove();
				}
				this._deferredClick = this.defer(function(){
					this._deferredClick = null;
					this.onClick(target);
				});
			},
	
			_onMouseDown: function(/*Event*/ evt, /*DomNode*/ target){
				if(this._hoveredNode){
					this.onUnhover(this._hoveredNode);
					this._hoveredNode = null;
				}
				this._isDragging = true;
				this._setSelectedAttr(target, false);
			},
	
			_onMouseUp: function(/*Event*/ evt, /*DomNode*/ target){
				this._isDragging = false;
				var selectedNode = this.selected;
				var hoveredNode = this._hoveredNode;
				if(selectedNode && target == selectedNode){
					this.defer(function(){
						this._onClick(evt, selectedNode);
					});
				}else if(hoveredNode){ // drag to select
					this.defer(function(){
						this._onClick(evt, hoveredNode);
					});
				}
			},
	
			_onMouseOut: function(/*Event*/ evt, /*DomNode*/ target){
				if(this._hoveredNode){
					this.onUnhover(this._hoveredNode);
					this._hoveredNode = null;
				}
				if(this._isDragging){
					this._cancelDrag = (new Date()).getTime() + 1000; // cancel in 1 second if no _onMouseOver fires
				}
			},
	
			_onMouseOver: function(/*Event*/ evt, /*DomNode*/ target){
				if(this._cancelDrag){
					var time = (new Date()).getTime();
					if(time > this._cancelDrag){
						this._isDragging = false;
					}
					this._cancelDrag = null;
				}
				this._hoveredNode = target;
				this.onHover(target);
				if(this._isDragging){
					this._setSelectedAttr(target, false);
				}
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(18),
		__webpack_require__(91),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, on, winUtils,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_ListBase", (function(){
	
		// module:
		//		dijit/form/_ListBase
	
		return declare("dijit.form._ListBase", null, {
			// summary:
			//		Focus-less menu to handle UI events consistently.
			//		Abstract methods that must be defined externally:
			//
			//		- onSelect: item is active (mousedown but not yet mouseup, or keyboard arrow selected but no Enter)
			//		- onDeselect:  cancels onSelect
			// tags:
			//		private
	
			// selected: DOMNode
			//		currently selected node
			selected: null,
	
			_listConnect: function(/*String|Function*/ eventType, /*String*/ callbackFuncName){
				// summary:
				//		Connects 'containerNode' to specified method of this object
				//		and automatically registers for 'disconnect' on widget destroy.
				// description:
				//		Provide widget-specific analog to 'connect'.
				//		The callback function is called with the normal event object,
				//		but also a second parameter is passed that indicates which list item
				//		actually received the event.
				// returns:
				//		A handle that can be passed to `disconnect` in order to disconnect
				//		before the widget is destroyed.
				// tags:
				//		private
	
				var self = this;
				return self.own(on(self.containerNode,
					on.selector(
						function(eventTarget, selector, target){
							return eventTarget.parentNode == target;
						},
						eventType
					),
					function(evt){
						self[callbackFuncName](evt, this);
					}
				));
			},
	
			selectFirstNode: function(){
				// summary:
				//		Select the first displayed item in the list.
				var first = this.containerNode.firstChild;
				while(first && first.style.display == "none"){
					first = first.nextSibling;
				}
				this._setSelectedAttr(first, true);
			},
	
			selectLastNode: function(){
				// summary:
				//		Select the last displayed item in the list
				var last = this.containerNode.lastChild;
				while(last && last.style.display == "none"){
					last = last.previousSibling;
				}
				this._setSelectedAttr(last, true);
			},
	
			selectNextNode: function(){
				// summary:
				//		Select the item just below the current selection.
				//		If nothing selected, select first node.
				var selectedNode = this.selected;
				if(!selectedNode){
					this.selectFirstNode();
				}else{
					var next = selectedNode.nextSibling;
					while(next && next.style.display == "none"){
						next = next.nextSibling;
					}
					if(!next){
						this.selectFirstNode();
					}else{
						this._setSelectedAttr(next, true);
					}
				}
			},
	
			selectPreviousNode: function(){
				// summary:
				//		Select the item just above the current selection.
				//		If nothing selected, select last node (if
				//		you select Previous and try to keep scrolling up the list).
				var selectedNode = this.selected;
				if(!selectedNode){
					this.selectLastNode();
				}else{
					var prev = selectedNode.previousSibling;
					while(prev && prev.style.display == "none"){
						prev = prev.previousSibling;
					}
					if(!prev){
						this.selectLastNode();
					}else{
						this._setSelectedAttr(prev, true);
					}
				}
			},
	
			_setSelectedAttr: function(/*DomNode*/ node, /*Boolean*/ scroll){
				// summary:
				//		Does the actual select.
				// node:
				//		The option to select
				// scroll:
				//		If necessary, scroll node into view.  Set to false for mouse/touch to
				//		avoid jumping problems on mobile/RTL, see https://bugs.dojotoolkit.org/ticket/17739.
				if(this.selected != node){
					var selectedNode = this.selected;
					if(selectedNode){
						this.onDeselect(selectedNode);
					}
					if(node){
						if(scroll){
							winUtils.scrollIntoView(node);
						}
						this.onSelect(node);
					}
					this._set("selected", node);
				}else if(node){
					this.onSelect(node);
				}
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(1), 
		__webpack_require__(14), 
		__webpack_require__(2), 
		__webpack_require__(9), 
		__webpack_require__(96),
		__webpack_require__(76),
		__webpack_require__(200),
		__webpack_require__(149),__webpack_require__(6)
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(declare, domAttr, kernel, has, _Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/Form", (function(){
	
		// module:
		//		dijit/form/Form
	
	
		return declare("dijit.form.Form", [_Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin], {
			// summary:
			//		Widget corresponding to HTML form tag, for validation and serialization
			//
			// example:
			//	|	<form data-dojo-type="dijit/form/Form" id="myForm">
			//	|		Name: <input type="text" name="name" />
			//	|	</form>
			//	|	// Example assumes you have required dijit/registry
			//	|	myObj = {name: "John Doe"};
			//	|	registry.byId('myForm').set('value', myObj);
			//	|
			//	|	myObj=registry.byId('myForm').get('value');
	
			// HTML <FORM> attributes
	
			// name: String?
			//		Name of form for scripting.
			name: "",
	
			// action: String?
			//		Server-side form handler.
			action: "",
	
			// method: String?
			//		HTTP method used to submit the form, either "GET" or "POST".
			method: "",
	
			// encType: String?
			//		Encoding type for the form, ex: application/x-www-form-urlencoded.
			encType: "",
	
			// accept-charset: String?
			//		List of supported charsets.
			"accept-charset": "",
	
			// accept: String?
			//		List of MIME types for file upload.
			accept: "",
	
			// target: String?
			//		Target frame for the document to be opened in.
			target: "",
	
			templateString: "<form data-dojo-attach-point='containerNode' data-dojo-attach-event='onreset:_onReset,onsubmit:_onSubmit' ${!nameAttrSetting}></form>",
	
			postMixInProperties: function(){
				// Setup name=foo string to be referenced from the template (but only if a name has been specified)
				// Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8660
				this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
				this.inherited(arguments);
			},
	
			execute: function(/*Object*/ /*===== formContents =====*/){
				// summary:
				//		Deprecated: use submit()
				// tags:
				//		deprecated
			},
	
			onExecute: function(){
				// summary:
				//		Deprecated: use onSubmit()
				// tags:
				//		deprecated
			},
	
			_setEncTypeAttr: function(/*String*/ value){
				domAttr.set(this.domNode, "encType", value);
				if(has("ie")){
					this.domNode.encoding = value;
				}
				this._set("encType", value);
			},
	
			reset: function(/*Event?*/ e){
				// summary:
				//		restores all widget values back to their init values,
				//		calls onReset() which can cancel the reset by returning false
	
				// create fake event so we can know if preventDefault() is called
				var faux = {
					returnValue: true, // the IE way
					preventDefault: function(){ // not IE
						this.returnValue = false;
					},
					stopPropagation: function(){
					},
					currentTarget: e ? e.target : this.domNode,
					target: e ? e.target : this.domNode
				};
				// if return value is not exactly false, and haven't called preventDefault(), then reset
				if(!(this.onReset(faux) === false) && faux.returnValue){
					this.inherited(arguments, []);
				}
			},
	
			onReset: function(/*Event?*/ /*===== e =====*/){
				// summary:
				//		Callback when user resets the form. This method is intended
				//		to be over-ridden. When the `reset` method is called
				//		programmatically, the return value from `onReset` is used
				//		to compute whether or not resetting should proceed
				// tags:
				//		callback
				return true; // Boolean
			},
	
			_onReset: function(e){
				this.reset(e);
				e.stopPropagation();
				e.preventDefault();
				return false;
			},
	
			_onSubmit: function(e){
				var fp = this.constructor.prototype;
				// TODO: remove this if statement beginning with 2.0
				if(this.execute != fp.execute || this.onExecute != fp.onExecute){
					kernel.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
					this.onExecute();
					this.execute(this.getValues());
				}
				if(this.onSubmit(e) === false){ // only exactly false stops submit
					e.stopPropagation();
					e.preventDefault();
				}
			},
	
			onSubmit: function(/*Event?*/ /*===== e =====*/){
				// summary:
				//		Callback when user submits the form.
				// description:
				//		This method is intended to be over-ridden, but by default it checks and
				//		returns the validity of form elements. When the `submit`
				//		method is called programmatically, the return value from
				//		`onSubmit` is used to compute whether or not submission
				//		should proceed
				// tags:
				//		extension
	
				return this.isValid(); // Boolean
			},
	
			submit: function(){
				// summary:
				//		programmatically submit form if and only if the `onSubmit` returns true
				if(!(this.onSubmit() === false)){
					this.containerNode.submit();
				}
			}
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
		__webpack_require__(28), 
		__webpack_require__(1), 
		__webpack_require__(2), 
		__webpack_require__(8), 
		__webpack_require__(18),
		__webpack_require__(91),__webpack_require__(6) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(array, declare, kernel, lang, on, winUtils,dojoWebpackLoaderRequire){return dojoWebpackLoaderRequire.register("dijit/form/_FormMixin", (function(){
	
		// module:
		//		dijit/form/_FormMixin
	
		return declare("dijit.form._FormMixin", null, {
			// summary:
			//		Mixin for containers of form widgets (i.e. widgets that represent a single value
			//		and can be children of a `<form>` node or `dijit/form/Form` widget)
			// description:
			//		Can extract all the form widgets
			//		values and combine them into a single javascript object, or alternately
			//		take such an object and set the values for all the contained
			//		form widgets
	
		/*=====
			// value: Object
			//		Name/value hash for each child widget with a name and value.
			//		Child widgets without names are not part of the hash.
			//
			//		If there are multiple child widgets w/the same name, value is an array,
			//		unless they are radio buttons in which case value is a scalar (since only
			//		one radio button can be checked at a time).
			//
			//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
			//
			//		Example:
			//	|	{ name: "John Smith", interests: ["sports", "movies"] }
		=====*/
	
			// state: [readonly] String
			//		Will be "Error" if one or more of the child widgets has an invalid value,
			//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
			//		which indicates that the form is ready to be submitted.
			state: "",
	
			// TODO:
			//	* Repeater
			//	* better handling for arrays.  Often form elements have names with [] like
			//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
	
	
			_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){
				// summary:
				//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
				var res = [];
				array.forEach(children || this.getChildren(), function(child){
					if("value" in child){
						res.push(child);
					}else{
						res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
					}
				}, this);
				return res;
			},
	
			reset: function(){
				array.forEach(this._getDescendantFormWidgets(), function(widget){
					if(widget.reset){
						widget.reset();
					}
				});
			},
	
			validate: function(){
				// summary:
				//		returns if the form is valid - same as isValid - but
				//		provides a few additional (ui-specific) features:
				//
				//		1. it will highlight any sub-widgets that are not valid
				//		2. it will call focus() on the first invalid sub-widget
				var didFocus = false;
				return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
					// Need to set this so that "required" widgets get their
					// state set.
					widget._hasBeenBlurred = true;
					var valid = widget.disabled || !widget.validate || widget.validate();
					if(!valid && !didFocus){
						// Set focus of the first non-valid widget
						winUtils.scrollIntoView(widget.containerNode || widget.domNode);
						widget.focus();
						didFocus = true;
					}
					return valid;
				}), function(item){ return item; });
			},
	
			setValues: function(val){
				kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
				return this.set('value', val);
			},
			_setValueAttr: function(/*Object*/ obj){
				// summary:
				//		Fill in form values from according to an Object (in the format returned by get('value'))
	
				// generate map from name --> [list of widgets with that name]
				var map = { };
				array.forEach(this._getDescendantFormWidgets(), function(widget){
					if(!widget.name){ return; }
					var entry = map[widget.name] || (map[widget.name] = [] );
					entry.push(widget);
				});
	
				for(var name in map){
					if(!map.hasOwnProperty(name)){
						continue;
					}
					var widgets = map[name],						// array of widgets w/this name
						values = lang.getObject(name, false, obj);	// list of values for those widgets
	
					if(values === undefined){
						continue;
					}
					values = [].concat(values);
					if(typeof widgets[0].checked == 'boolean'){
						// for checkbox/radio, values is a list of which widgets should be checked
						array.forEach(widgets, function(w){
							w.set('value', array.indexOf(values, w._get('value')) != -1);
						});
					}else if(widgets[0].multiple){
						// it takes an array (e.g. multi-select)
						widgets[0].set('value', values);
					}else{
						// otherwise, values is a list of values to be assigned sequentially to each widget
						array.forEach(widgets, function(w, i){
							w.set('value', values[i]);
						});
					}
				}
	
				/***
				 *	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)
	
				array.forEach(this.containerNode.elements, function(element){
					if(element.name == ''){return};	// like "continue"
					var namePath = element.name.split(".");
					var myObj=obj;
					var name=namePath[namePath.length-1];
					for(var j=1,len2=namePath.length;j<len2;++j){
						var p=namePath[j - 1];
						// repeater support block
						var nameA=p.split("[");
						if(nameA.length > 1){
							if(typeof(myObj[nameA[0]]) == "undefined"){
								myObj[nameA[0]]=[ ];
							} // if
	
							nameIndex=parseInt(nameA[1]);
							if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
								myObj[nameA[0]][nameIndex] = { };
							}
							myObj=myObj[nameA[0]][nameIndex];
							continue;
						} // repeater support ends
	
						if(typeof(myObj[p]) == "undefined"){
							myObj=undefined;
							break;
						};
						myObj=myObj[p];
					}
	
					if(typeof(myObj) == "undefined"){
						return;		// like "continue"
					}
					if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
						return;		// like "continue"
					}
	
					// TODO: widget values (just call set('value', ...) on the widget)
	
					// TODO: maybe should call dojo.getNodeProp() instead
					switch(element.type){
						case "checkbox":
							element.checked = (name in myObj) &&
								array.some(myObj[name], function(val){ return val == element.value; });
							break;
						case "radio":
							element.checked = (name in myObj) && myObj[name] == element.value;
							break;
						case "select-multiple":
							element.selectedIndex=-1;
							array.forEach(element.options, function(option){
								option.selected = array.some(myObj[name], function(val){ return option.value == val; });
							});
							break;
						case "select-one":
							element.selectedIndex="0";
							array.forEach(element.options, function(option){
								option.selected = option.value == myObj[name];
							});
							break;
						case "hidden":
						case "text":
						case "textarea":
						case "password":
							element.value = myObj[name] || "";
							break;
					}
				});
				*/
	
				// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
				// which I am monitoring.
			},
	
			getValues: function(){
				kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
				return this.get('value');
			},
			_getValueAttr: function(){
				// summary:
				//		Returns Object representing form values.   See description of `value` for details.
				// description:
	
				// The value is updated into this.value every time a child has an onChange event,
				// so in the common case this function could just return this.value.   However,
				// that wouldn't work when:
				//
				// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
				// and even if it did it would come too late due to the defer(...) in _handleOnChange()
				//
				// 2. app for some reason calls this.get("value") while the user is typing into a
				// form field.   Not sure if that case needs to be supported or not.
	
				// get widget values
				var obj = { };
				array.forEach(this._getDescendantFormWidgets(), function(widget){
					var name = widget.name;
					if(!name || widget.disabled){ return; }
	
					// Single value widget (checkbox, radio, or plain <input> type widget)
					var value = widget.get('value');
	
					// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
					if(typeof widget.checked == 'boolean'){
						if(/Radio/.test(widget.declaredClass)){
							// radio button
							if(value !== false){
								lang.setObject(name, value, obj);
							}else{
								// give radio widgets a default of null
								value = lang.getObject(name, false, obj);
								if(value === undefined){
									lang.setObject(name, null, obj);
								}
							}
						}else{
							// checkbox/toggle button
							var ary=lang.getObject(name, false, obj);
							if(!ary){
								ary=[];
								lang.setObject(name, ary, obj);
							}
							if(value !== false){
								ary.push(value);
							}
						}
					}else{
						var prev=lang.getObject(name, false, obj);
						if(typeof prev != "undefined"){
							if(lang.isArray(prev)){
								prev.push(value);
							}else{
								lang.setObject(name, [prev, value], obj);
							}
						}else{
							// unique name
							lang.setObject(name, value, obj);
						}
					}
				});
	
				/***
				 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
				 * but it doesn't understand [] notation, presumably)
				var obj = { };
				array.forEach(this.containerNode.elements, function(elm){
					if(!elm.name)	{
						return;		// like "continue"
					}
					var namePath = elm.name.split(".");
					var myObj=obj;
					var name=namePath[namePath.length-1];
					for(var j=1,len2=namePath.length;j<len2;++j){
						var nameIndex = null;
						var p=namePath[j - 1];
						var nameA=p.split("[");
						if(nameA.length > 1){
							if(typeof(myObj[nameA[0]]) == "undefined"){
								myObj[nameA[0]]=[ ];
							} // if
							nameIndex=parseInt(nameA[1]);
							if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
								myObj[nameA[0]][nameIndex] = { };
							}
						}else if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]] = { }
						} // if
	
						if(nameA.length == 1){
							myObj=myObj[nameA[0]];
						}else{
							myObj=myObj[nameA[0]][nameIndex];
						} // if
					} // for
	
					if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
						if(name == name.split("[")[0]){
							myObj[name]=elm.value;
						}else{
							// can not set value when there is no name
						}
					}else if(elm.type == "checkbox" && elm.checked){
						if(typeof(myObj[name]) == 'undefined'){
							myObj[name]=[ ];
						}
						myObj[name].push(elm.value);
					}else if(elm.type == "select-multiple"){
						if(typeof(myObj[name]) == 'undefined'){
							myObj[name]=[ ];
						}
						for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
							if(elm.options[jdx].selected){
								myObj[name].push(elm.options[jdx].value);
							}
						}
					} // if
					name=undefined;
				}); // forEach
				***/
				return obj;
			},
	
			isValid: function(){
				// summary:
				//		Returns true if all of the widgets are valid.
				//		Deprecated, will be removed in 2.0.  Use get("state") instead.
	
				return this.state == "";
			},
	
			onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
				// summary:
				//		Stub function to connect to if you want to do something
				//		(like disable/enable a submit button) when the valid
				//		state changes on the form as a whole.
				//
				//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
			},
	
			_getState: function(){
				// summary:
				//		Compute what this.state should be based on state of children
				var states = array.map(this._descendants, function(w){
					return w.get("state") || "";
				});
	
				return array.indexOf(states, "Error") >= 0 ? "Error" :
					array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
			},
	
			disconnectChildren: function(){
				// summary:
				//		Deprecated method.   Applications no longer need to call this.   Remove for 2.0.
			},
	
			connectChildren: function(/*Boolean*/ inStartup){
				// summary:
				//		You can call this function directly, ex. in the event that you
				//		programmatically add a widget to the form *after* the form has been
				//		initialized.
	
				// TODO: rename for 2.0
	
				this._descendants = this._getDescendantFormWidgets();
	
				// To get notifications from children they need to be started.   Children didn't used to need to be started,
				// so for back-compat, start them here
				array.forEach(this._descendants, function(child){
					if(!child._started){ child.startup(); }
				});
	
				if(!inStartup){
					this._onChildChange();
				}
			},
	
			_onChildChange: function(/*String*/ attr){
				// summary:
				//		Called when child's value or disabled state changes
	
				// The unit tests expect state update to be synchronous, so update it immediately.
				if(!attr || attr == "state" || attr == "disabled"){
					this._set("state", this._getState());
				}
	
				// Use defer() to collapse value changes in multiple children into a single
				// update to my value.   Multiple updates will occur on:
				//	1. Form.set()
				//	2. Form.reset()
				//	3. user selecting a radio button (which will de-select another radio button,
				//		 causing two onChange events)
				if(!attr || attr == "value" || attr == "disabled" || attr == "checked"){
					if(this._onChangeDelayTimer){
						this._onChangeDelayTimer.remove();
					}
					this._onChangeDelayTimer = this.defer(function(){
						delete this._onChangeDelayTimer;
						this._set("value", this.get("value"));
					}, 10);
				}
			},
	
			startup: function(){
				this.inherited(arguments);
	
				// Set initial this.value and this.state.   Don't emit watch() notifications.
				this._descendants = this._getDescendantFormWidgets();
				this.value = this.get("value");
				this.state = this._getState();
	
				// Initialize value and valid/invalid state tracking.
				var self = this;
				this.own(
					on(
						this.containerNode,
						"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked",
						function(evt){
							if(evt.target == self.domNode){
								return;	// ignore events that I fire on myself because my children changed
							}
							self._onChildChange(evt.type.replace("attrmodified-", ""));
						}
					)
				);
	
				// Make state change call onValidStateChange(), will be removed in 2.0
				this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
			},
	
			destroy: function(){
				this.inherited(arguments);
			}
	
		});
	})());}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(122), __webpack_require__(8), __webpack_require__(51), __webpack_require__(1), __webpack_require__(189) 
	], __WEBPACK_AMD_DEFINE_RESULT__ = function(xhr, lang, JSON, declare, QueryResults /*=====, Store =====*/){
	
	// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
	var base = null;
	/*===== base = Store; =====*/
	
	/*=====
	var __HeaderOptions = {
			// headers: Object?
			//		Additional headers to send along with the request.
		},
		__PutDirectives = declare(Store.PutDirectives, __HeaderOptions),
		__QueryOptions = declare(Store.QueryOptions, __HeaderOptions);
	=====*/
	
	return declare("dojo.store.JsonRest", base, {
		// summary:
		//		This is a basic store for RESTful communicating with a server through JSON
		//		formatted data. It implements dojo/store/api/Store.
	
		constructor: function(options){
			// summary:
			//		This is a basic store for RESTful communicating with a server through JSON
			//		formatted data.
			// options: dojo/store/JsonRest
			//		This provides any configuration information that will be mixed into the store
			this.headers = {};
			declare.safeMixin(this, options);
		},
	
		// headers: Object
		//		Additional headers to pass in all requests to the server. These can be overridden
		//		by passing additional headers to calls to the store.
		headers: {},
	
		// target: String
		//		The target base URL to use for all requests to the server. This string will be
		//		prepended to the id to generate the URL (relative or absolute) for requests
		//		sent to the server
		target: "",
	
		// idProperty: String
		//		Indicates the property to use as the identity property. The values of this
		//		property should be unique.
		idProperty: "id",
	
		// rangeParam: String
		//		Use a query parameter for the requested range. If this is omitted, than the
		//		Range header will be used. Independent of this, the X-Range header is always set.
	
		// sortParam: String
		//		The query parameter to used for holding sort information. If this is omitted, than
		//		the sort information is included in a functional query token to avoid colliding
		//		with the set of name/value pairs.
	
		// ascendingPrefix: String
		//		The prefix to apply to sort attribute names that are ascending
		ascendingPrefix: "+",
	
		// descendingPrefix: String
		//		The prefix to apply to sort attribute names that are ascending
		descendingPrefix: "-",
	
		_getTarget: function(id){
			// summary:
			//		If the target has no trailing '/', then append it.
			// id: Number
			//		The identity of the requested target
			var target = this.target;
			if(typeof id != "undefined"){
				if( (target.charAt(target.length-1) == '/') || (target.charAt(target.length-1) == '=')){
					target += id;
				}else{
					target += '/' + id;
				}
			}
			return target;
		},
	
		get: function(id, options){
			// summary:
			//		Retrieves an object by its identity. This will trigger a GET request to the server using
			//		the url `this.target + id`.
			// id: Number
			//		The identity to use to lookup the object
			// options: Object?
			//		HTTP headers. For consistency with other methods, if a `headers` key exists on this object, it will be
			//		used to provide HTTP headers instead.
			// returns: Object
			//		The object in the store that matches the given id.
			options = options || {};
			var headers = lang.mixin({ Accept: this.accepts }, this.headers, options.headers || options);
			return xhr("GET", {
				url: this._getTarget(id),
				handleAs: "json",
				headers: headers
			});
		},
	
		// accepts: String
		//		Defines the Accept header to use on HTTP requests
		accepts: "application/javascript, application/json",
	
		getIdentity: function(object){
			// summary:
			//		Returns an object's identity
			// object: Object
			//		The object to get the identity from
			// returns: Number
			return object[this.idProperty];
		},
	
		put: function(object, options){
			// summary:
			//		Stores an object. This will trigger a PUT request to the server
			//		if the object has an id, otherwise it will trigger a POST request.
			// object: Object
			//		The object to store.
			// options: __PutDirectives?
			//		Additional metadata for storing the data.  Includes an "id"
			//		property if a specific id is to be used.
			// returns: dojo/_base/Deferred
			options = options || {};
			var id = ("id" in options) ? options.id : this.getIdentity(object);
			var hasId = typeof id != "undefined";
			return xhr(hasId && !options.incremental ? "PUT" : "POST", {
					url: this._getTarget(id),
					postData: JSON.stringify(object),
					handleAs: "json",
					headers: lang.mixin({
						"Content-Type": "application/json",
						Accept: this.accepts,
						"If-Match": options.overwrite === true ? "*" : null,
						"If-None-Match": options.overwrite === false ? "*" : null
					}, this.headers, options.headers)
				});
		},
	
		add: function(object, options){
			// summary:
			//		Adds an object. This will trigger a PUT request to the server
			//		if the object has an id, otherwise it will trigger a POST request.
			// object: Object
			//		The object to store.
			// options: __PutDirectives?
			//		Additional metadata for storing the data.  Includes an "id"
			//		property if a specific id is to be used.
			options = options || {};
			options.overwrite = false;
			return this.put(object, options);
		},
	
		remove: function(id, options){
			// summary:
			//		Deletes an object by its identity. This will trigger a DELETE request to the server.
			// id: Number
			//		The identity to use to delete the object
			// options: __HeaderOptions?
			//		HTTP headers.
			options = options || {};
			return xhr("DELETE", {
				url: this._getTarget(id),
				headers: lang.mixin({}, this.headers, options.headers)
			});
		},
	
		query: function(query, options){
			// summary:
			//		Queries the store for objects. This will trigger a GET request to the server, with the
			//		query added as a query string.
			// query: Object
			//		The query to use for retrieving objects from the store.
			// options: __QueryOptions?
			//		The optional arguments to apply to the resultset.
			// returns: dojo/store/api/Store.QueryResults
			//		The results of the query, extended with iterative methods.
			options = options || {};
	
			var headers = lang.mixin({ Accept: this.accepts }, this.headers, options.headers);
	
			var hasQuestionMark = this.target.indexOf("?") > -1;
			query = query || ""; // https://bugs.dojotoolkit.org/ticket/17628
			if(query && typeof query == "object"){
				query = xhr.objectToQuery(query);
				query = query ? (hasQuestionMark ? "&" : "?") + query: "";
			}
			if(options.start >= 0 || options.count >= 0){
				headers["X-Range"] = "items=" + (options.start || '0') + '-' +
					(("count" in options && options.count != Infinity) ?
						(options.count + (options.start || 0) - 1) : '');
				if(this.rangeParam){
					query += (query || hasQuestionMark ? "&" : "?") + this.rangeParam + "=" + headers["X-Range"];
					hasQuestionMark = true;
				}else{
					headers.Range = headers["X-Range"];
				}
			}
			if(options && options.sort){
				var sortParam = this.sortParam;
				query += (query || hasQuestionMark ? "&" : "?") + (sortParam ? sortParam + '=' : "sort(");
				for(var i = 0; i<options.sort.length; i++){
					var sort = options.sort[i];
					query += (i > 0 ? "," : "") + (sort.descending ? this.descendingPrefix : this.ascendingPrefix) + encodeURIComponent(sort.attribute);
				}
				if(!sortParam){
					query += ")";
				}
			}
			var results = xhr("GET", {
				url: this.target + (query || ""),
				handleAs: "json",
				headers: headers
			});
			results.total = results.then(function(){
				var range = results.ioArgs.xhr.getResponseHeader("Content-Range");
				if (!range){
					// At least Chrome drops the Content-Range header from cached replies.
					range = results.ioArgs.xhr.getResponseHeader("X-Content-Range");
				}
				return range && (range = range.match(/\/(.*)/)) && +range[1];
			});
			return QueryResults(results);
		}
	});
	
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }
/******/ ]);
//# sourceMappingURL=dijit_03_form.bundle.js.map